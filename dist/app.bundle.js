/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./css/editor.scss":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./css/editor.scss ***!
  \************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Basic editor styles */\\n.ProseMirror > * + * {\\n  margin-top: 0.75em; }\\n\\n.ProseMirror img {\\n  max-width: 100%;\\n  height: auto; }\\n  .ProseMirror img.ProseMirror-selectednode {\\n    outline: 3px solid #68CEF8; }\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://cms_git/./css/editor.scss?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./css/style.css":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./css/style.css ***!
  \**********************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \":root {\\n  --black: rgb(42 48 58);\\n  --grey: rgb(100 116 139);\\n  --grey_light: rgb(100 116 139 / 0.2);\\n  --grey_lightest: rgb(100 116 139 / 0.1);\\n  --accent: rgb(79 70 229);\\n  --font_size: 16px;\\n  --padding_sm: 1em;\\n  --padding_md: 2em; }\\n\\nbody {\\n  margin: 1em 2em;\\n  font-family: sans-serif;\\n  font-size: var(--font_size);\\n  color: var(--black); }\\n\\nbody > * {\\n  margin-bottom: 1em; }\\n\\nul,\\nli {\\n  list-style: none;\\n  padding: 0;\\n  margin: auto 0; }\\n\\ndiv[data-netlify-identity-menu] {\\n  display: flex;\\n  justify-content: end; }\\n\\ndiv[data-netlify-identity-menu] ul {\\n  display: flex;\\n  gap: 1em; }\\n\\n.btn {\\n  border-radius: 0.5rem;\\n  background-color: var(--accent);\\n  color: white;\\n  border-width: 1px;\\n  border-color: var(--accent);\\n  padding: 0.5em 1em;\\n  font-size: 1em;\\n  border-style: solid;\\n  cursor: pointer; }\\n\\n.btn-default {\\n  background-color: white;\\n  border-color: var(--grey);\\n  color: var(--grey); }\\n\\n.card {\\n  border-radius: 0.5rem;\\n  padding: var(--padding_md);\\n  /* box-shadow: rgb(0 0 0 / 10%) 0 4px 6px -1px, rgb(0 0 0 / 10%) 0 2px 4px -2px; */\\n  border: 1px solid var(--grey_light);\\n  gap: 1em;\\n  display: flex;\\n  flex-direction: column; }\\n\\ncontent {\\n  display: flex;\\n  gap: 2em;\\n  flex-wrap: wrap; }\\n\\nbody aside {\\n  min-width: 20rem; }\\n\\naside .card {\\n  padding: var(--padding_sm); }\\n\\n.new-file {\\n  display: flex;\\n  flex-direction: column;\\n  flex-wrap: wrap;\\n  gap: 0.5em; }\\n\\n.new-file > * {\\n  width: fit-content; }\\n\\nbody main {\\n  flex-grow: 1;\\n  width: calc(100% - 22rem);\\n  gap: 2rem;\\n  display: flex;\\n  flex-direction: column; }\\n\\na[data-type=\\\"dir\\\"] {\\n  color: var(--grey); }\\n\\na[data-type=\\\"file\\\"] {\\n  cursor: pointer; }\\n\\n#files li a {\\n  padding: 0.5em;\\n  display: flex;\\n  border-radius: 0.5rem;\\n  margin: 0.1em 0; }\\n\\n#files li a:hover {\\n  background: var(--grey_lightest); }\\n\\n#files li:not(:last-child) {\\n  border-bottom: 1px solid var(--grey_light); }\\n\\n.container,\\n.element .ProseMirror {\\n  padding: 1em;\\n  border: 1px solid var(--grey_light);\\n  border-radius: 0.5em; }\\n\\n@media (max-width: 50em) {\\n  body aside {\\n    width: 100%; }\\n  body main {\\n    width: 100%; } }\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://cms_git/./css/style.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/toastify-js/src/toastify.css":
/*!**************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/toastify-js/src/toastify.css ***!
  \**************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*!\\n * Toastify js 1.12.0\\n * https://github.com/apvarun/toastify-js\\n * @license MIT licensed\\n *\\n * Copyright (C) 2018 Varun A P\\n */\\n.toastify {\\n  padding: 12px 20px;\\n  color: #ffffff;\\n  display: inline-block;\\n  box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);\\n  background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);\\n  background: linear-gradient(135deg, #73a5ff, #5477f5);\\n  position: fixed;\\n  opacity: 0;\\n  transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);\\n  border-radius: 2px;\\n  cursor: pointer;\\n  text-decoration: none;\\n  max-width: calc(50% - 20px);\\n  z-index: 2147483647; }\\n\\n.toastify.on {\\n  opacity: 1; }\\n\\n.toast-close {\\n  background: transparent;\\n  border: 0;\\n  color: white;\\n  cursor: pointer;\\n  font-family: inherit;\\n  font-size: 1em;\\n  opacity: 0.4;\\n  padding: 0 5px; }\\n\\n.toastify-right {\\n  right: 15px; }\\n\\n.toastify-left {\\n  left: 15px; }\\n\\n.toastify-top {\\n  top: -150px; }\\n\\n.toastify-bottom {\\n  bottom: -150px; }\\n\\n.toastify-rounded {\\n  border-radius: 25px; }\\n\\n.toastify-avatar {\\n  width: 1.5em;\\n  height: 1.5em;\\n  margin: -7px 5px;\\n  border-radius: 2px; }\\n\\n.toastify-center {\\n  margin-left: auto;\\n  margin-right: auto;\\n  left: 0;\\n  right: 0;\\n  max-width: fit-content;\\n  max-width: -moz-fit-content; }\\n\\n@media only screen and (max-width: 360px) {\\n  .toastify-right, .toastify-left {\\n    margin-left: auto;\\n    margin-right: auto;\\n    left: 0;\\n    right: 0;\\n    max-width: fit-content; } }\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://cms_git/./node_modules/toastify-js/src/toastify.css?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./css/style.js":
/*!**********************!*\
  !*** ./css/style.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ \"./css/style.css\");\n/* harmony import */ var _editor_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./editor.scss */ \"./css/editor.scss\");\n/* harmony import */ var toastify_js_src_toastify_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! toastify-js/src/toastify.css */ \"./node_modules/toastify-js/src/toastify.css\");\n\n\n\n\n\n//# sourceURL=webpack://cms_git/./css/style.js?");

/***/ }),

/***/ "./js/github.js":
/*!**********************!*\
  !*** ./js/github.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchData\": () => (/* binding */ fetchData),\n/* harmony export */   \"getData\": () => (/* binding */ getData),\n/* harmony export */   \"saveData\": () => (/* binding */ saveData)\n/* harmony export */ });\n/* harmony import */ var netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! netlify-identity-widget */ \"./node_modules/netlify-identity-widget/build/netlify-identity.js\");\n/* harmony import */ var netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0__);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\nlet netlifyAddresse = \"\";\nif (true) {\n  netlifyAddresse = \"https://cms-laurent.netlify.app\";\n}\nfunction getData(mypath = \"\") {\n  return __async(this, null, function* () {\n    const user = netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().currentUser();\n    const token = user.token.access_token;\n    const url = `${netlifyAddresse}/.netlify/git/github/contents/${mypath}`;\n    const bearer = `Bearer ${token}`;\n    return fetch(url, {\n      method: \"GET\",\n      withCredentials: true,\n      credentials: \"include\",\n      headers: {\n        Authorization: bearer,\n        \"Content-Type\": \"application/json\"\n      }\n    }).then((resp) => resp.json()).then((data) => {\n      if (data.code == 400) {\n        netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().refresh().then(function(token2) {\n          getData(mypath);\n        });\n      } else {\n        data.content = atob(data.content);\n        return data;\n      }\n    }).catch((error) => error);\n  });\n}\nfunction fetchData(mypath = \"\") {\n  return __async(this, null, function* () {\n    const user = netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().currentUser();\n    const token = user.token.access_token;\n    const url = `${netlifyAddresse}/.netlify/git/github/contents/${mypath}`;\n    const bearer = `Bearer ${token}`;\n    return fetch(url, {\n      method: \"GET\",\n      withCredentials: true,\n      credentials: \"include\",\n      headers: {\n        Authorization: bearer,\n        \"Content-Type\": \"application/json\"\n      }\n    }).then((resp) => resp.json()).then((data) => {\n      if (data.code == 400) {\n        netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().refresh().then(function(token2) {\n          getData(mypath);\n        });\n      } else {\n        return data;\n      }\n    }).catch((error) => error);\n  });\n}\nfunction saveData(mypath, data) {\n  return __async(this, null, function* () {\n    return getData(mypath).then(function(curfile) {\n      const user = netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().currentUser();\n      const token = user.token.access_token;\n      const opts = {\n        path: mypath,\n        message: \"initial commit\",\n        content: btoa(data),\n        branch: \"main\",\n        committer: { name: \"Dashpilot\", email: \"support@dashpilot.com\" }\n      };\n      if (typeof curfile !== \"undefined\") {\n        opts.sha = curfile.sha;\n      }\n      const url = `${netlifyAddresse}/.netlify/git/github/contents/${mypath}`;\n      const bearer = `Bearer ${token}`;\n      return fetch(url, {\n        body: JSON.stringify(opts),\n        method: \"PUT\",\n        withCredentials: true,\n        credentials: \"include\",\n        headers: {\n          Authorization: bearer,\n          \"Content-Type\": \"application/json\"\n        }\n      }).then((resp) => resp.json()).then((data2) => {\n        if (data2.code == 400) {\n          netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().refresh().then(function(token2) {\n            saveData(mypath);\n          });\n        } else {\n          return data2;\n        }\n      }).catch((error) => this.setState({\n        message: `Error: ${error}`\n      }));\n    });\n  });\n}\n\n\n\n//# sourceURL=webpack://cms_git/./js/github.js?");

/***/ }),

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! netlify-identity-widget */ \"./node_modules/netlify-identity-widget/build/netlify-identity.js\");\n/* harmony import */ var netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var toastify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! toastify-js */ \"./node_modules/toastify-js/src/toastify.js\");\n/* harmony import */ var toastify_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(toastify_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var showdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! showdown */ \"./node_modules/showdown/dist/showdown.js\");\n/* harmony import */ var showdown__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(showdown__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _github__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./github */ \"./js/github.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n/* harmony import */ var _tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/starter-kit */ \"./node_modules/@tiptap/starter-kit/dist/tiptap-starter-kit.esm.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-document */ \"./node_modules/@tiptap/extension-document/dist/tiptap-extension-document.esm.js\");\n/* harmony import */ var _tiptap_extension_placeholder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-placeholder */ \"./node_modules/@tiptap/extension-placeholder/dist/tiptap-extension-placeholder.esm.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"./node_modules/@tiptap/extension-paragraph/dist/tiptap-extension-paragraph.esm.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-text */ \"./node_modules/@tiptap/extension-text/dist/tiptap-extension-text.esm.js\");\n/* harmony import */ var _tiptap_extension_image__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-image */ \"./node_modules/@tiptap/extension-image/dist/tiptap-extension-image.esm.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"./node_modules/@tiptap/extension-dropcursor/dist/tiptap-extension-dropcursor.esm.js\");\n/* harmony import */ var _css_style_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../css/style.js */ \"./css/style.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().init();\n  const resultSelector = document.querySelector(\"#result\");\n  const filesSelector = document.querySelector(\"#files\");\n  const pathSelector = document.querySelector(\"#path\");\n  const saveBtn = document.querySelector(\"#save\");\n  const readBtn = document.querySelector(\"#read\");\n  const createBtn = document.querySelector(\"#create\");\n  const createInput = document.querySelector(\"#filename\");\n  const avatarInput = document.querySelector(\"#avatar\");\n  const netlifyUser = netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().currentUser();\n  let workingFile = \"newfile.txt\";\n  let isRaw;\n  let newContent = \"\";\n  const ignoreFile = [\".eslintrc\", \".gitignore\", \".stylelintrc\", \"package.json\", \"yarn.lock\"];\n  const rawFileArr = [\".html\", \".jpg\", \".jpeg\", \".png\"];\n  const mediaFileArr = [\".jpg\", \".jpeg\", \".png\"];\n  netlify_identity_widget__WEBPACK_IMPORTED_MODULE_0___default().on(\"login\", function() {\n    getContent(workingFile);\n    displayContent();\n    console.log(\"login\");\n  });\n  const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_12__.Editor({\n    element: document.querySelector(\".element\"),\n    content: \"<p>Hello World!</p>\",\n    extensions: [\n      _tiptap_extension_image__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n      _tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n      _tiptap_extension_placeholder__WEBPACK_IMPORTED_MODULE_6__[\"default\"].configure({\n        placeholder: ({ node }) => {\n          if (node.type.name === \"heading\") {\n            return \"What\\u2019s the title?\";\n          }\n          return \"Can you add some further context?\";\n        }\n      })\n    ]\n  });\n  saveBtn.addEventListener(\"click\", function() {\n    saveContent(workingFile, isRaw);\n  });\n  createBtn.addEventListener(\"click\", function() {\n    const file = createInput.value;\n    const dataContent = atob(newContent.replace(/^(.+,)/, \"\"));\n    (0,_github__WEBPACK_IMPORTED_MODULE_3__.saveData)(file, dataContent).then(function() {\n      showNotif(\"File created \\u{1F389}\");\n    });\n  });\n  avatarInput.addEventListener(\"change\", handleFileSelect, false);\n  function handleFileSelect(event) {\n    const reader = new FileReader();\n    reader.readAsDataURL(event.target.files[0]);\n    reader.onload = handleFileLoad;\n  }\n  function handleFileLoad(event) {\n    newContent = event.target.result;\n    console.log({ newContent });\n  }\n  readBtn.addEventListener(\"click\", function() {\n    getContent(workingFile);\n  });\n  document.addEventListener(\"click\", function(e) {\n    if (e.target.dataset.name && e.target.dataset.type === \"file\") {\n      const fileName = e.target.dataset.name;\n      const fileNameRaw = e.target.dataset.raw;\n      const fileNameMedia = e.target.dataset.media;\n      isRaw = e.target.dataset.raw;\n      workingFile = fileName;\n      pathSelector.innerHTML = workingFile;\n      getContent(fileName, fileNameRaw, fileNameMedia);\n    }\n  });\n  if (netlifyUser) {\n    getContent(workingFile);\n    pathSelector.innerHTML = workingFile;\n    displayContent();\n  } else {\n  }\n  function getContent(file, type, media) {\n    (0,_github__WEBPACK_IMPORTED_MODULE_3__.getData)(file, type, media).then(function(result) {\n      const data = result.content;\n      if (type !== \"true\") {\n        console.log(\"not raw\");\n        const converter = new (showdown__WEBPACK_IMPORTED_MODULE_2___default().Converter)();\n        const html = converter.makeHtml(data);\n        resultSelector.style.whiteSpace = \"inherit\";\n        resultSelector.innerHTML = data;\n        editor.commands.setContent(html);\n      } else if (media != \"true\") {\n        console.log(\"raw\");\n        resultSelector.style.whiteSpace = \"break-spaces\";\n        resultSelector.innerText = data;\n        editor.commands.setContent(data);\n      } else {\n        console.log(\"raw and image\");\n        resultSelector.innerHTML = `<img style=\"max-width:100%\" src=\"${result.download_url}\"/>`;\n        editor.commands.setContent(`<img style=\"max-width:100%\" src=\"${result.download_url}\"/>`);\n      }\n    });\n  }\n  function saveContent(file, type) {\n    console.log({ type });\n    let dataContent;\n    if (type !== \"true\") {\n      dataContent = resultSelector.innerHTML;\n    } else {\n      dataContent = resultSelector.innerText;\n    }\n    (0,_github__WEBPACK_IMPORTED_MODULE_3__.saveData)(file, dataContent).then(function(result) {\n      showNotif();\n    });\n  }\n  function displayContent() {\n    (0,_github__WEBPACK_IMPORTED_MODULE_3__.fetchData)().then(function(result) {\n      buildTreeFiles(result);\n    });\n  }\n  function buildTreeFiles(data) {\n    let html = \"\";\n    let file = \"\";\n    for (file of data) {\n      if (ignoreFile.indexOf(file.name) === -1) {\n        const fileName = file.name;\n        const isRawFile = rawFileArr.some((rawFile) => fileName.includes(rawFile));\n        const isMediaFile = mediaFileArr.some((mediaFile) => fileName.includes(mediaFile));\n        html += \"<li>\";\n        html += `<a data-name=\"${file.name}\" data-type=\"${file.type}\" data-raw=\"${isRawFile}\" data-media=\"${isMediaFile}\">${file.name}</a>`;\n        html += \"</li>\";\n      }\n    }\n    filesSelector.innerHTML = html;\n  }\n  function showNotif(msgTxt = \"File saved \\u{1F389}\") {\n    toastify_js__WEBPACK_IMPORTED_MODULE_1___default()({\n      text: msgTxt,\n      duration: 2e3,\n      gravity: \"bottom\",\n      position: \"center\",\n      style: {\n        background: \"rgb(79 70 229)\",\n        color: \"white\",\n        borderRadius: \"0.5rem\"\n      }\n    }).showToast();\n  }\n});\n\n\n//# sourceURL=webpack://cms_git/./js/index.js?");

/***/ }),

/***/ "./node_modules/@tiptap/core/dist/tiptap-core.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/tiptap-core.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CommandManager\": () => (/* binding */ CommandManager),\n/* harmony export */   \"Editor\": () => (/* binding */ Editor),\n/* harmony export */   \"Extension\": () => (/* binding */ Extension),\n/* harmony export */   \"InputRule\": () => (/* binding */ InputRule),\n/* harmony export */   \"Mark\": () => (/* binding */ Mark),\n/* harmony export */   \"Node\": () => (/* binding */ Node),\n/* harmony export */   \"NodeView\": () => (/* binding */ NodeView),\n/* harmony export */   \"PasteRule\": () => (/* binding */ PasteRule),\n/* harmony export */   \"Tracker\": () => (/* binding */ Tracker),\n/* harmony export */   \"callOrReturn\": () => (/* binding */ callOrReturn),\n/* harmony export */   \"combineTransactionSteps\": () => (/* binding */ combineTransactionSteps),\n/* harmony export */   \"defaultBlockAt\": () => (/* binding */ defaultBlockAt),\n/* harmony export */   \"escapeForRegEx\": () => (/* binding */ escapeForRegEx),\n/* harmony export */   \"extensions\": () => (/* binding */ extensions),\n/* harmony export */   \"findChildren\": () => (/* binding */ findChildren),\n/* harmony export */   \"findChildrenInRange\": () => (/* binding */ findChildrenInRange),\n/* harmony export */   \"findParentNode\": () => (/* binding */ findParentNode),\n/* harmony export */   \"findParentNodeClosestToPos\": () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   \"generateHTML\": () => (/* binding */ generateHTML),\n/* harmony export */   \"generateJSON\": () => (/* binding */ generateJSON),\n/* harmony export */   \"generateText\": () => (/* binding */ generateText),\n/* harmony export */   \"getAttributes\": () => (/* binding */ getAttributes),\n/* harmony export */   \"getChangedRanges\": () => (/* binding */ getChangedRanges),\n/* harmony export */   \"getDebugJSON\": () => (/* binding */ getDebugJSON),\n/* harmony export */   \"getExtensionField\": () => (/* binding */ getExtensionField),\n/* harmony export */   \"getHTMLFromFragment\": () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   \"getMarkAttributes\": () => (/* binding */ getMarkAttributes),\n/* harmony export */   \"getMarkRange\": () => (/* binding */ getMarkRange),\n/* harmony export */   \"getMarkType\": () => (/* binding */ getMarkType),\n/* harmony export */   \"getMarksBetween\": () => (/* binding */ getMarksBetween),\n/* harmony export */   \"getNodeAttributes\": () => (/* binding */ getNodeAttributes),\n/* harmony export */   \"getNodeType\": () => (/* binding */ getNodeType),\n/* harmony export */   \"getSchema\": () => (/* binding */ getSchema),\n/* harmony export */   \"getText\": () => (/* binding */ getText),\n/* harmony export */   \"getTextBetween\": () => (/* binding */ getTextBetween),\n/* harmony export */   \"getTextContentFromNodes\": () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   \"getTextSerializersFromSchema\": () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   \"inputRulesPlugin\": () => (/* binding */ inputRulesPlugin),\n/* harmony export */   \"isActive\": () => (/* binding */ isActive),\n/* harmony export */   \"isList\": () => (/* binding */ isList),\n/* harmony export */   \"isMarkActive\": () => (/* binding */ isMarkActive),\n/* harmony export */   \"isNodeActive\": () => (/* binding */ isNodeActive),\n/* harmony export */   \"isNodeEmpty\": () => (/* binding */ isNodeEmpty),\n/* harmony export */   \"isNodeSelection\": () => (/* binding */ isNodeSelection),\n/* harmony export */   \"isTextSelection\": () => (/* binding */ isTextSelection),\n/* harmony export */   \"markInputRule\": () => (/* binding */ markInputRule),\n/* harmony export */   \"markPasteRule\": () => (/* binding */ markPasteRule),\n/* harmony export */   \"mergeAttributes\": () => (/* binding */ mergeAttributes),\n/* harmony export */   \"nodeInputRule\": () => (/* binding */ nodeInputRule),\n/* harmony export */   \"nodePasteRule\": () => (/* binding */ nodePasteRule),\n/* harmony export */   \"pasteRulesPlugin\": () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   \"posToDOMRect\": () => (/* binding */ posToDOMRect),\n/* harmony export */   \"textInputRule\": () => (/* binding */ textInputRule),\n/* harmony export */   \"textPasteRule\": () => (/* binding */ textPasteRule),\n/* harmony export */   \"textblockTypeInputRule\": () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   \"wrappingInputRule\": () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-view */ \"./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ \"./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-commands */ \"./node_modules/prosemirror-commands/dist/index.js\");\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! prosemirror-schema-list */ \"./node_modules/prosemirror-schema-list/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n\n\n\n\n\n\nfunction createChainableState(config) {\n  const { state, transaction } = config;\n  let { selection } = transaction;\n  let { doc } = transaction;\n  let { storedMarks } = transaction;\n  return __spreadProps(__spreadValues({}, state), {\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    filterTransaction: state.filterTransaction,\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks;\n    },\n    get selection() {\n      return selection;\n    },\n    get doc() {\n      return doc;\n    },\n    get tr() {\n      selection = transaction.selection;\n      doc = transaction.doc;\n      storedMarks = transaction.storedMarks;\n      return transaction;\n    }\n  });\n}\nclass CommandManager {\n  constructor(props) {\n    this.editor = props.editor;\n    this.rawCommands = this.editor.extensionManager.commands;\n    this.customState = props.state;\n  }\n  get hasCustomState() {\n    return !!this.customState;\n  }\n  get state() {\n    return this.customState || this.editor.state;\n  }\n  get commands() {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const { tr } = state;\n    const props = this.buildProps(tr);\n    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {\n      const method = (...args) => {\n        const callback = command2(...args)(props);\n        if (!tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n          view.dispatch(tr);\n        }\n        return callback;\n      };\n      return [name, method];\n    }));\n  }\n  get chain() {\n    return () => this.createChain();\n  }\n  get can() {\n    return () => this.createCan();\n  }\n  createChain(startTr, shouldDispatch = true) {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    const callbacks = [];\n    const hasStartTransaction = !!startTr;\n    const tr = startTr || state.tr;\n    const run2 = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n        view.dispatch(tr);\n      }\n      return callbacks.every((callback) => callback === true);\n    };\n    const chain = __spreadProps(__spreadValues({}, Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {\n      const chainedCommand = (...args) => {\n        const props = this.buildProps(tr, shouldDispatch);\n        const callback = command2(...args)(props);\n        callbacks.push(callback);\n        return chain;\n      };\n      return [name, chainedCommand];\n    }))), {\n      run: run2\n    });\n    return chain;\n  }\n  createCan(startTr) {\n    const { rawCommands, state } = this;\n    const dispatch = false;\n    const tr = startTr || state.tr;\n    const props = this.buildProps(tr, dispatch);\n    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {\n      return [name, (...args) => command2(...args)(__spreadProps(__spreadValues({}, props), { dispatch: void 0 }))];\n    }));\n    return __spreadProps(__spreadValues({}, formattedCommands), {\n      chain: () => this.createChain(tr, dispatch)\n    });\n  }\n  buildProps(tr, shouldDispatch = true) {\n    const { rawCommands, editor, state } = this;\n    const { view } = editor;\n    if (state.storedMarks) {\n      tr.setStoredMarks(state.storedMarks);\n    }\n    const props = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr\n      }),\n      dispatch: shouldDispatch ? () => void 0 : void 0,\n      chain: () => this.createChain(tr),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {\n          return [name, (...args) => command2(...args)(props)];\n        }));\n      }\n    };\n    return props;\n  }\n}\nclass EventEmitter {\n  constructor() {\n    this.callbacks = {};\n  }\n  on(event, fn) {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = [];\n    }\n    this.callbacks[event].push(fn);\n    return this;\n  }\n  emit(event, ...args) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      callbacks.forEach((callback) => callback.apply(this, args));\n    }\n    return this;\n  }\n  off(event, fn) {\n    const callbacks = this.callbacks[event];\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n      } else {\n        delete this.callbacks[event];\n      }\n    }\n    return this;\n  }\n  removeAllListeners() {\n    this.callbacks = {};\n  }\n}\nfunction getExtensionField(extension, field, context) {\n  if (extension.config[field] === void 0 && extension.parent) {\n    return getExtensionField(extension.parent, field, context);\n  }\n  if (typeof extension.config[field] === \"function\") {\n    const value = extension.config[field].bind(__spreadProps(__spreadValues({}, context), {\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n    }));\n    return value;\n  }\n  return extension.config[field];\n}\nfunction splitExtensions(extensions2) {\n  const baseExtensions = extensions2.filter((extension) => extension.type === \"extension\");\n  const nodeExtensions = extensions2.filter((extension) => extension.type === \"node\");\n  const markExtensions = extensions2.filter((extension) => extension.type === \"mark\");\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions\n  };\n}\nfunction getAttributesFromExtensions(extensions2) {\n  const extensionAttributes = [];\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n  const defaultAttribute = {\n    default: null,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false\n  };\n  extensions2.forEach((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addGlobalAttributes = getExtensionField(extension, \"addGlobalAttributes\", context);\n    if (!addGlobalAttributes) {\n      return;\n    }\n    const globalAttributes = addGlobalAttributes();\n    globalAttributes.forEach((globalAttribute) => {\n      globalAttribute.types.forEach((type) => {\n        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: __spreadValues(__spreadValues({}, defaultAttribute), attribute)\n          });\n        });\n      });\n    });\n  });\n  nodeAndMarkExtensions.forEach((extension) => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const addAttributes = getExtensionField(extension, \"addAttributes\", context);\n    if (!addAttributes) {\n      return;\n    }\n    const attributes = addAttributes();\n    Object.entries(attributes).forEach(([name, attribute]) => {\n      const mergedAttr = __spreadValues(__spreadValues({}, defaultAttribute), attribute);\n      if ((attribute === null || attribute === void 0 ? void 0 : attribute.isRequired) && (attribute === null || attribute === void 0 ? void 0 : attribute.default) === void 0) {\n        delete mergedAttr.default;\n      }\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr\n      });\n    });\n  });\n  return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n  if (typeof nameOrType === \"string\") {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.nodes[nameOrType];\n  }\n  return nameOrType;\n}\nfunction mergeAttributes(...objects) {\n  return objects.filter((item) => !!item).reduce((items, item) => {\n    const mergedAttributes = __spreadValues({}, items);\n    Object.entries(item).forEach(([key, value]) => {\n      const exists = mergedAttributes[key];\n      if (!exists) {\n        mergedAttributes[key] = value;\n        return;\n      }\n      if (key === \"class\") {\n        mergedAttributes[key] = [mergedAttributes[key], value].join(\" \");\n      } else if (key === \"style\") {\n        mergedAttributes[key] = [mergedAttributes[key], value].join(\"; \");\n      } else {\n        mergedAttributes[key] = value;\n      }\n    });\n    return mergedAttributes;\n  }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n  return extensionAttributes.filter((item) => item.attribute.rendered).map((item) => {\n    if (!item.attribute.renderHTML) {\n      return {\n        [item.name]: nodeOrMark.attrs[item.name]\n      };\n    }\n    return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction callOrReturn(value, context = void 0, ...props) {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props);\n    }\n    return value(...props);\n  }\n  return value;\n}\nfunction isEmptyObject(value = {}) {\n  return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value);\n  }\n  if (value === \"true\") {\n    return true;\n  }\n  if (value === \"false\") {\n    return false;\n  }\n  return value;\n}\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n  if (parseRule.style) {\n    return parseRule;\n  }\n  return __spreadProps(__spreadValues({}, parseRule), {\n    getAttrs: (node) => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n      if (oldAttributes === false) {\n        return false;\n      }\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n        if (value === null || value === void 0) {\n          return items;\n        }\n        return __spreadProps(__spreadValues({}, items), {\n          [item.name]: value\n        });\n      }, {});\n      return __spreadValues(__spreadValues({}, oldAttributes), newAttributes);\n    }\n  });\n}\nfunction cleanUpSchemaItem(data) {\n  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {\n    if (key === \"attrs\" && isEmptyObject(value)) {\n      return false;\n    }\n    return value !== null && value !== void 0;\n  }));\n}\nfunction getSchemaByResolvedExtensions(extensions2) {\n  var _a;\n  const allAttributes = getAttributesFromExtensions(extensions2);\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);\n  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, \"topNode\"))) === null || _a === void 0 ? void 0 : _a.name;\n  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {\n    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const extraNodeFields = extensions2.reduce((fields, e) => {\n      const extendNodeSchema = getExtensionField(e, \"extendNodeSchema\", context);\n      return __spreadValues(__spreadValues({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});\n    }, {});\n    const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraNodeFields), {\n      content: callOrReturn(getExtensionField(extension, \"content\", context)),\n      marks: callOrReturn(getExtensionField(extension, \"marks\", context)),\n      group: callOrReturn(getExtensionField(extension, \"group\", context)),\n      inline: callOrReturn(getExtensionField(extension, \"inline\", context)),\n      atom: callOrReturn(getExtensionField(extension, \"atom\", context)),\n      selectable: callOrReturn(getExtensionField(extension, \"selectable\", context)),\n      draggable: callOrReturn(getExtensionField(extension, \"draggable\", context)),\n      code: callOrReturn(getExtensionField(extension, \"code\", context)),\n      defining: callOrReturn(getExtensionField(extension, \"defining\", context)),\n      isolating: callOrReturn(getExtensionField(extension, \"isolating\", context)),\n      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {\n        var _a2;\n        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];\n      }))\n    }));\n    const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n    if (renderHTML) {\n      schema.toDOM = (node) => renderHTML({\n        node,\n        HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n      });\n    }\n    const renderText = getExtensionField(extension, \"renderText\", context);\n    if (renderText) {\n      schema.toText = renderText;\n    }\n    return [extension.name, schema];\n  }));\n  const marks = Object.fromEntries(markExtensions.map((extension) => {\n    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    const extraMarkFields = extensions2.reduce((fields, e) => {\n      const extendMarkSchema = getExtensionField(e, \"extendMarkSchema\", context);\n      return __spreadValues(__spreadValues({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});\n    }, {});\n    const schema = cleanUpSchemaItem(__spreadProps(__spreadValues({}, extraMarkFields), {\n      inclusive: callOrReturn(getExtensionField(extension, \"inclusive\", context)),\n      excludes: callOrReturn(getExtensionField(extension, \"excludes\", context)),\n      group: callOrReturn(getExtensionField(extension, \"group\", context)),\n      spanning: callOrReturn(getExtensionField(extension, \"spanning\", context)),\n      code: callOrReturn(getExtensionField(extension, \"code\", context)),\n      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {\n        var _a2;\n        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];\n      }))\n    }));\n    const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n    if (parseHTML) {\n      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n    }\n    const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n    if (renderHTML) {\n      schema.toDOM = (mark) => renderHTML({\n        mark,\n        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n      });\n    }\n    return [extension.name, schema];\n  }));\n  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema({\n    topNode,\n    nodes,\n    marks\n  });\n}\nfunction getSchemaTypeByName(name, schema) {\n  return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n  if (Array.isArray(enabled)) {\n    return enabled.some((enabledExtension) => {\n      const name = typeof enabledExtension === \"string\" ? enabledExtension : enabledExtension.name;\n      return name === extension.name;\n    });\n  }\n  return enabled;\n}\nconst getTextContentFromNodes = ($from, maxMatch = 500) => {\n  let textBefore = \"\";\n  const sliceEndPos = $from.parentOffset;\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    var _a, _b;\n    const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n      node,\n      pos,\n      parent,\n      index\n    })) || node.textContent || \"%leaf%\";\n    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));\n  });\n  return textBefore;\n};\nfunction isRegExp(value) {\n  return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\nclass InputRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst inputRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return find.exec(text);\n  }\n  const inputRuleMatch = find(text);\n  if (!inputRuleMatch) {\n    return null;\n  }\n  const result = [];\n  result.push(inputRuleMatch.text);\n  result.index = inputRuleMatch.index;\n  result.input = text;\n  result.data = inputRuleMatch.data;\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n    }\n    result.push(inputRuleMatch.replaceWith);\n  }\n  return result;\n};\nfunction run$1(config) {\n  var _a;\n  const { editor, from, to, text, rules, plugin } = config;\n  const { view } = editor;\n  if (view.composing) {\n    return false;\n  }\n  const $from = view.state.doc.resolve(from);\n  if ($from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))) {\n    return false;\n  }\n  let matched = false;\n  const textBefore = getTextContentFromNodes($from) + text;\n  rules.forEach((rule) => {\n    if (matched) {\n      return;\n    }\n    const match = inputRuleMatcherHandler(textBefore, rule.find);\n    if (!match) {\n      return;\n    }\n    const tr = view.state.tr;\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr\n    });\n    const range = {\n      from: from - (match[0].length - text.length),\n      to\n    };\n    const { commands: commands2, chain, can } = new CommandManager({\n      editor,\n      state\n    });\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands: commands2,\n      chain,\n      can\n    });\n    if (handler === null || !tr.steps.length) {\n      return;\n    }\n    tr.setMeta(plugin, {\n      transform: tr,\n      from,\n      to,\n      text\n    });\n    view.dispatch(tr);\n    matched = true;\n  });\n  return matched;\n}\nfunction inputRulesPlugin(props) {\n  const { editor, rules } = props;\n  const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, prev) {\n        const stored = tr.getMeta(plugin);\n        if (stored) {\n          return stored;\n        }\n        return tr.selectionSet || tr.docChanged ? null : prev;\n      }\n    },\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run$1({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin\n        });\n      },\n      handleDOMEvents: {\n        compositionend: (view) => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection;\n            if ($cursor) {\n              run$1({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: \"\",\n                rules,\n                plugin\n              });\n            }\n          });\n          return false;\n        }\n      },\n      handleKeyDown(view, event) {\n        if (event.key !== \"Enter\") {\n          return false;\n        }\n        const { $cursor } = view.state.selection;\n        if ($cursor) {\n          return run$1({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: \"\\n\",\n            rules,\n            plugin\n          });\n        }\n        return false;\n      }\n    },\n    isInputRules: true\n  });\n  return plugin;\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nclass PasteRule {\n  constructor(config) {\n    this.find = config.find;\n    this.handler = config.handler;\n  }\n}\nconst pasteRuleMatcherHandler = (text, find) => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)];\n  }\n  const matches = find(text);\n  if (!matches) {\n    return [];\n  }\n  return matches.map((pasteRuleMatch) => {\n    const result = [];\n    result.push(pasteRuleMatch.text);\n    result.index = pasteRuleMatch.index;\n    result.input = text;\n    result.data = pasteRuleMatch.data;\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n      }\n      result.push(pasteRuleMatch.replaceWith);\n    }\n    return result;\n  });\n};\nfunction run(config) {\n  const { editor, state, from, to, rule } = config;\n  const { commands: commands2, chain, can } = new CommandManager({\n    editor,\n    state\n  });\n  const handlers = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isTextblock || node.type.spec.code) {\n      return;\n    }\n    const resolvedFrom = Math.max(from, pos);\n    const resolvedTo = Math.min(to, pos + node.content.size);\n    const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, \"\\uFFFC\");\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find);\n    matches.forEach((match) => {\n      if (match.index === void 0) {\n        return;\n      }\n      const start = resolvedFrom + match.index + 1;\n      const end = start + match[0].length;\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end)\n      };\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands: commands2,\n        chain,\n        can\n      });\n      handlers.push(handler);\n    });\n  });\n  const success = handlers.every((handler) => handler !== null);\n  return success;\n}\nfunction pasteRulesPlugin(props) {\n  const { editor, rules } = props;\n  let dragSourceElement = null;\n  let isPastedFromProseMirror = false;\n  let isDroppedFromProseMirror = false;\n  const plugins = rules.map((rule) => {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n      view(view) {\n        const handleDragstart = (event) => {\n          var _a;\n          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n        };\n        window.addEventListener(\"dragstart\", handleDragstart);\n        return {\n          destroy() {\n            window.removeEventListener(\"dragstart\", handleDragstart);\n          }\n        };\n      },\n      props: {\n        handleDOMEvents: {\n          drop: (view) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n            return false;\n          },\n          paste: (view, event) => {\n            var _a;\n            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData(\"text/html\");\n            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes(\"data-pm-slice\"));\n            return false;\n          }\n        }\n      },\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0];\n        const isPaste = transaction.getMeta(\"uiEvent\") === \"paste\" && !isPastedFromProseMirror;\n        const isDrop = transaction.getMeta(\"uiEvent\") === \"drop\" && !isDroppedFromProseMirror;\n        if (!isPaste && !isDrop) {\n          return;\n        }\n        const from = oldState.doc.content.findDiffStart(state.doc.content);\n        const to = oldState.doc.content.findDiffEnd(state.doc.content);\n        if (!isNumber(from) || !to || from === to.b) {\n          return;\n        }\n        const tr = state.tr;\n        const chainableState = createChainableState({\n          state,\n          transaction: tr\n        });\n        const handler = run({\n          editor,\n          state: chainableState,\n          from: Math.max(from - 1, 0),\n          to: to.b - 1,\n          rule\n        });\n        if (!handler || !tr.steps.length) {\n          return;\n        }\n        return tr;\n      }\n    });\n  });\n  return plugins;\n}\nfunction findDuplicates(items) {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n  return [...new Set(filtered)];\n}\nclass ExtensionManager {\n  constructor(extensions2, editor) {\n    this.splittableMarks = [];\n    this.editor = editor;\n    this.extensions = ExtensionManager.resolve(extensions2);\n    this.schema = getSchemaByResolvedExtensions(this.extensions);\n    this.extensions.forEach((extension) => {\n      var _a;\n      this.editor.extensionStorage[extension.name] = extension.storage;\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      if (extension.type === \"mark\") {\n        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, \"keepOnSplit\", context))) !== null && _a !== void 0 ? _a : true;\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name);\n        }\n      }\n      const onBeforeCreate = getExtensionField(extension, \"onBeforeCreate\", context);\n      if (onBeforeCreate) {\n        this.editor.on(\"beforeCreate\", onBeforeCreate);\n      }\n      const onCreate = getExtensionField(extension, \"onCreate\", context);\n      if (onCreate) {\n        this.editor.on(\"create\", onCreate);\n      }\n      const onUpdate = getExtensionField(extension, \"onUpdate\", context);\n      if (onUpdate) {\n        this.editor.on(\"update\", onUpdate);\n      }\n      const onSelectionUpdate = getExtensionField(extension, \"onSelectionUpdate\", context);\n      if (onSelectionUpdate) {\n        this.editor.on(\"selectionUpdate\", onSelectionUpdate);\n      }\n      const onTransaction = getExtensionField(extension, \"onTransaction\", context);\n      if (onTransaction) {\n        this.editor.on(\"transaction\", onTransaction);\n      }\n      const onFocus = getExtensionField(extension, \"onFocus\", context);\n      if (onFocus) {\n        this.editor.on(\"focus\", onFocus);\n      }\n      const onBlur = getExtensionField(extension, \"onBlur\", context);\n      if (onBlur) {\n        this.editor.on(\"blur\", onBlur);\n      }\n      const onDestroy = getExtensionField(extension, \"onDestroy\", context);\n      if (onDestroy) {\n        this.editor.on(\"destroy\", onDestroy);\n      }\n    });\n  }\n  static resolve(extensions2) {\n    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions2));\n    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));\n    if (duplicatedNames.length) {\n      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(\", \")}]. This can lead to issues.`);\n    }\n    return resolvedExtensions;\n  }\n  static flatten(extensions2) {\n    return extensions2.map((extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n      };\n      const addExtensions = getExtensionField(extension, \"addExtensions\", context);\n      if (addExtensions) {\n        return [\n          extension,\n          ...this.flatten(addExtensions())\n        ];\n      }\n      return extension;\n    }).flat(10);\n  }\n  static sort(extensions2) {\n    const defaultPriority = 100;\n    return extensions2.sort((a, b) => {\n      const priorityA = getExtensionField(a, \"priority\") || defaultPriority;\n      const priorityB = getExtensionField(b, \"priority\") || defaultPriority;\n      if (priorityA > priorityB) {\n        return -1;\n      }\n      if (priorityA < priorityB) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n  get commands() {\n    return this.extensions.reduce((commands2, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const addCommands = getExtensionField(extension, \"addCommands\", context);\n      if (!addCommands) {\n        return commands2;\n      }\n      return __spreadValues(__spreadValues({}, commands2), addCommands());\n    }, {});\n  }\n  get plugins() {\n    const { editor } = this;\n    const extensions2 = ExtensionManager.sort([...this.extensions].reverse());\n    const inputRules = [];\n    const pasteRules = [];\n    const allPlugins = extensions2.map((extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema)\n      };\n      const plugins = [];\n      const addKeyboardShortcuts = getExtensionField(extension, \"addKeyboardShortcuts\", context);\n      let defaultBindings = {};\n      if (extension.type === \"mark\" && extension.config.exitable) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });\n      }\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n          return [shortcut, () => method({ editor })];\n        }));\n        defaultBindings = __spreadValues(__spreadValues({}, defaultBindings), bindings);\n      }\n      const keyMapPlugin = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);\n      plugins.push(keyMapPlugin);\n      const addInputRules = getExtensionField(extension, \"addInputRules\", context);\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        inputRules.push(...addInputRules());\n      }\n      const addPasteRules = getExtensionField(extension, \"addPasteRules\", context);\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        pasteRules.push(...addPasteRules());\n      }\n      const addProseMirrorPlugins = getExtensionField(extension, \"addProseMirrorPlugins\", context);\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins();\n        plugins.push(...proseMirrorPlugins);\n      }\n      return plugins;\n    }).flat();\n    return [\n      inputRulesPlugin({\n        editor,\n        rules: inputRules\n      }),\n      ...pasteRulesPlugin({\n        editor,\n        rules: pasteRules\n      }),\n      ...allPlugins\n    ];\n  }\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions);\n  }\n  get nodeViews() {\n    const { editor } = this;\n    const { nodeExtensions } = splitExtensions(this.extensions);\n    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, \"addNodeView\")).map((extension) => {\n      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n        type: getNodeType(extension.name, this.schema)\n      };\n      const addNodeView = getExtensionField(extension, \"addNodeView\", context);\n      if (!addNodeView) {\n        return [];\n      }\n      const nodeview = (node, view, getPos, decorations) => {\n        const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n        return addNodeView()({\n          editor,\n          node,\n          getPos,\n          decorations,\n          HTMLAttributes,\n          extension\n        });\n      };\n      return [extension.name, nodeview];\n    }));\n  }\n}\nfunction getType(value) {\n  return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n  if (getType(value) !== \"Object\") {\n    return false;\n  }\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n  const output = __spreadValues({}, target);\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isPlainObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] });\n        } else {\n          output[key] = mergeDeep(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\nclass Extension {\n  constructor(config = {}) {\n    this.type = \"extension\";\n    this.name = \"extension\";\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = __spreadValues(__spreadValues({}, this.config), config);\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create(config = {}) {\n    return new Extension(config);\n  }\n  configure(options = {}) {\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new Extension(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nfunction getTextBetween(startNode, range, options) {\n  const { from, to } = range;\n  const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n  let text = \"\";\n  let separated = true;\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    var _a;\n    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n    if (textSerializer) {\n      if (node.isBlock && !separated) {\n        text += blockSeparator;\n        separated = true;\n      }\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range\n        });\n      }\n    } else if (node.isText) {\n      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos);\n      separated = false;\n    } else if (node.isBlock && !separated) {\n      text += blockSeparator;\n      separated = true;\n    }\n  });\n  return text;\n}\nfunction getTextSerializersFromSchema(schema) {\n  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText]));\n}\nconst ClipboardTextSerializer = Extension.create({\n  name: \"clipboardTextSerializer\",\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"clipboardTextSerializer\"),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this;\n            const { state, schema } = editor;\n            const { doc, selection } = state;\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map((range2) => range2.$from.pos));\n            const to = Math.max(...ranges.map((range2) => range2.$to.pos));\n            const textSerializers = getTextSerializersFromSchema(schema);\n            const range = { from, to };\n            return getTextBetween(doc, range, {\n              textSerializers\n            });\n          }\n        }\n      })\n    ];\n  }\n});\nconst blur = () => ({ editor, view }) => {\n  requestAnimationFrame(() => {\n    var _a;\n    if (!editor.isDestroyed) {\n      view.dom.blur();\n      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n    }\n  });\n  return true;\n};\nconst clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {\n  return commands2.setContent(\"\", emitUpdate);\n};\nconst clearNodes = () => ({ state, tr, dispatch }) => {\n  const { selection } = tr;\n  const { ranges } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  ranges.forEach(({ $from, $to }) => {\n    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n      if (node.type.isText) {\n        return;\n      }\n      const { doc, mapping } = tr;\n      const $mappedFrom = doc.resolve(mapping.map(pos));\n      const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n      const nodeRange = $mappedFrom.blockRange($mappedTo);\n      if (!nodeRange) {\n        return;\n      }\n      const targetLiftDepth = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.liftTarget)(nodeRange);\n      if (node.type.isTextblock) {\n        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n        tr.setNodeMarkup(nodeRange.start, defaultType);\n      }\n      if (targetLiftDepth || targetLiftDepth === 0) {\n        tr.lift(nodeRange, targetLiftDepth);\n      }\n    });\n  });\n  return true;\n};\nconst command = (fn) => (props) => {\n  return fn(props);\n};\nconst createParagraphNear = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.createParagraphNear)(state, dispatch);\n};\nconst deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const $pos = tr.selection.$anchor;\n  for (let depth = $pos.depth; depth > 0; depth -= 1) {\n    const node = $pos.node(depth);\n    if (node.type === type) {\n      if (dispatch) {\n        const from = $pos.before(depth);\n        const to = $pos.after(depth);\n        tr.delete(from, to).scrollIntoView();\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst deleteRange = (range) => ({ tr, dispatch }) => {\n  const { from, to } = range;\n  if (dispatch) {\n    tr.delete(from, to);\n  }\n  return true;\n};\nconst deleteSelection = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.deleteSelection)(state, dispatch);\n};\nconst enter = () => ({ commands: commands2 }) => {\n  return commands2.keyboardShortcut(\"Enter\");\n};\nconst exitCode = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.exitCode)(state, dispatch);\n};\nfunction objectIncludes(object1, object2, options = { strict: true }) {\n  const keys = Object.keys(object2);\n  if (!keys.length) {\n    return true;\n  }\n  return keys.every((key) => {\n    if (options.strict) {\n      return object2[key] === object1[key];\n    }\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key]);\n    }\n    return object2[key] === object1[key];\n  });\n}\nfunction findMarkInSet(marks, type, attributes = {}) {\n  return marks.find((item) => {\n    return item.type === type && objectIncludes(item.attrs, attributes);\n  });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n  return !!findMarkInSet(marks, type, attributes);\n}\nfunction getMarkRange($pos, type, attributes = {}) {\n  if (!$pos || !type) {\n    return;\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset);\n  if ($pos.parentOffset === start.offset && start.offset !== 0) {\n    start = $pos.parent.childBefore($pos.parentOffset);\n  }\n  if (!start.node) {\n    return;\n  }\n  const mark = findMarkInSet([...start.node.marks], type, attributes);\n  if (!mark) {\n    return;\n  }\n  let startIndex = start.index;\n  let startPos = $pos.start() + start.offset;\n  let endIndex = startIndex + 1;\n  let endPos = startPos + start.node.nodeSize;\n  findMarkInSet([...start.node.marks], type, attributes);\n  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {\n    startIndex -= 1;\n    startPos -= $pos.parent.child(startIndex).nodeSize;\n  }\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize;\n    endIndex += 1;\n  }\n  return {\n    from: startPos,\n    to: endPos\n  };\n}\nfunction getMarkType(nameOrType, schema) {\n  if (typeof nameOrType === \"string\") {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n    }\n    return schema.marks[nameOrType];\n  }\n  return nameOrType;\n}\nconst extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const type = getMarkType(typeOrName, state.schema);\n  const { doc, selection } = tr;\n  const { $from, from, to } = selection;\n  if (dispatch) {\n    const range = getMarkRange($from, type, attributes);\n    if (range && range.from <= from && range.to >= to) {\n      const newSelection = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, range.from, range.to);\n      tr.setSelection(newSelection);\n    }\n  }\n  return true;\n};\nconst first = (commands2) => (props) => {\n  const items = typeof commands2 === \"function\" ? commands2(props) : commands2;\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true;\n    }\n  }\n  return false;\n};\nfunction isTextSelection(value) {\n  return value instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection;\n}\nfunction minMax(value = 0, min = 0, max = 0) {\n  return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc, position = null) {\n  if (!position) {\n    return null;\n  }\n  const selectionAtStart = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.atStart(doc);\n  const selectionAtEnd = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.atEnd(doc);\n  if (position === \"start\" || position === true) {\n    return selectionAtStart;\n  }\n  if (position === \"end\") {\n    return selectionAtEnd;\n  }\n  const minPos = selectionAtStart.from;\n  const maxPos = selectionAtEnd.to;\n  if (position === \"all\") {\n    return prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n  }\n  return prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isiOS() {\n  return [\n    \"iPad Simulator\",\n    \"iPhone Simulator\",\n    \"iPod Simulator\",\n    \"iPad\",\n    \"iPhone\",\n    \"iPod\"\n  ].includes(navigator.platform) || navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\nconst focus = (position = null, options = {}) => ({ editor, view, tr, dispatch }) => {\n  options = __spreadValues({\n    scrollIntoView: true\n  }, options);\n  const delayedFocus = () => {\n    if (isiOS()) {\n      view.dom.focus();\n    }\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        view.focus();\n        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n          editor.commands.scrollIntoView();\n        }\n      }\n    });\n  };\n  if (view.hasFocus() && position === null || position === false) {\n    return true;\n  }\n  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n    delayedFocus();\n    return true;\n  }\n  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n  const isSameSelection = editor.state.selection.eq(selection);\n  if (dispatch) {\n    if (!isSameSelection) {\n      tr.setSelection(selection);\n    }\n    if (isSameSelection && tr.storedMarks) {\n      tr.setStoredMarks(tr.storedMarks);\n    }\n    delayedFocus();\n  }\n  return true;\n};\nconst forEach = (items, fn) => (props) => {\n  return items.every((item, index) => fn(item, __spreadProps(__spreadValues({}, props), { index })));\n};\nconst insertContent = (value, options) => ({ tr, commands: commands2 }) => {\n  return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\n};\nfunction elementFromString(value) {\n  const wrappedValue = `<body>${value}</body>`;\n  return new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n}\nfunction createNodeFromContent(content, schema, options) {\n  options = __spreadValues({\n    slice: true,\n    parseOptions: {}\n  }, options);\n  if (typeof content === \"object\" && content !== null) {\n    try {\n      if (Array.isArray(content)) {\n        return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));\n      }\n      return schema.nodeFromJSON(content);\n    } catch (error) {\n      console.warn(\"[tiptap warn]: Invalid content.\", \"Passed value:\", content, \"Error:\", error);\n      return createNodeFromContent(\"\", schema, options);\n    }\n  }\n  if (typeof content === \"string\") {\n    const parser = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(schema);\n    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);\n  }\n  return createNodeFromContent(\"\", schema, options);\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  const last = tr.steps.length - 1;\n  if (last < startLen) {\n    return;\n  }\n  const step = tr.steps[last];\n  if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.ReplaceAroundStep)) {\n    return;\n  }\n  const map = tr.mapping.maps[last];\n  let end = 0;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo;\n    }\n  });\n  tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = (nodeOrFragment) => {\n  return nodeOrFragment.toString().startsWith(\"<\");\n};\nconst insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\n  if (dispatch) {\n    options = __spreadValues({\n      parseOptions: {},\n      updateSelection: true\n    }, options);\n    const content = createNodeFromContent(value, editor.schema, {\n      parseOptions: __spreadValues({\n        preserveWhitespace: \"full\"\n      }, options.parseOptions)\n    });\n    if (content.toString() === \"<>\") {\n      return true;\n    }\n    let { from, to } = typeof position === \"number\" ? { from: position, to: position } : position;\n    let isOnlyTextContent = true;\n    let isOnlyBlockContent = true;\n    const nodes = isFragment(content) ? content : [content];\n    nodes.forEach((node) => {\n      node.check();\n      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n    });\n    if (from === to && isOnlyBlockContent) {\n      const { parent } = tr.doc.resolve(from);\n      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n      if (isEmptyTextBlock) {\n        from -= 1;\n        to += 1;\n      }\n    }\n    if (isOnlyTextContent) {\n      tr.insertText(value, from, to);\n    } else {\n      tr.replaceWith(from, to, content);\n    }\n    if (options.updateSelection) {\n      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n    }\n  }\n  return true;\n};\nconst joinBackward = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.joinBackward)(state, dispatch);\n};\nconst joinForward = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.joinForward)(state, dispatch);\n};\nfunction isMacOS() {\n  return typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n  const parts = name.split(/-(?!$)/);\n  let result = parts[parts.length - 1];\n  if (result === \"Space\") {\n    result = \" \";\n  }\n  let alt;\n  let ctrl;\n  let shift;\n  let meta;\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true;\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true;\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true;\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true;\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true;\n      } else {\n        ctrl = true;\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`);\n    }\n  }\n  if (alt) {\n    result = `Alt-${result}`;\n  }\n  if (ctrl) {\n    result = `Ctrl-${result}`;\n  }\n  if (meta) {\n    result = `Meta-${result}`;\n  }\n  if (shift) {\n    result = `Shift-${result}`;\n  }\n  return result;\n}\nconst keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {\n  const keys = normalizeKeyName(name).split(/-(?!$)/);\n  const key = keys.find((item) => ![\"Alt\", \"Ctrl\", \"Meta\", \"Shift\"].includes(item));\n  const event = new KeyboardEvent(\"keydown\", {\n    key: key === \"Space\" ? \" \" : key,\n    altKey: keys.includes(\"Alt\"),\n    ctrlKey: keys.includes(\"Ctrl\"),\n    metaKey: keys.includes(\"Meta\"),\n    shiftKey: keys.includes(\"Shift\"),\n    bubbles: true,\n    cancelable: true\n  });\n  const capturedTransaction = editor.captureTransaction(() => {\n    view.someProp(\"handleKeyDown\", (f) => f(view, event));\n  });\n  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {\n    const newStep = step.map(tr.mapping);\n    if (newStep && dispatch) {\n      tr.maybeStep(newStep);\n    }\n  });\n  return true;\n};\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n  const { from, to, empty } = state.selection;\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n  const nodeRanges = [];\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return;\n    }\n    const relativeFrom = Math.max(from, pos);\n    const relativeTo = Math.min(to, pos + node.nodeSize);\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo\n    });\n  });\n  const selectionRange = to - from;\n  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {\n    if (!type) {\n      return true;\n    }\n    return type.name === nodeRange.node.type.name;\n  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\n  if (empty) {\n    return !!matchedNodeRanges.length;\n  }\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n  return range >= selectionRange;\n}\nconst lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (!isActive2) {\n    return false;\n  }\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.lift)(state, dispatch);\n};\nconst liftEmptyBlock = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.liftEmptyBlock)(state, dispatch);\n};\nconst liftListItem = (typeOrName) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_5__.liftListItem)(type)(state, dispatch);\n};\nconst newlineInCode = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.newlineInCode)(state, dispatch);\n};\nfunction getSchemaTypeNameByName(name, schema) {\n  if (schema.nodes[name]) {\n    return \"node\";\n  }\n  if (schema.marks[name]) {\n    return \"mark\";\n  }\n  return null;\n}\nfunction deleteProps(obj, propOrProps) {\n  const props = typeof propOrProps === \"string\" ? [propOrProps] : propOrProps;\n  return Object.keys(obj).reduce((newObj, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop];\n    }\n    return newObj;\n  }, {});\n}\nconst resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === \"node\") {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === \"mark\") {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach((range) => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach((mark) => {\n            if (markType === mark.type) {\n              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\nconst scrollIntoView = () => ({ tr, dispatch }) => {\n  if (dispatch) {\n    tr.scrollIntoView();\n  }\n  return true;\n};\nconst selectAll = () => ({ tr, commands: commands2 }) => {\n  return commands2.setTextSelection({\n    from: 0,\n    to: tr.doc.content.size\n  });\n};\nconst selectNodeBackward = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.selectNodeBackward)(state, dispatch);\n};\nconst selectNodeForward = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.selectNodeForward)(state, dispatch);\n};\nconst selectParentNode = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.selectParentNode)(state, dispatch);\n};\nconst selectTextblockEnd = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.selectTextblockEnd)(state, dispatch);\n};\nconst selectTextblockStart = () => ({ state, dispatch }) => {\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.selectTextblockStart)(state, dispatch);\n};\nfunction createDocument(content, schema, parseOptions = {}) {\n  return createNodeFromContent(content, schema, { slice: false, parseOptions });\n}\nconst setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {\n  const { doc } = tr;\n  const document2 = createDocument(content, editor.schema, parseOptions);\n  if (dispatch) {\n    tr.replaceWith(0, doc.content.size, document2).setMeta(\"preventUpdate\", !emitUpdate);\n  }\n  return true;\n};\nfunction combineTransactionSteps(oldDoc, transactions) {\n  const transform = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.Transform(oldDoc);\n  transactions.forEach((transaction) => {\n    transaction.steps.forEach((step) => {\n      transform.step(step);\n    });\n  });\n  return transform;\n}\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type;\n    }\n  }\n  return null;\n}\nfunction findChildren(node, predicate) {\n  const nodesWithPos = [];\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\nfunction findChildrenInRange(node, range, predicate) {\n  const nodesWithPos = [];\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos\n      });\n    }\n  });\n  return nodesWithPos;\n}\nfunction findParentNodeClosestToPos($pos, predicate) {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n}\nfunction findParentNode(predicate) {\n  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getHTMLFromFragment(fragment, schema) {\n  const documentFragment = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n  const temporaryDocument = document.implementation.createHTMLDocument();\n  const container = temporaryDocument.createElement(\"div\");\n  container.appendChild(documentFragment);\n  return container.innerHTML;\n}\nfunction getSchema(extensions2) {\n  const resolvedExtensions = ExtensionManager.resolve(extensions2);\n  return getSchemaByResolvedExtensions(resolvedExtensions);\n}\nfunction generateHTML(doc, extensions2) {\n  const schema = getSchema(extensions2);\n  const contentNode = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(schema, doc);\n  return getHTMLFromFragment(contentNode.content, schema);\n}\nfunction generateJSON(html, extensions2) {\n  const schema = getSchema(extensions2);\n  const dom = elementFromString(html);\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\nfunction getText(node, options) {\n  const range = {\n    from: 0,\n    to: node.content.size\n  };\n  return getTextBetween(node, range, options);\n}\nfunction generateText(doc, extensions2, options) {\n  const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n  const schema = getSchema(extensions2);\n  const contentNode = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(schema, doc);\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: __spreadValues(__spreadValues({}, textSerializers), getTextSerializersFromSchema(schema))\n  });\n}\nfunction getMarkAttributes(state, typeOrName) {\n  const type = getMarkType(typeOrName, state.schema);\n  const { from, to, empty } = state.selection;\n  const marks = [];\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks);\n    }\n    marks.push(...state.selection.$head.marks());\n  } else {\n    state.doc.nodesBetween(from, to, (node) => {\n      marks.push(...node.marks);\n    });\n  }\n  const mark = marks.find((markItem) => markItem.type.name === type.name);\n  if (!mark) {\n    return {};\n  }\n  return __spreadValues({}, mark.attrs);\n}\nfunction getNodeAttributes(state, typeOrName) {\n  const type = getNodeType(typeOrName, state.schema);\n  const { from, to } = state.selection;\n  const nodes = [];\n  state.doc.nodesBetween(from, to, (node2) => {\n    nodes.push(node2);\n  });\n  const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);\n  if (!node) {\n    return {};\n  }\n  return __spreadValues({}, node.attrs);\n}\nfunction getAttributes(state, typeOrName) {\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n  if (schemaType === \"node\") {\n    return getNodeAttributes(state, typeOrName);\n  }\n  if (schemaType === \"mark\") {\n    return getMarkAttributes(state, typeOrName);\n  }\n  return {};\n}\nfunction removeDuplicates(array, by = JSON.stringify) {\n  const seen = {};\n  return array.filter((item) => {\n    const key = by(item);\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n  });\n}\nfunction simplifyChangedRanges(changes) {\n  const uniqueChanges = removeDuplicates(changes);\n  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {\n    const rest = uniqueChanges.filter((_, i) => i !== index);\n    return !rest.some((otherChange) => {\n      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n    });\n  });\n}\nfunction getChangedRanges(transform) {\n  const { mapping, steps } = transform;\n  const changes = [];\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges = [];\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index];\n      if (from === void 0 || to === void 0) {\n        return;\n      }\n      ranges.push({ from, to });\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to });\n      });\n    }\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1);\n      const newEnd = mapping.slice(index).map(to);\n      const oldStart = mapping.invert().map(newStart, -1);\n      const oldEnd = mapping.invert().map(newEnd);\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd\n        }\n      });\n    });\n  });\n  return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node, startOffset = 0) {\n  const isTopNode = node.type === node.type.schema.topNodeType;\n  const increment = isTopNode ? 0 : 1;\n  const from = startOffset;\n  const to = from + node.nodeSize;\n  const marks = node.marks.map((mark) => {\n    const output2 = {\n      type: mark.type.name\n    };\n    if (Object.keys(mark.attrs).length) {\n      output2.attrs = __spreadValues({}, mark.attrs);\n    }\n    return output2;\n  });\n  const attrs = __spreadValues({}, node.attrs);\n  const output = {\n    type: node.type.name,\n    from,\n    to\n  };\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs;\n  }\n  if (marks.length) {\n    output.marks = marks;\n  }\n  if (node.content.childCount) {\n    output.content = [];\n    node.forEach((child, offset) => {\n      var _a;\n      (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n    });\n  }\n  if (node.text) {\n    output.text = node.text;\n  }\n  return output;\n}\nfunction getMarksBetween(from, to, doc) {\n  const marks = [];\n  if (from === to) {\n    doc.resolve(from).marks().forEach((mark) => {\n      const $pos = doc.resolve(from - 1);\n      const range = getMarkRange($pos, mark.type);\n      if (!range) {\n        return;\n      }\n      marks.push(__spreadValues({\n        mark\n      }, range));\n    });\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      marks.push(...node.marks.map((mark) => ({\n        from: pos,\n        to: pos + node.nodeSize,\n        mark\n      })));\n    });\n  }\n  return marks;\n}\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n  const { empty, ranges } = state.selection;\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {\n      if (!type) {\n        return true;\n      }\n      return type.name === mark.type.name;\n    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));\n  }\n  let selectionRange = 0;\n  const markRanges = [];\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos;\n    const to = $to.pos;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return;\n      }\n      const relativeFrom = Math.max(from, pos);\n      const relativeTo = Math.min(to, pos + node.nodeSize);\n      const range2 = relativeTo - relativeFrom;\n      selectionRange += range2;\n      markRanges.push(...node.marks.map((mark) => ({\n        mark,\n        from: relativeFrom,\n        to: relativeTo\n      })));\n    });\n  });\n  if (selectionRange === 0) {\n    return false;\n  }\n  const matchedRange = markRanges.filter((markRange) => {\n    if (!type) {\n      return true;\n    }\n    return type.name === markRange.mark.type.name;\n  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  const excludedRange = markRanges.filter((markRange) => {\n    if (!type) {\n      return true;\n    }\n    return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n  return range >= selectionRange;\n}\nfunction isActive(state, name, attributes = {}) {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n  }\n  const schemaType = getSchemaTypeNameByName(name, state.schema);\n  if (schemaType === \"node\") {\n    return isNodeActive(state, name, attributes);\n  }\n  if (schemaType === \"mark\") {\n    return isMarkActive(state, name, attributes);\n  }\n  return false;\n}\nfunction isList(name, extensions2) {\n  const { nodeExtensions } = splitExtensions(extensions2);\n  const extension = nodeExtensions.find((item) => item.name === name);\n  if (!extension) {\n    return false;\n  }\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage\n  };\n  const group = callOrReturn(getExtensionField(extension, \"group\", context));\n  if (typeof group !== \"string\") {\n    return false;\n  }\n  return group.split(\" \").includes(\"list\");\n}\nfunction isNodeEmpty(node) {\n  var _a;\n  const defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();\n  const content = node.toJSON();\n  return JSON.stringify(defaultContent) === JSON.stringify(content);\n}\nfunction isNodeSelection(value) {\n  return value instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n  const minPos = 0;\n  const maxPos = view.state.doc.content.size;\n  const resolvedFrom = minMax(from, minPos, maxPos);\n  const resolvedEnd = minMax(to, minPos, maxPos);\n  const start = view.coordsAtPos(resolvedFrom);\n  const end = view.coordsAtPos(resolvedEnd, -1);\n  const top = Math.min(start.top, end.top);\n  const bottom = Math.max(start.bottom, end.bottom);\n  const left = Math.min(start.left, end.left);\n  const right = Math.max(start.right, end.right);\n  const width = right - left;\n  const height = bottom - top;\n  const x = left;\n  const y = top;\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y\n  };\n  return __spreadProps(__spreadValues({}, data), {\n    toJSON: () => data\n  });\n}\nfunction canSetMark(state, tr, newMarkType) {\n  var _a;\n  const { selection } = tr;\n  let cursor = null;\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor;\n  }\n  if (cursor) {\n    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));\n  }\n  const { ranges } = selection;\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      if (someNodeSupportsMark) {\n        return false;\n      }\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n      }\n      return !someNodeSupportsMark;\n    });\n    return someNodeSupportsMark;\n  });\n}\nconst setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  const { selection } = tr;\n  const { empty, ranges } = selection;\n  const type = getMarkType(typeOrName, state.schema);\n  if (dispatch) {\n    if (empty) {\n      const oldAttributes = getMarkAttributes(state, type);\n      tr.addStoredMark(type.create(__spreadValues(__spreadValues({}, oldAttributes), attributes)));\n    } else {\n      ranges.forEach((range) => {\n        const from = range.$from.pos;\n        const to = range.$to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n          const trimmedFrom = Math.max(pos, from);\n          const trimmedTo = Math.min(pos + node.nodeSize, to);\n          const someHasMark = node.marks.find((mark) => mark.type === type);\n          if (someHasMark) {\n            node.marks.forEach((mark) => {\n              if (type === mark.type) {\n                tr.addMark(trimmedFrom, trimmedTo, type.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));\n              }\n            });\n          } else {\n            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n          }\n        });\n      });\n    }\n  }\n  return canSetMark(state, tr, type);\n};\nconst setMeta = (key, value) => ({ tr }) => {\n  tr.setMeta(key, value);\n  return true;\n};\nconst setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  if (!type.isTextblock) {\n    console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n    return false;\n  }\n  return chain().command(({ commands: commands2 }) => {\n    const canSetBlock = (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.setBlockType)(type, attributes)(state);\n    if (canSetBlock) {\n      return true;\n    }\n    return commands2.clearNodes();\n  }).command(({ state: updatedState }) => {\n    return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.setBlockType)(type, attributes)(updatedState, dispatch);\n  }).run();\n};\nconst setNodeSelection = (position) => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr;\n    const from = minMax(position, 0, doc.content.size);\n    const selection = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, from);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst setTextSelection = (position) => ({ tr, dispatch }) => {\n  if (dispatch) {\n    const { doc } = tr;\n    const { from, to } = typeof position === \"number\" ? { from: position, to: position } : position;\n    const minPos = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.atStart(doc).from;\n    const maxPos = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.atEnd(doc).to;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const selection = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n    tr.setSelection(selection);\n  }\n  return true;\n};\nconst sinkListItem = (typeOrName) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_5__.sinkListItem)(type)(state, dispatch);\n};\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {\n    const extensionAttribute = extensionAttributes.find((item) => {\n      return item.type === typeName && item.name === name;\n    });\n    if (!extensionAttribute) {\n      return false;\n    }\n    return extensionAttribute.attribute.keepOnSplit;\n  }));\n}\nfunction ensureMarks(state, splittableMarks) {\n  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n  if (marks) {\n    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n    state.tr.ensureMarks(filteredMarks);\n  }\n}\nconst splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {\n  const { selection, doc } = tr;\n  const { $from, $to } = selection;\n  const extensionAttributes = editor.extensionManager.attributes;\n  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.node.isBlock) {\n    if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.canSplit)(doc, $from.pos)) {\n      return false;\n    }\n    if (dispatch) {\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks);\n      }\n      tr.split($from.pos).scrollIntoView();\n    }\n    return true;\n  }\n  if (!$from.parent.isBlock) {\n    return false;\n  }\n  if (dispatch) {\n    const atEnd = $to.parentOffset === $to.parent.content.size;\n    if (selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n      tr.deleteSelection();\n    }\n    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    let types = atEnd && deflt ? [{\n      type: deflt,\n      attrs: newAttributes\n    }] : void 0;\n    let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n    if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {\n      can = true;\n      types = deflt ? [{\n        type: deflt,\n        attrs: newAttributes\n      }] : void 0;\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n        const first2 = tr.mapping.map($from.before());\n        const $first = tr.doc.resolve(first2);\n        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n        }\n      }\n    }\n    if (keepMarks) {\n      ensureMarks(state, editor.extensionManager.splittableMarks);\n    }\n    tr.scrollIntoView();\n  }\n  return true;\n};\nconst splitListItem = (typeOrName) => ({ tr, state, dispatch, editor }) => {\n  var _a;\n  const type = getNodeType(typeOrName, state.schema);\n  const { $from, $to } = state.selection;\n  const node = state.selection.node;\n  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n    return false;\n  }\n  const grandParent = $from.node(-1);\n  if (grandParent.type !== type) {\n    return false;\n  }\n  const extensionAttributes = editor.extensionManager.attributes;\n  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n      return false;\n    }\n    if (dispatch) {\n      let wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n        wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(wrap));\n      }\n      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;\n      wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.createAndFill(null, nextType2) || void 0));\n      const start = $from.before($from.depth - (depthBefore - 1));\n      tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(wrap, 4 - depthBefore, 0));\n      let sel = -1;\n      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n        if (sel > -1) {\n          return false;\n        }\n        if (n.isTextblock && n.content.size === 0) {\n          sel = pos + 1;\n        }\n      });\n      if (sel > -1) {\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.near(tr.doc.resolve(sel)));\n      }\n      tr.scrollIntoView();\n    }\n    return true;\n  }\n  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);\n  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n  tr.delete($from.pos, $to.pos);\n  const types = nextType ? [{ type, attrs: newTypeAttributes }, { type: nextType, attrs: newNextTypeAttributes }] : [{ type, attrs: newTypeAttributes }];\n  if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.canSplit)(tr.doc, $from.pos, 2)) {\n    return false;\n  }\n  if (dispatch) {\n    tr.split($from.pos, 2, types).scrollIntoView();\n  }\n  return true;\n};\nconst joinListBackwards = (tr, listType) => {\n  const list = findParentNode((node) => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n  if (before === void 0) {\n    return true;\n  }\n  const nodeBefore = tr.doc.nodeAt(before);\n  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.canJoin)(tr.doc, list.pos);\n  if (!canJoinBackwards) {\n    return true;\n  }\n  tr.join(list.pos);\n  return true;\n};\nconst joinListForwards = (tr, listType) => {\n  const list = findParentNode((node) => node.type === listType)(tr.selection);\n  if (!list) {\n    return true;\n  }\n  const after = tr.doc.resolve(list.start).after(list.depth);\n  if (after === void 0) {\n    return true;\n  }\n  const nodeAfter = tr.doc.nodeAt(after);\n  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.canJoin)(tr.doc, after);\n  if (!canJoinForwards) {\n    return true;\n  }\n  tr.join(after);\n  return true;\n};\nconst toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch, chain, commands: commands2, can }) => {\n  const { extensions: extensions2 } = editor.extensionManager;\n  const listType = getNodeType(listTypeOrName, state.schema);\n  const itemType = getNodeType(itemTypeOrName, state.schema);\n  const { selection } = state;\n  const { $from, $to } = selection;\n  const range = $from.blockRange($to);\n  if (!range) {\n    return false;\n  }\n  const parentList = findParentNode((node) => isList(node.type.name, extensions2))(selection);\n  if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n    if (parentList.node.type === listType) {\n      return commands2.liftListItem(itemType);\n    }\n    if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {\n      return chain().command(() => {\n        tr.setNodeMarkup(parentList.pos, listType);\n        return true;\n      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n    }\n  }\n  return chain().command(() => {\n    const canWrapInList = can().wrapInList(listType);\n    if (canWrapInList) {\n      return true;\n    }\n    return commands2.clearNodes();\n  }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();\n};\nconst toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {\n  const { extendEmptyMarkRange = false } = options;\n  const type = getMarkType(typeOrName, state.schema);\n  const isActive2 = isMarkActive(state, type, attributes);\n  if (isActive2) {\n    return commands2.unsetMark(type, { extendEmptyMarkRange });\n  }\n  return commands2.setMark(type, attributes);\n};\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const toggleType = getNodeType(toggleTypeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (isActive2) {\n    return commands2.setNode(toggleType);\n  }\n  return commands2.setNode(type, attributes);\n};\nconst toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  const isActive2 = isNodeActive(state, type, attributes);\n  if (isActive2) {\n    return commands2.lift(type);\n  }\n  return commands2.wrapIn(type, attributes);\n};\nconst undoInputRule = () => ({ state, dispatch }) => {\n  const plugins = state.plugins;\n  for (let i = 0; i < plugins.length; i += 1) {\n    const plugin = plugins[i];\n    let undoable;\n    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n      if (dispatch) {\n        const tr = state.tr;\n        const toUndo = undoable.transform;\n        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n        }\n        if (undoable.text) {\n          const marks = tr.doc.resolve(undoable.from).marks();\n          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n        } else {\n          tr.delete(undoable.from, undoable.to);\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n};\nconst unsetAllMarks = () => ({ tr, dispatch }) => {\n  const { selection } = tr;\n  const { empty, ranges } = selection;\n  if (empty) {\n    return true;\n  }\n  if (dispatch) {\n    ranges.forEach((range) => {\n      tr.removeMark(range.$from.pos, range.$to.pos);\n    });\n  }\n  return true;\n};\nconst unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n  var _a;\n  const { extendEmptyMarkRange = false } = options;\n  const { selection } = tr;\n  const type = getMarkType(typeOrName, state.schema);\n  const { $from, empty, ranges } = selection;\n  if (!dispatch) {\n    return true;\n  }\n  if (empty && extendEmptyMarkRange) {\n    let { from, to } = selection;\n    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n    const range = getMarkRange($from, type, attrs);\n    if (range) {\n      from = range.from;\n      to = range.to;\n    }\n    tr.removeMark(from, to, type);\n  } else {\n    ranges.forEach((range) => {\n      tr.removeMark(range.$from.pos, range.$to.pos, type);\n    });\n  }\n  tr.removeStoredMark(type);\n  return true;\n};\nconst updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n  let nodeType = null;\n  let markType = null;\n  const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n  if (!schemaType) {\n    return false;\n  }\n  if (schemaType === \"node\") {\n    nodeType = getNodeType(typeOrName, state.schema);\n  }\n  if (schemaType === \"mark\") {\n    markType = getMarkType(typeOrName, state.schema);\n  }\n  if (dispatch) {\n    tr.selection.ranges.forEach((range) => {\n      const from = range.$from.pos;\n      const to = range.$to.pos;\n      state.doc.nodesBetween(from, to, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          tr.setNodeMarkup(pos, void 0, __spreadValues(__spreadValues({}, node.attrs), attributes));\n        }\n        if (markType && node.marks.length) {\n          node.marks.forEach((mark) => {\n            if (markType === mark.type) {\n              const trimmedFrom = Math.max(pos, from);\n              const trimmedTo = Math.min(pos + node.nodeSize, to);\n              tr.addMark(trimmedFrom, trimmedTo, markType.create(__spreadValues(__spreadValues({}, mark.attrs), attributes)));\n            }\n          });\n        }\n      });\n    });\n  }\n  return true;\n};\nconst wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,prosemirror_commands__WEBPACK_IMPORTED_MODULE_4__.wrapIn)(type, attributes)(state, dispatch);\n};\nconst wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n  const type = getNodeType(typeOrName, state.schema);\n  return (0,prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_5__.wrapInList)(type, attributes)(state, dispatch);\n};\nvar commands = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  blur,\n  clearContent,\n  clearNodes,\n  command,\n  createParagraphNear,\n  deleteNode,\n  deleteRange,\n  deleteSelection,\n  enter,\n  exitCode,\n  extendMarkRange,\n  first,\n  focus,\n  forEach,\n  insertContent,\n  insertContentAt,\n  joinBackward,\n  joinForward,\n  keyboardShortcut,\n  lift,\n  liftEmptyBlock,\n  liftListItem,\n  newlineInCode,\n  resetAttributes,\n  scrollIntoView,\n  selectAll,\n  selectNodeBackward,\n  selectNodeForward,\n  selectParentNode,\n  selectTextblockEnd,\n  selectTextblockStart,\n  setContent,\n  setMark,\n  setMeta,\n  setNode,\n  setNodeSelection,\n  setTextSelection,\n  sinkListItem,\n  splitBlock,\n  splitListItem,\n  toggleList,\n  toggleMark,\n  toggleNode,\n  toggleWrap,\n  undoInputRule,\n  unsetAllMarks,\n  unsetMark,\n  updateAttributes,\n  wrapIn,\n  wrapInList\n});\nconst Commands = Extension.create({\n  name: \"commands\",\n  addCommands() {\n    return __spreadValues({}, commands);\n  }\n});\nconst Editable = Extension.create({\n  name: \"editable\",\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"editable\"),\n        props: {\n          editable: () => this.editor.options.editable\n        }\n      })\n    ];\n  }\n});\nconst FocusEvents = Extension.create({\n  name: \"focusEvents\",\n  addProseMirrorPlugins() {\n    const { editor } = this;\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"focusEvents\"),\n        props: {\n          handleDOMEvents: {\n            focus: (view, event) => {\n              editor.isFocused = true;\n              const transaction = editor.state.tr.setMeta(\"focus\", { event }).setMeta(\"addToHistory\", false);\n              view.dispatch(transaction);\n              return false;\n            },\n            blur: (view, event) => {\n              editor.isFocused = false;\n              const transaction = editor.state.tr.setMeta(\"blur\", { event }).setMeta(\"addToHistory\", false);\n              view.dispatch(transaction);\n              return false;\n            }\n          }\n        }\n      })\n    ];\n  }\n});\nconst Keymap = Extension.create({\n  name: \"keymap\",\n  addKeyboardShortcuts() {\n    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [\n      () => commands2.undoInputRule(),\n      () => commands2.command(({ tr }) => {\n        const { selection, doc } = tr;\n        const { empty, $anchor } = selection;\n        const { pos, parent } = $anchor;\n        const isAtStart = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.atStart(doc).from === pos;\n        if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {\n          return false;\n        }\n        return commands2.clearNodes();\n      }),\n      () => commands2.deleteSelection(),\n      () => commands2.joinBackward(),\n      () => commands2.selectNodeBackward()\n    ]);\n    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [\n      () => commands2.deleteSelection(),\n      () => commands2.joinForward(),\n      () => commands2.selectNodeForward()\n    ]);\n    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [\n      () => commands2.newlineInCode(),\n      () => commands2.createParagraphNear(),\n      () => commands2.liftEmptyBlock(),\n      () => commands2.splitBlock()\n    ]);\n    const baseKeymap = {\n      Enter: handleEnter,\n      \"Mod-Enter\": () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      \"Mod-Backspace\": handleBackspace,\n      \"Shift-Backspace\": handleBackspace,\n      Delete: handleDelete,\n      \"Mod-Delete\": handleDelete,\n      \"Mod-a\": () => this.editor.commands.selectAll()\n    };\n    const pcKeymap = __spreadValues({}, baseKeymap);\n    const macKeymap = __spreadProps(__spreadValues({}, baseKeymap), {\n      \"Ctrl-h\": handleBackspace,\n      \"Alt-Backspace\": handleBackspace,\n      \"Ctrl-d\": handleDelete,\n      \"Ctrl-Alt-Backspace\": handleDelete,\n      \"Alt-Delete\": handleDelete,\n      \"Alt-d\": handleDelete,\n      \"Ctrl-a\": () => this.editor.commands.selectTextblockStart(),\n      \"Ctrl-e\": () => this.editor.commands.selectTextblockEnd()\n    });\n    if (isiOS() || isMacOS()) {\n      return macKeymap;\n    }\n    return pcKeymap;\n  },\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"clearDocument\"),\n        appendTransaction: (transactions, oldState, newState) => {\n          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n          if (!docChanges) {\n            return;\n          }\n          const { empty, from, to } = oldState.selection;\n          const allFrom = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.atStart(oldState.doc).from;\n          const allEnd = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.atEnd(oldState.doc).to;\n          const allWasSelected = from === allFrom && to === allEnd;\n          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, \" \", \" \").length === 0;\n          if (empty || !allWasSelected || !isEmpty) {\n            return;\n          }\n          const tr = newState.tr;\n          const state = createChainableState({\n            state: newState,\n            transaction: tr\n          });\n          const { commands: commands2 } = new CommandManager({\n            editor: this.editor,\n            state\n          });\n          commands2.clearNodes();\n          if (!tr.steps.length) {\n            return;\n          }\n          return tr;\n        }\n      })\n    ];\n  }\n});\nconst Tabindex = Extension.create({\n  name: \"tabindex\",\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"tabindex\"),\n        props: {\n          attributes: this.editor.isEditable ? { tabindex: \"0\" } : {}\n        }\n      })\n    ];\n  }\n});\nvar extensions = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer,\n  Commands,\n  Editable,\n  FocusEvents,\n  Keymap,\n  Tabindex\n});\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\nfunction createStyleTag(style2, nonce) {\n  const tipTapStyleTag = document.querySelector(\"style[data-tiptap-style]\");\n  if (tipTapStyleTag !== null) {\n    return tipTapStyleTag;\n  }\n  const styleNode = document.createElement(\"style\");\n  if (nonce) {\n    styleNode.setAttribute(\"nonce\", nonce);\n  }\n  styleNode.setAttribute(\"data-tiptap-style\", \"\");\n  styleNode.innerHTML = style2;\n  document.getElementsByTagName(\"head\")[0].appendChild(styleNode);\n  return styleNode;\n}\nclass Editor extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.isFocused = false;\n    this.extensionStorage = {};\n    this.options = {\n      element: document.createElement(\"div\"),\n      content: \"\",\n      injectCSS: true,\n      injectNonce: void 0,\n      extensions: [],\n      autofocus: false,\n      editable: true,\n      editorProps: {},\n      parseOptions: {},\n      enableInputRules: true,\n      enablePasteRules: true,\n      enableCoreExtensions: true,\n      onBeforeCreate: () => null,\n      onCreate: () => null,\n      onUpdate: () => null,\n      onSelectionUpdate: () => null,\n      onTransaction: () => null,\n      onFocus: () => null,\n      onBlur: () => null,\n      onDestroy: () => null\n    };\n    this.isCapturingTransaction = false;\n    this.capturedTransaction = null;\n    this.setOptions(options);\n    this.createExtensionManager();\n    this.createCommandManager();\n    this.createSchema();\n    this.on(\"beforeCreate\", this.options.onBeforeCreate);\n    this.emit(\"beforeCreate\", { editor: this });\n    this.createView();\n    this.injectCSS();\n    this.on(\"create\", this.options.onCreate);\n    this.on(\"update\", this.options.onUpdate);\n    this.on(\"selectionUpdate\", this.options.onSelectionUpdate);\n    this.on(\"transaction\", this.options.onTransaction);\n    this.on(\"focus\", this.options.onFocus);\n    this.on(\"blur\", this.options.onBlur);\n    this.on(\"destroy\", this.options.onDestroy);\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return;\n      }\n      this.commands.focus(this.options.autofocus);\n      this.emit(\"create\", { editor: this });\n    }, 0);\n  }\n  get storage() {\n    return this.extensionStorage;\n  }\n  get commands() {\n    return this.commandManager.commands;\n  }\n  chain() {\n    return this.commandManager.chain();\n  }\n  can() {\n    return this.commandManager.can();\n  }\n  injectCSS() {\n    if (this.options.injectCSS && document) {\n      this.css = createStyleTag(style, this.options.injectNonce);\n    }\n  }\n  setOptions(options = {}) {\n    this.options = __spreadValues(__spreadValues({}, this.options), options);\n    if (!this.view || !this.state || this.isDestroyed) {\n      return;\n    }\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps);\n    }\n    this.view.updateState(this.state);\n  }\n  setEditable(editable) {\n    this.setOptions({ editable });\n    this.emit(\"update\", { editor: this, transaction: this.state.tr });\n  }\n  get isEditable() {\n    return this.options.editable && this.view && this.view.editable;\n  }\n  get state() {\n    return this.view.state;\n  }\n  registerPlugin(plugin, handlePlugins) {\n    const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];\n    const state = this.state.reconfigure({ plugins });\n    this.view.updateState(state);\n  }\n  unregisterPlugin(nameOrPluginKey) {\n    if (this.isDestroyed) {\n      return;\n    }\n    const name = typeof nameOrPluginKey === \"string\" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n    const state = this.state.reconfigure({\n      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))\n    });\n    this.view.updateState(state);\n  }\n  createExtensionManager() {\n    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {\n      return [\"extension\", \"node\", \"mark\"].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n    });\n    this.extensionManager = new ExtensionManager(allExtensions, this);\n  }\n  createCommandManager() {\n    this.commandManager = new CommandManager({\n      editor: this\n    });\n  }\n  createSchema() {\n    this.schema = this.extensionManager.schema;\n  }\n  createView() {\n    const doc = createDocument(this.options.content, this.schema, this.options.parseOptions);\n    const selection = resolveFocusPosition(doc, this.options.autofocus);\n    this.view = new prosemirror_view__WEBPACK_IMPORTED_MODULE_6__.EditorView(this.options.element, __spreadProps(__spreadValues({}, this.options.editorProps), {\n      dispatchTransaction: this.dispatchTransaction.bind(this),\n      state: prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({\n        doc,\n        selection: selection || void 0\n      })\n    }));\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins\n    });\n    this.view.updateState(newState);\n    this.createNodeViews();\n    const dom = this.view.dom;\n    dom.editor = this;\n  }\n  createNodeViews() {\n    this.view.setProps({\n      nodeViews: this.extensionManager.nodeViews\n    });\n  }\n  captureTransaction(fn) {\n    this.isCapturingTransaction = true;\n    fn();\n    this.isCapturingTransaction = false;\n    const tr = this.capturedTransaction;\n    this.capturedTransaction = null;\n    return tr;\n  }\n  dispatchTransaction(transaction) {\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction;\n        return;\n      }\n      transaction.steps.forEach((step) => {\n        var _a;\n        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n      });\n      return;\n    }\n    const state = this.state.apply(transaction);\n    const selectionHasChanged = !this.state.selection.eq(state.selection);\n    this.view.updateState(state);\n    this.emit(\"transaction\", {\n      editor: this,\n      transaction\n    });\n    if (selectionHasChanged) {\n      this.emit(\"selectionUpdate\", {\n        editor: this,\n        transaction\n      });\n    }\n    const focus2 = transaction.getMeta(\"focus\");\n    const blur2 = transaction.getMeta(\"blur\");\n    if (focus2) {\n      this.emit(\"focus\", {\n        editor: this,\n        event: focus2.event,\n        transaction\n      });\n    }\n    if (blur2) {\n      this.emit(\"blur\", {\n        editor: this,\n        event: blur2.event,\n        transaction\n      });\n    }\n    if (!transaction.docChanged || transaction.getMeta(\"preventUpdate\")) {\n      return;\n    }\n    this.emit(\"update\", {\n      editor: this,\n      transaction\n    });\n  }\n  getAttributes(nameOrType) {\n    return getAttributes(this.state, nameOrType);\n  }\n  isActive(nameOrAttributes, attributesOrUndefined) {\n    const name = typeof nameOrAttributes === \"string\" ? nameOrAttributes : null;\n    const attributes = typeof nameOrAttributes === \"string\" ? attributesOrUndefined : nameOrAttributes;\n    return isActive(this.state, name, attributes);\n  }\n  getJSON() {\n    return this.state.doc.toJSON();\n  }\n  getHTML() {\n    return getHTMLFromFragment(this.state.doc.content, this.schema);\n  }\n  getText(options) {\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: __spreadValues(__spreadValues({}, textSerializers), getTextSerializersFromSchema(this.schema))\n    });\n  }\n  get isEmpty() {\n    return isNodeEmpty(this.state.doc);\n  }\n  getCharacterCount() {\n    console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n    return this.state.doc.content.size - 2;\n  }\n  destroy() {\n    this.emit(\"destroy\");\n    if (this.view) {\n      this.view.destroy();\n    }\n    this.removeAllListeners();\n  }\n  get isDestroyed() {\n    var _a;\n    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n  }\n}\nfunction markInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const { tr } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {\n          const excluded = item.mark.type.excluded;\n          return excluded.find((type) => type === config.type && type !== item.mark.type);\n        }).filter((item) => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\nfunction nodeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      const { tr } = state;\n      const start = range.from;\n      let end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        let matchStart = start + offset;\n        if (matchStart > end) {\n          matchStart = end;\n        } else {\n          end = matchStart + match[1].length;\n        }\n        const lastChar = match[0][match[0].length - 1];\n        tr.insertText(lastChar, start + match[0].length - 1);\n        tr.replaceWith(matchStart, end, config.type.create(attributes));\n      } else if (match[0]) {\n        tr.replaceWith(start, end, config.type.create(attributes));\n      }\n    }\n  });\n}\nfunction textblockTypeInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from);\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null;\n      }\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n    }\n  });\n}\nfunction textInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\nfunction wrappingInputRule(config) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};\n      const tr = state.tr.delete(range.from, range.to);\n      const $start = tr.doc.resolve(range.from);\n      const blockRange = $start.blockRange();\n      const wrapping = blockRange && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.findWrapping)(blockRange, config.type, attributes);\n      if (!wrapping) {\n        return null;\n      }\n      tr.wrap(blockRange, wrapping);\n      const before = tr.doc.resolve(range.from - 1).nodeBefore;\n      if (before && before.type === config.type && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_3__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n        tr.join(range.from - 1);\n      }\n    }\n  });\n}\nclass Mark {\n  constructor(config = {}) {\n    this.type = \"mark\";\n    this.name = \"mark\";\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = __spreadValues(__spreadValues({}, this.config), config);\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create(config = {}) {\n    return new Mark(config);\n  }\n  configure(options = {}) {\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new Mark(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  static handleExit({ editor, mark }) {\n    const { tr } = editor.state;\n    const currentPos = editor.state.selection.$from;\n    const isAtEnd = currentPos.pos === currentPos.end();\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks();\n      const isInMark = !!currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (!isInMark) {\n        return false;\n      }\n      const removeMark = currentMarks.find((m) => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n      if (removeMark) {\n        tr.removeStoredMark(removeMark);\n      }\n      tr.insertText(\" \", currentPos.pos);\n      editor.view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n}\nclass Node {\n  constructor(config = {}) {\n    this.type = \"node\";\n    this.name = \"node\";\n    this.parent = null;\n    this.child = null;\n    this.config = {\n      name: this.name,\n      defaultOptions: {}\n    };\n    this.config = __spreadValues(__spreadValues({}, this.config), config);\n    this.name = this.config.name;\n    if (config.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n    }\n    this.options = this.config.defaultOptions;\n    if (this.config.addOptions) {\n      this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n        name: this.name\n      }));\n    }\n    this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n      name: this.name,\n      options: this.options\n    })) || {};\n  }\n  static create(config = {}) {\n    return new Node(config);\n  }\n  configure(options = {}) {\n    const extension = this.extend();\n    extension.options = mergeDeep(this.options, options);\n    extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n  extend(extendedConfig = {}) {\n    const extension = new Node(extendedConfig);\n    extension.parent = this;\n    this.child = extension;\n    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n    if (extendedConfig.defaultOptions) {\n      console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n    }\n    extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n      name: extension.name\n    }));\n    extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n      name: extension.name,\n      options: extension.options\n    }));\n    return extension;\n  }\n}\nclass NodeView {\n  constructor(component, props, options) {\n    this.isDragging = false;\n    this.component = component;\n    this.editor = props.editor;\n    this.options = __spreadValues({\n      stopEvent: null,\n      ignoreMutation: null\n    }, options);\n    this.extension = props.extension;\n    this.node = props.node;\n    this.decorations = props.decorations;\n    this.getPos = props.getPos;\n    this.mount();\n  }\n  mount() {\n    return;\n  }\n  get dom() {\n    return this.editor.view.dom;\n  }\n  get contentDOM() {\n    return null;\n  }\n  onDragStart(event) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const { view } = this.editor;\n    const target = event.target;\n    const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest(\"[data-drag-handle]\") : target.closest(\"[data-drag-handle]\");\n    if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect();\n      const handleBox = dragHandle.getBoundingClientRect();\n      const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n      const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n      x = handleBox.x - domBox.x + offsetX;\n      y = handleBox.y - domBox.y + offsetY;\n    }\n    (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);\n    const selection = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, this.getPos());\n    const transaction = view.state.tr.setSelection(selection);\n    view.dispatch(transaction);\n  }\n  stopEvent(event) {\n    var _a;\n    if (!this.dom) {\n      return false;\n    }\n    if (typeof this.options.stopEvent === \"function\") {\n      return this.options.stopEvent({ event });\n    }\n    const target = event.target;\n    const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n    if (!isInElement) {\n      return false;\n    }\n    const isDropEvent = event.type === \"drop\";\n    const isInput = [\"INPUT\", \"BUTTON\", \"SELECT\", \"TEXTAREA\"].includes(target.tagName) || target.isContentEditable;\n    if (isInput && !isDropEvent) {\n      return true;\n    }\n    const { isEditable } = this.editor;\n    const { isDragging } = this;\n    const isDraggable = !!this.node.type.spec.draggable;\n    const isSelectable = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(this.node);\n    const isCopyEvent = event.type === \"copy\";\n    const isPasteEvent = event.type === \"paste\";\n    const isCutEvent = event.type === \"cut\";\n    const isClickEvent = event.type === \"mousedown\";\n    const isDragEvent = event.type.startsWith(\"drag\");\n    if (!isDraggable && isSelectable && isDragEvent) {\n      event.preventDefault();\n    }\n    if (isDraggable && isDragEvent && !isDragging) {\n      event.preventDefault();\n      return false;\n    }\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest(\"[data-drag-handle]\");\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n      if (isValidDragHandle) {\n        this.isDragging = true;\n        document.addEventListener(\"dragend\", () => {\n          this.isDragging = false;\n        }, { once: true });\n        document.addEventListener(\"mouseup\", () => {\n          this.isDragging = false;\n        }, { once: true });\n      }\n    }\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n      return false;\n    }\n    return true;\n  }\n  ignoreMutation(mutation) {\n    if (!this.dom || !this.contentDOM) {\n      return true;\n    }\n    if (typeof this.options.ignoreMutation === \"function\") {\n      return this.options.ignoreMutation({ mutation });\n    }\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true;\n    }\n    if (mutation.type === \"selection\") {\n      return false;\n    }\n    if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && isiOS() && this.editor.isFocused) {\n      const changedNodes = [\n        ...Array.from(mutation.addedNodes),\n        ...Array.from(mutation.removedNodes)\n      ];\n      if (changedNodes.every((node) => node.isContentEditable)) {\n        return false;\n      }\n    }\n    if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n      return true;\n    }\n    if (this.contentDOM.contains(mutation.target)) {\n      return false;\n    }\n    return true;\n  }\n  updateAttributes(attributes) {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos();\n      tr.setNodeMarkup(pos, void 0, __spreadValues(__spreadValues({}, this.node.attrs), attributes));\n      return true;\n    });\n  }\n  deleteNode() {\n    const from = this.getPos();\n    const to = from + this.node.nodeSize;\n    this.editor.commands.deleteRange({ from, to });\n  }\n}\nfunction markPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, void 0, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      const { tr } = state;\n      const captureGroup = match[match.length - 1];\n      const fullMatch = match[0];\n      let markEnd = range.to;\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/);\n        const textStart = range.from + fullMatch.indexOf(captureGroup);\n        const textEnd = textStart + captureGroup.length;\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item) => {\n          const excluded = item.mark.type.excluded;\n          return excluded.find((type) => type === config.type && type !== item.mark.type);\n        }).filter((item) => item.to > textStart);\n        if (excludedMarks.length) {\n          return null;\n        }\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to);\n        }\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart);\n        }\n        markEnd = range.from + startSpaces + captureGroup.length;\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n        tr.removeStoredMark(config.type);\n      }\n    }\n  });\n}\nfunction escapeForRegEx(string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction nodePasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range }) {\n      const attributes = callOrReturn(config.getAttributes, void 0, match);\n      if (attributes === false || attributes === null) {\n        return null;\n      }\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, {\n          type: config.type.name,\n          attrs: attributes\n        });\n      }\n    }\n  });\n}\nfunction textPasteRule(config) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace;\n      let start = range.from;\n      const end = range.to;\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1]);\n        insert += match[0].slice(offset + match[1].length);\n        start += offset;\n        const cutOff = start - end;\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert;\n          start = end;\n        }\n      }\n      state.tr.insertText(insert, start, end);\n    }\n  });\n}\nclass Tracker {\n  constructor(transaction) {\n    this.transaction = transaction;\n    this.currentStep = this.transaction.steps.length;\n  }\n  map(position) {\n    let deleted = false;\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition);\n      if (mapResult.deleted) {\n        deleted = true;\n      }\n      return mapResult.pos;\n    }, position);\n    return {\n      position: mappedPosition,\n      deleted\n    };\n  }\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/core/dist/tiptap-core.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-blockquote/dist/tiptap-extension-blockquote.esm.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/tiptap-extension-blockquote.esm.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Blockquote\": () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ Blockquote),\n/* harmony export */   \"inputRegex\": () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst inputRegex = /^\\s*>\\s$/;\nconst Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"blockquote\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  content: \"block+\",\n  group: \"block\",\n  defining: true,\n  parseHTML() {\n    return [\n      { tag: \"blockquote\" }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"blockquote\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setBlockquote: () => ({ commands }) => {\n        return commands.wrapIn(this.name);\n      },\n      toggleBlockquote: () => ({ commands }) => {\n        return commands.toggleWrap(this.name);\n      },\n      unsetBlockquote: () => ({ commands }) => {\n        return commands.lift(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-b\": () => this.editor.commands.toggleBlockquote()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-blockquote/dist/tiptap-extension-blockquote.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-bold/dist/tiptap-extension-bold.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/tiptap-extension-bold.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bold\": () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ Bold),\n/* harmony export */   \"starInputRegex\": () => (/* binding */ starInputRegex),\n/* harmony export */   \"starPasteRegex\": () => (/* binding */ starPasteRegex),\n/* harmony export */   \"underscoreInputRegex\": () => (/* binding */ underscoreInputRegex),\n/* harmony export */   \"underscorePasteRegex\": () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst starInputRegex = /(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))$/;\nconst starPasteRegex = /(?:^|\\s)((?:\\*\\*)((?:[^*]+))(?:\\*\\*))/g;\nconst underscoreInputRegex = /(?:^|\\s)((?:__)((?:[^__]+))(?:__))$/;\nconst underscorePasteRegex = /(?:^|\\s)((?:__)((?:[^__]+))(?:__))/g;\nconst Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"bold\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"strong\"\n      },\n      {\n        tag: \"b\",\n        getAttrs: (node) => node.style.fontWeight !== \"normal\" && null\n      },\n      {\n        style: \"font-weight\",\n        getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"strong\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setBold: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleBold: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetBold: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-b\": () => this.editor.commands.toggleBold(),\n      \"Mod-B\": () => this.editor.commands.toggleBold()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: starInputRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: underscoreInputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: starPasteRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: underscorePasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-bold/dist/tiptap-extension-bold.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-bullet-list/dist/tiptap-extension-bullet-list.esm.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bullet-list/dist/tiptap-extension-bullet-list.esm.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BulletList\": () => (/* binding */ BulletList),\n/* harmony export */   \"default\": () => (/* binding */ BulletList),\n/* harmony export */   \"inputRegex\": () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst inputRegex = /^\\s*([-+*])\\s$/;\nconst BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"bulletList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  parseHTML() {\n    return [\n      { tag: \"ul\" }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"ul\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      toggleBulletList: () => ({ commands }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-8\": () => this.editor.commands.toggleBulletList()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-bullet-list/dist/tiptap-extension-bullet-list.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-code-block/dist/tiptap-extension-code-block.esm.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/tiptap-extension-code-block.esm.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CodeBlock\": () => (/* binding */ CodeBlock),\n/* harmony export */   \"backtickInputRegex\": () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ CodeBlock),\n/* harmony export */   \"tildeInputRegex\": () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\nconst backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\nconst tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\nconst CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"codeBlock\",\n  addOptions() {\n    return {\n      languageClassPrefix: \"language-\",\n      exitOnTripleEnter: true,\n      exitOnArrowDown: true,\n      HTMLAttributes: {}\n    };\n  },\n  content: \"text*\",\n  marks: \"\",\n  group: \"block\",\n  code: true,\n  defining: true,\n  addAttributes() {\n    return {\n      language: {\n        default: null,\n        parseHTML: (element) => {\n          var _a;\n          const { languageClassPrefix } = this.options;\n          const classNames = [...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []];\n          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, \"\"));\n          const language = languages[0];\n          if (!language) {\n            return null;\n          }\n          return language;\n        },\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"pre\",\n        preserveWhitespace: \"full\"\n      }\n    ];\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    return [\n      \"pre\",\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n      [\n        \"code\",\n        {\n          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n        },\n        0\n      ]\n    ];\n  },\n  addCommands() {\n    return {\n      setCodeBlock: (attributes) => ({ commands }) => {\n        return commands.setNode(this.name, attributes);\n      },\n      toggleCodeBlock: (attributes) => ({ commands }) => {\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-c\": () => this.editor.commands.toggleCodeBlock(),\n      Backspace: () => {\n        const { empty, $anchor } = this.editor.state.selection;\n        const isAtStart = $anchor.pos === 1;\n        if (!empty || $anchor.parent.type.name !== this.name) {\n          return false;\n        }\n        if (isAtStart || !$anchor.parent.textContent.length) {\n          return this.editor.commands.clearNodes();\n        }\n        return false;\n      },\n      Enter: ({ editor }) => {\n        if (!this.options.exitOnTripleEnter) {\n          return false;\n        }\n        const { state } = editor;\n        const { selection } = state;\n        const { $from, empty } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n        if (!isAtEnd || !endsWithDoubleNewline) {\n          return false;\n        }\n        return editor.chain().command(({ tr }) => {\n          tr.delete($from.pos - 2, $from.pos);\n          return true;\n        }).exitCode().run();\n      },\n      ArrowDown: ({ editor }) => {\n        if (!this.options.exitOnArrowDown) {\n          return false;\n        }\n        const { state } = editor;\n        const { selection, doc } = state;\n        const { $from, empty } = selection;\n        if (!empty || $from.parent.type !== this.type) {\n          return false;\n        }\n        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n        if (!isAtEnd) {\n          return false;\n        }\n        const after = $from.after();\n        if (after === void 0) {\n          return false;\n        }\n        const nodeAfter = doc.nodeAt(after);\n        if (nodeAfter) {\n          return false;\n        }\n        return editor.commands.exitCode();\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n        find: backtickInputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          language: match[1]\n        })\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n        find: tildeInputRegex,\n        type: this.type,\n        getAttributes: (match) => ({\n          language: match[1]\n        })\n      })\n    ];\n  },\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey(\"codeBlockVSCodeHandler\"),\n        props: {\n          handlePaste: (view, event) => {\n            if (!event.clipboardData) {\n              return false;\n            }\n            if (this.editor.isActive(this.type.name)) {\n              return false;\n            }\n            const text = event.clipboardData.getData(\"text/plain\");\n            const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n            const vscodeData = vscode ? JSON.parse(vscode) : void 0;\n            const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\n            if (!text || !language) {\n              return false;\n            }\n            const { tr } = view.state;\n            tr.replaceSelectionWith(this.type.create({ language }));\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n            tr.insertText(text.replace(/\\r\\n?/g, \"\\n\"));\n            tr.setMeta(\"paste\", true);\n            view.dispatch(tr);\n            return true;\n          }\n        }\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-code-block/dist/tiptap-extension-code-block.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-code/dist/tiptap-extension-code.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/tiptap-extension-code.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Code\": () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ Code),\n/* harmony export */   \"inputRegex\": () => (/* binding */ inputRegex),\n/* harmony export */   \"pasteRegex\": () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst inputRegex = /(?:^|\\s)((?:`)((?:[^`]+))(?:`))$/;\nconst pasteRegex = /(?:^|\\s)((?:`)((?:[^`]+))(?:`))/g;\nconst Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"code\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  excludes: \"_\",\n  code: true,\n  exitable: true,\n  parseHTML() {\n    return [\n      { tag: \"code\" }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"code\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setCode: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleCode: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetCode: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-e\": () => this.editor.commands.toggleCode()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: pasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-code/dist/tiptap-extension-code.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-document/dist/tiptap-extension-document.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/tiptap-extension-document.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Document\": () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ Document)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"doc\",\n  topNode: true,\n  content: \"block+\"\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-document/dist/tiptap-extension-document.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-dropcursor/dist/tiptap-extension-dropcursor.esm.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-dropcursor/dist/tiptap-extension-dropcursor.esm.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dropcursor\": () => (/* binding */ Dropcursor),\n/* harmony export */   \"default\": () => (/* binding */ Dropcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-dropcursor */ \"./node_modules/prosemirror-dropcursor/dist/index.js\");\n\n\nconst Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"dropCursor\",\n  addOptions() {\n    return {\n      color: \"currentColor\",\n      width: 1,\n      class: void 0\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      (0,prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_1__.dropCursor)(this.options)\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-dropcursor/dist/tiptap-extension-dropcursor.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-gapcursor/dist/tiptap-extension-gapcursor.esm.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-gapcursor/dist/tiptap-extension-gapcursor.esm.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Gapcursor\": () => (/* binding */ Gapcursor),\n/* harmony export */   \"default\": () => (/* binding */ Gapcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-gapcursor */ \"./node_modules/prosemirror-gapcursor/dist/index.js\");\n\n\nconst Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"gapCursor\",\n  addProseMirrorPlugins() {\n    return [\n      (0,prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_1__.gapCursor)()\n    ];\n  },\n  extendNodeSchema(extension) {\n    var _a;\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage\n    };\n    return {\n      allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getExtensionField)(extension, \"allowGapCursor\", context))) !== null && _a !== void 0 ? _a : null\n    };\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-gapcursor/dist/tiptap-extension-gapcursor.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-hard-break/dist/tiptap-extension-hard-break.esm.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/tiptap-extension-hard-break.esm.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HardBreak\": () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ HardBreak)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"hardBreak\",\n  addOptions() {\n    return {\n      keepMarks: true,\n      HTMLAttributes: {}\n    };\n  },\n  inline: true,\n  group: \"inline\",\n  selectable: false,\n  parseHTML() {\n    return [\n      { tag: \"br\" }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"br\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  renderText() {\n    return \"\\n\";\n  },\n  addCommands() {\n    return {\n      setHardBreak: () => ({ commands, chain, state, editor }) => {\n        return commands.first([\n          () => commands.exitCode(),\n          () => commands.command(() => {\n            const { selection, storedMarks } = state;\n            if (selection.$from.parent.type.spec.isolating) {\n              return false;\n            }\n            const { keepMarks } = this.options;\n            const { splittableMarks } = editor.extensionManager;\n            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n            return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {\n              if (dispatch && marks && keepMarks) {\n                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));\n                tr.ensureMarks(filteredMarks);\n              }\n              return true;\n            }).run();\n          })\n        ]);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Enter\": () => this.editor.commands.setHardBreak(),\n      \"Shift-Enter\": () => this.editor.commands.setHardBreak()\n    };\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-hard-break/dist/tiptap-extension-hard-break.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-heading/dist/tiptap-extension-heading.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/tiptap-extension-heading.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Heading\": () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ Heading)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\n\nconst Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"heading\",\n  addOptions() {\n    return {\n      levels: [1, 2, 3, 4, 5, 6],\n      HTMLAttributes: {}\n    };\n  },\n  content: \"inline*\",\n  group: \"block\",\n  defining: true,\n  addAttributes() {\n    return {\n      level: {\n        default: 1,\n        rendered: false\n      }\n    };\n  },\n  parseHTML() {\n    return this.options.levels.map((level) => ({\n      tag: `h${level}`,\n      attrs: { level }\n    }));\n  },\n  renderHTML({ node, HTMLAttributes }) {\n    const hasLevel = this.options.levels.includes(node.attrs.level);\n    const level = hasLevel ? node.attrs.level : this.options.levels[0];\n    return [`h${level}`, (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setHeading: (attributes) => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false;\n        }\n        return commands.setNode(this.name, attributes);\n      },\n      toggleHeading: (attributes) => ({ commands }) => {\n        if (!this.options.levels.includes(attributes.level)) {\n          return false;\n        }\n        return commands.toggleNode(this.name, \"paragraph\", attributes);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return this.options.levels.reduce((items, level) => __spreadValues(__spreadValues({}, items), {\n      [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })\n    }), {});\n  },\n  addInputRules() {\n    return this.options.levels.map((level) => {\n      return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n        find: new RegExp(`^(#{1,${level}})\\\\s$`),\n        type: this.type,\n        getAttributes: {\n          level\n        }\n      });\n    });\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-heading/dist/tiptap-extension-heading.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-history/dist/tiptap-extension-history.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-history/dist/tiptap-extension-history.esm.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"History\": () => (/* binding */ History),\n/* harmony export */   \"default\": () => (/* binding */ History)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-history */ \"./node_modules/prosemirror-history/dist/index.js\");\n\n\nconst History = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"history\",\n  addOptions() {\n    return {\n      depth: 100,\n      newGroupDelay: 500\n    };\n  },\n  addCommands() {\n    return {\n      undo: () => ({ state, dispatch }) => {\n        return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.undo)(state, dispatch);\n      },\n      redo: () => ({ state, dispatch }) => {\n        return (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.redo)(state, dispatch);\n      }\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      (0,prosemirror_history__WEBPACK_IMPORTED_MODULE_1__.history)(this.options)\n    ];\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-z\": () => this.editor.commands.undo(),\n      \"Mod-y\": () => this.editor.commands.redo(),\n      \"Shift-Mod-z\": () => this.editor.commands.redo(),\n      \"Mod-\\u044F\": () => this.editor.commands.undo(),\n      \"Shift-Mod-\\u044F\": () => this.editor.commands.redo()\n    };\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-history/dist/tiptap-extension-history.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-horizontal-rule/dist/tiptap-extension-horizontal-rule.esm.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/tiptap-extension-horizontal-rule.esm.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HorizontalRule\": () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ HorizontalRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\nconst HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"horizontalRule\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block\",\n  parseHTML() {\n    return [\n      { tag: \"hr\" }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"hr\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setHorizontalRule: () => ({ chain }) => {\n        return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {\n          var _a;\n          if (dispatch) {\n            const { $to } = tr.selection;\n            const posAfter = $to.end();\n            if ($to.nodeAfter) {\n              tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, $to.pos));\n            } else {\n              const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n              if (node) {\n                tr.insert(posAfter, node);\n                tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, posAfter));\n              }\n            }\n            tr.scrollIntoView();\n          }\n          return true;\n        }).run();\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.nodeInputRule)({\n        find: /^(?:---|-|___\\s|\\*\\*\\*\\s)$/,\n        type: this.type\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-horizontal-rule/dist/tiptap-extension-horizontal-rule.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-image/dist/tiptap-extension-image.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-image/dist/tiptap-extension-image.esm.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Image\": () => (/* binding */ Image),\n/* harmony export */   \"default\": () => (/* binding */ Image),\n/* harmony export */   \"inputRegex\": () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst inputRegex = /(?:^|\\s)(!\\[(.+|:?)]\\((\\S+)(?:(?:\\s+)[\"'](\\S+)[\"'])?\\))$/;\nconst Image = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"image\",\n  addOptions() {\n    return {\n      inline: false,\n      allowBase64: false,\n      HTMLAttributes: {}\n    };\n  },\n  inline() {\n    return this.options.inline;\n  },\n  group() {\n    return this.options.inline ? \"inline\" : \"block\";\n  },\n  draggable: true,\n  addAttributes() {\n    return {\n      src: {\n        default: null\n      },\n      alt: {\n        default: null\n      },\n      title: {\n        default: null\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: this.options.allowBase64 ? \"img[src]\" : 'img[src]:not([src^=\"data:\"])'\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"img\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n  },\n  addCommands() {\n    return {\n      setImage: (options) => ({ commands }) => {\n        return commands.insertContent({\n          type: this.name,\n          attrs: options\n        });\n      }\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.nodeInputRule)({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: (match) => {\n          const [, , alt, src, title] = match;\n          return { src, alt, title };\n        }\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-image/dist/tiptap-extension-image.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-italic/dist/tiptap-extension-italic.esm.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/tiptap-extension-italic.esm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Italic\": () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ Italic),\n/* harmony export */   \"starInputRegex\": () => (/* binding */ starInputRegex),\n/* harmony export */   \"starPasteRegex\": () => (/* binding */ starPasteRegex),\n/* harmony export */   \"underscoreInputRegex\": () => (/* binding */ underscoreInputRegex),\n/* harmony export */   \"underscorePasteRegex\": () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst starInputRegex = /(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))$/;\nconst starPasteRegex = /(?:^|\\s)((?:\\*)((?:[^*]+))(?:\\*))/g;\nconst underscoreInputRegex = /(?:^|\\s)((?:_)((?:[^_]+))(?:_))$/;\nconst underscorePasteRegex = /(?:^|\\s)((?:_)((?:[^_]+))(?:_))/g;\nconst Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"italic\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"em\"\n      },\n      {\n        tag: \"i\",\n        getAttrs: (node) => node.style.fontStyle !== \"normal\" && null\n      },\n      {\n        style: \"font-style=italic\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"em\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setItalic: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleItalic: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetItalic: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-i\": () => this.editor.commands.toggleItalic(),\n      \"Mod-I\": () => this.editor.commands.toggleItalic()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: starInputRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: underscoreInputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: starPasteRegex,\n        type: this.type\n      }),\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: underscorePasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-italic/dist/tiptap-extension-italic.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-list-item/dist/tiptap-extension-list-item.esm.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-list-item/dist/tiptap-extension-list-item.esm.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ListItem\": () => (/* binding */ ListItem),\n/* harmony export */   \"default\": () => (/* binding */ ListItem)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"listItem\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  content: \"paragraph block*\",\n  defining: true,\n  parseHTML() {\n    return [\n      {\n        tag: \"li\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"li\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addKeyboardShortcuts() {\n    return {\n      Enter: () => this.editor.commands.splitListItem(this.name),\n      Tab: () => this.editor.commands.sinkListItem(this.name),\n      \"Shift-Tab\": () => this.editor.commands.liftListItem(this.name)\n    };\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-list-item/dist/tiptap-extension-list-item.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-ordered-list/dist/tiptap-extension-ordered-list.esm.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-ordered-list/dist/tiptap-extension-ordered-list.esm.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OrderedList\": () => (/* binding */ OrderedList),\n/* harmony export */   \"default\": () => (/* binding */ OrderedList),\n/* harmony export */   \"inputRegex\": () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\nconst inputRegex = /^(\\d+)\\.\\s$/;\nconst OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"orderedList\",\n  addOptions() {\n    return {\n      itemTypeName: \"listItem\",\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block list\",\n  content() {\n    return `${this.options.itemTypeName}+`;\n  },\n  addAttributes() {\n    return {\n      start: {\n        default: 1,\n        parseHTML: (element) => {\n          return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n        }\n      }\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"ol\"\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    const _a = HTMLAttributes, { start } = _a, attributesWithoutStart = __objRest(_a, [\"start\"]);\n    return start === 1 ? [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0] : [\"ol\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      toggleOrderedList: () => ({ commands }) => {\n        return commands.toggleList(this.name, this.options.itemTypeName);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-7\": () => this.editor.commands.toggleOrderedList()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n        find: inputRegex,\n        type: this.type,\n        getAttributes: (match) => ({ start: +match[1] }),\n        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-ordered-list/dist/tiptap-extension-ordered-list.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-paragraph/dist/tiptap-extension-paragraph.esm.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/tiptap-extension-paragraph.esm.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Paragraph\": () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ Paragraph)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"paragraph\",\n  priority: 1e3,\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  group: \"block\",\n  content: \"inline*\",\n  parseHTML() {\n    return [\n      { tag: \"p\" }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"p\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setParagraph: () => ({ commands }) => {\n        return commands.setNode(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Alt-0\": () => this.editor.commands.setParagraph()\n    };\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-paragraph/dist/tiptap-extension-paragraph.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-placeholder/dist/tiptap-extension-placeholder.esm.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-placeholder/dist/tiptap-extension-placeholder.esm.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Placeholder\": () => (/* binding */ Placeholder),\n/* harmony export */   \"default\": () => (/* binding */ Placeholder)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"./node_modules/prosemirror-view/dist/index.js\");\n\n\n\nconst Placeholder = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n  name: \"placeholder\",\n  addOptions() {\n    return {\n      emptyEditorClass: \"is-editor-empty\",\n      emptyNodeClass: \"is-empty\",\n      placeholder: \"Write something \\u2026\",\n      showOnlyWhenEditable: true,\n      showOnlyCurrent: true,\n      includeChildren: false\n    };\n  },\n  addProseMirrorPlugins() {\n    return [\n      new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({\n        props: {\n          decorations: ({ doc, selection }) => {\n            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n            const { anchor } = selection;\n            const decorations = [];\n            if (!active) {\n              return null;\n            }\n            const emptyDocInstance = doc.type.createAndFill();\n            const isEditorEmpty = (emptyDocInstance === null || emptyDocInstance === void 0 ? void 0 : emptyDocInstance.sameMarkup(doc)) && emptyDocInstance.content.findDiffStart(doc.content) === null;\n            doc.descendants((node, pos) => {\n              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n              const isEmpty = !node.isLeaf && !node.childCount;\n              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                const classes = [this.options.emptyNodeClass];\n                if (isEditorEmpty) {\n                  classes.push(this.options.emptyEditorClass);\n                }\n                const decoration = prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.node(pos, pos + node.nodeSize, {\n                  class: classes.join(\" \"),\n                  \"data-placeholder\": typeof this.options.placeholder === \"function\" ? this.options.placeholder({\n                    editor: this.editor,\n                    node,\n                    pos,\n                    hasAnchor\n                  }) : this.options.placeholder\n                });\n                decorations.push(decoration);\n              }\n              return this.options.includeChildren;\n            });\n            return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(doc, decorations);\n          }\n        }\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-placeholder/dist/tiptap-extension-placeholder.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-strike/dist/tiptap-extension-strike.esm.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/tiptap-extension-strike.esm.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Strike\": () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ Strike),\n/* harmony export */   \"inputRegex\": () => (/* binding */ inputRegex),\n/* harmony export */   \"pasteRegex\": () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst inputRegex = /(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))$/;\nconst pasteRegex = /(?:^|\\s)((?:~~)((?:[^~]+))(?:~~))/g;\nconst Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n  name: \"strike\",\n  addOptions() {\n    return {\n      HTMLAttributes: {}\n    };\n  },\n  parseHTML() {\n    return [\n      {\n        tag: \"s\"\n      },\n      {\n        tag: \"del\"\n      },\n      {\n        tag: \"strike\"\n      },\n      {\n        style: \"text-decoration\",\n        consuming: false,\n        getAttrs: (style) => style.includes(\"line-through\") ? {} : false\n      }\n    ];\n  },\n  renderHTML({ HTMLAttributes }) {\n    return [\"s\", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setStrike: () => ({ commands }) => {\n        return commands.setMark(this.name);\n      },\n      toggleStrike: () => ({ commands }) => {\n        return commands.toggleMark(this.name);\n      },\n      unsetStrike: () => ({ commands }) => {\n        return commands.unsetMark(this.name);\n      }\n    };\n  },\n  addKeyboardShortcuts() {\n    return {\n      \"Mod-Shift-x\": () => this.editor.commands.toggleStrike()\n    };\n  },\n  addInputRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n        find: inputRegex,\n        type: this.type\n      })\n    ];\n  },\n  addPasteRules() {\n    return [\n      (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n        find: pasteRegex,\n        type: this.type\n      })\n    ];\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-strike/dist/tiptap-extension-strike.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/extension-text/dist/tiptap-extension-text.esm.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/tiptap-extension-text.esm.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Text\": () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n\nconst Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n  name: \"text\",\n  group: \"inline\"\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/extension-text/dist/tiptap-extension-text.esm.js?");

/***/ }),

/***/ "./node_modules/@tiptap/starter-kit/dist/tiptap-starter-kit.esm.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/tiptap-starter-kit.esm.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StarterKit\": () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ StarterKit)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tiptap/core */ \"./node_modules/@tiptap/core/dist/tiptap-core.esm.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"./node_modules/@tiptap/extension-blockquote/dist/tiptap-extension-blockquote.esm.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"./node_modules/@tiptap/extension-bold/dist/tiptap-extension-bold.esm.js\");\n/* harmony import */ var _tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-bullet-list */ \"./node_modules/@tiptap/extension-bullet-list/dist/tiptap-extension-bullet-list.esm.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code */ \"./node_modules/@tiptap/extension-code/dist/tiptap-extension-code.esm.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"./node_modules/@tiptap/extension-code-block/dist/tiptap-extension-code-block.esm.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-document */ \"./node_modules/@tiptap/extension-document/dist/tiptap-extension-document.esm.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"./node_modules/@tiptap/extension-dropcursor/dist/tiptap-extension-dropcursor.esm.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"./node_modules/@tiptap/extension-gapcursor/dist/tiptap-extension-gapcursor.esm.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"./node_modules/@tiptap/extension-hard-break/dist/tiptap-extension-hard-break.esm.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-heading */ \"./node_modules/@tiptap/extension-heading/dist/tiptap-extension-heading.esm.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-history */ \"./node_modules/@tiptap/extension-history/dist/tiptap-extension-history.esm.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"./node_modules/@tiptap/extension-horizontal-rule/dist/tiptap-extension-horizontal-rule.esm.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-italic */ \"./node_modules/@tiptap/extension-italic/dist/tiptap-extension-italic.esm.js\");\n/* harmony import */ var _tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-list-item */ \"./node_modules/@tiptap/extension-list-item/dist/tiptap-extension-list-item.esm.js\");\n/* harmony import */ var _tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-ordered-list */ \"./node_modules/@tiptap/extension-ordered-list/dist/tiptap-extension-ordered-list.esm.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"./node_modules/@tiptap/extension-paragraph/dist/tiptap-extension-paragraph.esm.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-strike */ \"./node_modules/@tiptap/extension-strike/dist/tiptap-extension-strike.esm.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/extension-text */ \"./node_modules/@tiptap/extension-text/dist/tiptap-extension-text.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_18__.Extension.create({\n  name: \"starterKit\",\n  addExtensions() {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n    const extensions = [];\n    if (this.options.blockquote !== false) {\n      extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));\n    }\n    if (this.options.bold !== false) {\n      extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));\n    }\n    if (this.options.bulletList !== false) {\n      extensions.push(_tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__.BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));\n    }\n    if (this.options.code !== false) {\n      extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__.Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));\n    }\n    if (this.options.codeBlock !== false) {\n      extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__.CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));\n    }\n    if (this.options.document !== false) {\n      extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__.Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));\n    }\n    if (this.options.dropcursor !== false) {\n      extensions.push(_tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__.Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));\n    }\n    if (this.options.gapcursor !== false) {\n      extensions.push(_tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__.Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));\n    }\n    if (this.options.hardBreak !== false) {\n      extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__.HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));\n    }\n    if (this.options.heading !== false) {\n      extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__.Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));\n    }\n    if (this.options.history !== false) {\n      extensions.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__.History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));\n    }\n    if (this.options.horizontalRule !== false) {\n      extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__.HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));\n    }\n    if (this.options.italic !== false) {\n      extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__.Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));\n    }\n    if (this.options.listItem !== false) {\n      extensions.push(_tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__.ListItem.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));\n    }\n    if (this.options.orderedList !== false) {\n      extensions.push(_tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__.OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));\n    }\n    if (this.options.paragraph !== false) {\n      extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__.Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));\n    }\n    if (this.options.strike !== false) {\n      extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__.Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));\n    }\n    if (this.options.text !== false) {\n      extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__.Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));\n    }\n    return extensions;\n  }\n});\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/@tiptap/starter-kit/dist/tiptap-starter-kit.esm.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(cssWithMappingToString) {\n  var list = [];\n  list.toString = function toString() {\n    return this.map(function(item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, void 0]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n\n//# sourceURL=webpack://cms_git/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function(i) {\n  return i[1];\n};\n\n\n//# sourceURL=webpack://cms_git/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/netlify-identity-widget/build/netlify-identity.js":
/*!************************************************************************!*\
  !*** ./node_modules/netlify-identity-widget/build/netlify-identity.js ***!
  \************************************************************************/
/***/ (function(module) {

eval("!function(e, n) {\n   true ? module.exports = n() : 0;\n}(this, function() {\n  return function(e) {\n    var n = {};\n    function t(r) {\n      if (n[r])\n        return n[r].exports;\n      var o = n[r] = { i: r, l: false, exports: {} };\n      return e[r].call(o.exports, o, o.exports, t), o.l = true, o.exports;\n    }\n    return t.m = e, t.c = n, t.d = function(e2, n2, r) {\n      t.o(e2, n2) || Object.defineProperty(e2, n2, { enumerable: true, get: r });\n    }, t.r = function(e2) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: \"Module\" }), Object.defineProperty(e2, \"__esModule\", { value: true });\n    }, t.t = function(e2, n2) {\n      if (1 & n2 && (e2 = t(e2)), 8 & n2)\n        return e2;\n      if (4 & n2 && \"object\" == typeof e2 && e2 && e2.__esModule)\n        return e2;\n      var r = /* @__PURE__ */ Object.create(null);\n      if (t.r(r), Object.defineProperty(r, \"default\", { enumerable: true, value: e2 }), 2 & n2 && \"string\" != typeof e2)\n        for (var o in e2)\n          t.d(r, o, function(n3) {\n            return e2[n3];\n          }.bind(null, o));\n      return r;\n    }, t.n = function(e2) {\n      var n2 = e2 && e2.__esModule ? function() {\n        return e2.default;\n      } : function() {\n        return e2;\n      };\n      return t.d(n2, \"a\", n2), n2;\n    }, t.o = function(e2, n2) {\n      return Object.prototype.hasOwnProperty.call(e2, n2);\n    }, t.p = \"/\", t(t.s = 8);\n  }([function(e, n, t) {\n    \"use strict\";\n    t.r(n), t.d(n, \"h\", function() {\n      return a;\n    }), t.d(n, \"createElement\", function() {\n      return a;\n    }), t.d(n, \"cloneElement\", function() {\n      return l;\n    }), t.d(n, \"createRef\", function() {\n      return _;\n    }), t.d(n, \"Component\", function() {\n      return Y;\n    }), t.d(n, \"render\", function() {\n      return Q;\n    }), t.d(n, \"rerender\", function() {\n      return y;\n    }), t.d(n, \"options\", function() {\n      return o;\n    });\n    var r = function() {\n    }, o = {}, i = [], M = [];\n    function a(e2, n2) {\n      var t2, a2, u2, s2, c2 = M;\n      for (s2 = arguments.length; s2-- > 2; )\n        i.push(arguments[s2]);\n      for (n2 && null != n2.children && (i.length || i.push(n2.children), delete n2.children); i.length; )\n        if ((a2 = i.pop()) && void 0 !== a2.pop)\n          for (s2 = a2.length; s2--; )\n            i.push(a2[s2]);\n        else\n          \"boolean\" == typeof a2 && (a2 = null), (u2 = \"function\" != typeof e2) && (null == a2 ? a2 = \"\" : \"number\" == typeof a2 ? a2 = String(a2) : \"string\" != typeof a2 && (u2 = false)), u2 && t2 ? c2[c2.length - 1] += a2 : c2 === M ? c2 = [a2] : c2.push(a2), t2 = u2;\n      var l2 = new r();\n      return l2.nodeName = e2, l2.children = c2, l2.attributes = null == n2 ? void 0 : n2, l2.key = null == n2 ? void 0 : n2.key, void 0 !== o.vnode && o.vnode(l2), l2;\n    }\n    function u(e2, n2) {\n      for (var t2 in n2)\n        e2[t2] = n2[t2];\n      return e2;\n    }\n    function s(e2, n2) {\n      e2 && (\"function\" == typeof e2 ? e2(n2) : e2.current = n2);\n    }\n    var c = \"function\" == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n    function l(e2, n2) {\n      return a(e2.nodeName, u(u({}, e2.attributes), n2), arguments.length > 2 ? [].slice.call(arguments, 2) : e2.children);\n    }\n    var N = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i, D = [];\n    function g(e2) {\n      !e2._dirty && (e2._dirty = true) && 1 == D.push(e2) && (o.debounceRendering || c)(y);\n    }\n    function y() {\n      for (var e2; e2 = D.pop(); )\n        e2._dirty && S(e2);\n    }\n    function j(e2, n2, t2) {\n      return \"string\" == typeof n2 || \"number\" == typeof n2 ? void 0 !== e2.splitText : \"string\" == typeof n2.nodeName ? !e2._componentConstructor && z(e2, n2.nodeName) : t2 || e2._componentConstructor === n2.nodeName;\n    }\n    function z(e2, n2) {\n      return e2.normalizedNodeName === n2 || e2.nodeName.toLowerCase() === n2.toLowerCase();\n    }\n    function T(e2) {\n      var n2 = u({}, e2.attributes);\n      n2.children = e2.children;\n      var t2 = e2.nodeName.defaultProps;\n      if (void 0 !== t2)\n        for (var r2 in t2)\n          void 0 === n2[r2] && (n2[r2] = t2[r2]);\n      return n2;\n    }\n    function f(e2) {\n      var n2 = e2.parentNode;\n      n2 && n2.removeChild(e2);\n    }\n    function A(e2, n2, t2, r2, o2) {\n      if (\"className\" === n2 && (n2 = \"class\"), \"key\" === n2)\n        ;\n      else if (\"ref\" === n2)\n        s(t2, null), s(r2, e2);\n      else if (\"class\" !== n2 || o2)\n        if (\"style\" === n2) {\n          if (r2 && \"string\" != typeof r2 && \"string\" != typeof t2 || (e2.style.cssText = r2 || \"\"), r2 && \"object\" == typeof r2) {\n            if (\"string\" != typeof t2)\n              for (var i2 in t2)\n                i2 in r2 || (e2.style[i2] = \"\");\n            for (var i2 in r2)\n              e2.style[i2] = \"number\" == typeof r2[i2] && false === N.test(i2) ? r2[i2] + \"px\" : r2[i2];\n          }\n        } else if (\"dangerouslySetInnerHTML\" === n2)\n          r2 && (e2.innerHTML = r2.__html || \"\");\n        else if (\"o\" == n2[0] && \"n\" == n2[1]) {\n          var M2 = n2 !== (n2 = n2.replace(/Capture$/, \"\"));\n          n2 = n2.toLowerCase().substring(2), r2 ? t2 || e2.addEventListener(n2, d, M2) : e2.removeEventListener(n2, d, M2), (e2._listeners || (e2._listeners = {}))[n2] = r2;\n        } else if (\"list\" !== n2 && \"type\" !== n2 && !o2 && n2 in e2) {\n          try {\n            e2[n2] = null == r2 ? \"\" : r2;\n          } catch (e3) {\n          }\n          null != r2 && false !== r2 || \"spellcheck\" == n2 || e2.removeAttribute(n2);\n        } else {\n          var a2 = o2 && n2 !== (n2 = n2.replace(/^xlink:?/, \"\"));\n          null == r2 || false === r2 ? a2 ? e2.removeAttributeNS(\"http://www.w3.org/1999/xlink\", n2.toLowerCase()) : e2.removeAttribute(n2) : \"function\" != typeof r2 && (a2 ? e2.setAttributeNS(\"http://www.w3.org/1999/xlink\", n2.toLowerCase(), r2) : e2.setAttribute(n2, r2));\n        }\n      else\n        e2.className = r2 || \"\";\n    }\n    function d(e2) {\n      return this._listeners[e2.type](o.event && o.event(e2) || e2);\n    }\n    var p = [], E = 0, w = false, I = false;\n    function O() {\n      for (var e2; e2 = p.shift(); )\n        o.afterMount && o.afterMount(e2), e2.componentDidMount && e2.componentDidMount();\n    }\n    function x(e2, n2, t2, r2, o2, i2) {\n      E++ || (w = null != o2 && void 0 !== o2.ownerSVGElement, I = null != e2 && !(\"__preactattr_\" in e2));\n      var M2 = L(e2, n2, t2, r2, i2);\n      return o2 && M2.parentNode !== o2 && o2.appendChild(M2), --E || (I = false, i2 || O()), M2;\n    }\n    function L(e2, n2, t2, r2, o2) {\n      var i2 = e2, M2 = w;\n      if (null != n2 && \"boolean\" != typeof n2 || (n2 = \"\"), \"string\" == typeof n2 || \"number\" == typeof n2)\n        return e2 && void 0 !== e2.splitText && e2.parentNode && (!e2._component || o2) ? e2.nodeValue != n2 && (e2.nodeValue = n2) : (i2 = document.createTextNode(n2), e2 && (e2.parentNode && e2.parentNode.replaceChild(i2, e2), h(e2, true))), i2.__preactattr_ = true, i2;\n      var a2, u2, s2 = n2.nodeName;\n      if (\"function\" == typeof s2)\n        return function(e3, n3, t3, r3) {\n          var o3 = e3 && e3._component, i3 = o3, M3 = e3, a3 = o3 && e3._componentConstructor === n3.nodeName, u3 = a3, s3 = T(n3);\n          for (; o3 && !u3 && (o3 = o3._parentComponent); )\n            u3 = o3.constructor === n3.nodeName;\n          o3 && u3 && (!r3 || o3._component) ? (C(o3, s3, 3, t3, r3), e3 = o3.base) : (i3 && !a3 && (U(i3), e3 = M3 = null), o3 = b(n3.nodeName, s3, t3), e3 && !o3.nextBase && (o3.nextBase = e3, M3 = null), C(o3, s3, 1, t3, r3), e3 = o3.base, M3 && e3 !== M3 && (M3._component = null, h(M3, false)));\n          return e3;\n        }(e2, n2, t2, r2);\n      if (w = \"svg\" === s2 || \"foreignObject\" !== s2 && w, s2 = String(s2), (!e2 || !z(e2, s2)) && (a2 = s2, (u2 = w ? document.createElementNS(\"http://www.w3.org/2000/svg\", a2) : document.createElement(a2)).normalizedNodeName = a2, i2 = u2, e2)) {\n        for (; e2.firstChild; )\n          i2.appendChild(e2.firstChild);\n        e2.parentNode && e2.parentNode.replaceChild(i2, e2), h(e2, true);\n      }\n      var c2 = i2.firstChild, l2 = i2.__preactattr_, N2 = n2.children;\n      if (null == l2) {\n        l2 = i2.__preactattr_ = {};\n        for (var D2 = i2.attributes, g2 = D2.length; g2--; )\n          l2[D2[g2].name] = D2[g2].value;\n      }\n      return !I && N2 && 1 === N2.length && \"string\" == typeof N2[0] && null != c2 && void 0 !== c2.splitText && null == c2.nextSibling ? c2.nodeValue != N2[0] && (c2.nodeValue = N2[0]) : (N2 && N2.length || null != c2) && function(e3, n3, t3, r3, o3) {\n        var i3, M3, a3, u3, s3, c3 = e3.childNodes, l3 = [], N3 = {}, D3 = 0, g3 = 0, y2 = c3.length, z2 = 0, T2 = n3 ? n3.length : 0;\n        if (0 !== y2)\n          for (var A2 = 0; A2 < y2; A2++) {\n            var d2 = c3[A2], p2 = d2.__preactattr_;\n            null != (E2 = T2 && p2 ? d2._component ? d2._component.__key : p2.key : null) ? (D3++, N3[E2] = d2) : (p2 || (void 0 !== d2.splitText ? !o3 || d2.nodeValue.trim() : o3)) && (l3[z2++] = d2);\n          }\n        if (0 !== T2)\n          for (A2 = 0; A2 < T2; A2++) {\n            var E2;\n            if (u3 = n3[A2], s3 = null, null != (E2 = u3.key))\n              D3 && void 0 !== N3[E2] && (s3 = N3[E2], N3[E2] = void 0, D3--);\n            else if (g3 < z2) {\n              for (i3 = g3; i3 < z2; i3++)\n                if (void 0 !== l3[i3] && j(M3 = l3[i3], u3, o3)) {\n                  s3 = M3, l3[i3] = void 0, i3 === z2 - 1 && z2--, i3 === g3 && g3++;\n                  break;\n                }\n            }\n            s3 = L(s3, u3, t3, r3), a3 = c3[A2], s3 && s3 !== e3 && s3 !== a3 && (null == a3 ? e3.appendChild(s3) : s3 === a3.nextSibling ? f(a3) : e3.insertBefore(s3, a3));\n          }\n        if (D3)\n          for (var A2 in N3)\n            void 0 !== N3[A2] && h(N3[A2], false);\n        for (; g3 <= z2; )\n          void 0 !== (s3 = l3[z2--]) && h(s3, false);\n      }(i2, N2, t2, r2, I || null != l2.dangerouslySetInnerHTML), function(e3, n3, t3) {\n        var r3;\n        for (r3 in t3)\n          n3 && null != n3[r3] || null == t3[r3] || A(e3, r3, t3[r3], t3[r3] = void 0, w);\n        for (r3 in n3)\n          \"children\" === r3 || \"innerHTML\" === r3 || r3 in t3 && n3[r3] === (\"value\" === r3 || \"checked\" === r3 ? e3[r3] : t3[r3]) || A(e3, r3, t3[r3], t3[r3] = n3[r3], w);\n      }(i2, n2.attributes, l2), w = M2, i2;\n    }\n    function h(e2, n2) {\n      var t2 = e2._component;\n      t2 ? U(t2) : (null != e2.__preactattr_ && s(e2.__preactattr_.ref, null), false !== n2 && null != e2.__preactattr_ || f(e2), v(e2));\n    }\n    function v(e2) {\n      for (e2 = e2.lastChild; e2; ) {\n        var n2 = e2.previousSibling;\n        h(e2, true), e2 = n2;\n      }\n    }\n    var m = [];\n    function b(e2, n2, t2) {\n      var r2, o2 = m.length;\n      for (e2.prototype && e2.prototype.render ? (r2 = new e2(n2, t2), Y.call(r2, n2, t2)) : ((r2 = new Y(n2, t2)).constructor = e2, r2.render = k); o2--; )\n        if (m[o2].constructor === e2)\n          return r2.nextBase = m[o2].nextBase, m.splice(o2, 1), r2;\n      return r2;\n    }\n    function k(e2, n2, t2) {\n      return this.constructor(e2, t2);\n    }\n    function C(e2, n2, t2, r2, i2) {\n      e2._disable || (e2._disable = true, e2.__ref = n2.ref, e2.__key = n2.key, delete n2.ref, delete n2.key, void 0 === e2.constructor.getDerivedStateFromProps && (!e2.base || i2 ? e2.componentWillMount && e2.componentWillMount() : e2.componentWillReceiveProps && e2.componentWillReceiveProps(n2, r2)), r2 && r2 !== e2.context && (e2.prevContext || (e2.prevContext = e2.context), e2.context = r2), e2.prevProps || (e2.prevProps = e2.props), e2.props = n2, e2._disable = false, 0 !== t2 && (1 !== t2 && false === o.syncComponentUpdates && e2.base ? g(e2) : S(e2, 1, i2)), s(e2.__ref, e2));\n    }\n    function S(e2, n2, t2, r2) {\n      if (!e2._disable) {\n        var i2, M2, a2, s2 = e2.props, c2 = e2.state, l2 = e2.context, N2 = e2.prevProps || s2, D2 = e2.prevState || c2, g2 = e2.prevContext || l2, y2 = e2.base, j2 = e2.nextBase, z2 = y2 || j2, f2 = e2._component, A2 = false, d2 = g2;\n        if (e2.constructor.getDerivedStateFromProps && (c2 = u(u({}, c2), e2.constructor.getDerivedStateFromProps(s2, c2)), e2.state = c2), y2 && (e2.props = N2, e2.state = D2, e2.context = g2, 2 !== n2 && e2.shouldComponentUpdate && false === e2.shouldComponentUpdate(s2, c2, l2) ? A2 = true : e2.componentWillUpdate && e2.componentWillUpdate(s2, c2, l2), e2.props = s2, e2.state = c2, e2.context = l2), e2.prevProps = e2.prevState = e2.prevContext = e2.nextBase = null, e2._dirty = false, !A2) {\n          i2 = e2.render(s2, c2, l2), e2.getChildContext && (l2 = u(u({}, l2), e2.getChildContext())), y2 && e2.getSnapshotBeforeUpdate && (d2 = e2.getSnapshotBeforeUpdate(N2, D2));\n          var w2, I2, L2 = i2 && i2.nodeName;\n          if (\"function\" == typeof L2) {\n            var v2 = T(i2);\n            (M2 = f2) && M2.constructor === L2 && v2.key == M2.__key ? C(M2, v2, 1, l2, false) : (w2 = M2, e2._component = M2 = b(L2, v2, l2), M2.nextBase = M2.nextBase || j2, M2._parentComponent = e2, C(M2, v2, 0, l2, false), S(M2, 1, t2, true)), I2 = M2.base;\n          } else\n            a2 = z2, (w2 = f2) && (a2 = e2._component = null), (z2 || 1 === n2) && (a2 && (a2._component = null), I2 = x(a2, i2, l2, t2 || !y2, z2 && z2.parentNode, true));\n          if (z2 && I2 !== z2 && M2 !== f2) {\n            var m2 = z2.parentNode;\n            m2 && I2 !== m2 && (m2.replaceChild(I2, z2), w2 || (z2._component = null, h(z2, false)));\n          }\n          if (w2 && U(w2), e2.base = I2, I2 && !r2) {\n            for (var k2 = e2, Y2 = e2; Y2 = Y2._parentComponent; )\n              (k2 = Y2).base = I2;\n            I2._component = k2, I2._componentConstructor = k2.constructor;\n          }\n        }\n        for (!y2 || t2 ? p.push(e2) : A2 || (e2.componentDidUpdate && e2.componentDidUpdate(N2, D2, d2), o.afterUpdate && o.afterUpdate(e2)); e2._renderCallbacks.length; )\n          e2._renderCallbacks.pop().call(e2);\n        E || r2 || O();\n      }\n    }\n    function U(e2) {\n      o.beforeUnmount && o.beforeUnmount(e2);\n      var n2 = e2.base;\n      e2._disable = true, e2.componentWillUnmount && e2.componentWillUnmount(), e2.base = null;\n      var t2 = e2._component;\n      t2 ? U(t2) : n2 && (null != n2.__preactattr_ && s(n2.__preactattr_.ref, null), e2.nextBase = n2, f(n2), m.push(e2), v(n2)), s(e2.__ref, null);\n    }\n    function Y(e2, n2) {\n      this._dirty = true, this.context = n2, this.props = e2, this.state = this.state || {}, this._renderCallbacks = [];\n    }\n    function Q(e2, n2, t2) {\n      return x(t2, e2, {}, false, n2, false);\n    }\n    function _() {\n      return {};\n    }\n    u(Y.prototype, { setState: function(e2, n2) {\n      this.prevState || (this.prevState = this.state), this.state = u(u({}, this.state), \"function\" == typeof e2 ? e2(this.state, this.props) : e2), n2 && this._renderCallbacks.push(n2), g(this);\n    }, forceUpdate: function(e2) {\n      e2 && this._renderCallbacks.push(e2), S(this, 2);\n    }, render: function() {\n    } });\n    var B = { h: a, createElement: a, cloneElement: l, createRef: _, Component: Y, render: Q, rerender: y, options: o };\n    n.default = B;\n  }, function(e, n, t) {\n    \"use strict\";\n    t.r(n), function(e2) {\n      t.d(n, \"$mobx\", function() {\n        return d;\n      }), t.d(n, \"FlowCancellationError\", function() {\n        return On;\n      }), t.d(n, \"IDerivationState\", function() {\n        return K;\n      }), t.d(n, \"ObservableMap\", function() {\n        return At;\n      }), t.d(n, \"ObservableSet\", function() {\n        return Et;\n      }), t.d(n, \"Reaction\", function() {\n        return Ve;\n      }), t.d(n, \"_allowStateChanges\", function() {\n        return Ee;\n      }), t.d(n, \"_allowStateChangesInsideComputed\", function() {\n        return Oe;\n      }), t.d(n, \"_allowStateReadsEnd\", function() {\n        return ge;\n      }), t.d(n, \"_allowStateReadsStart\", function() {\n        return De;\n      }), t.d(n, \"_endAction\", function() {\n        return pe;\n      }), t.d(n, \"_getAdministration\", function() {\n        return kt;\n      }), t.d(n, \"_getGlobalState\", function() {\n        return Qe;\n      }), t.d(n, \"_interceptReads\", function() {\n        return vn;\n      }), t.d(n, \"_isComputingDerivation\", function() {\n        return Me;\n      }), t.d(n, \"_resetGlobalState\", function() {\n        return _e;\n      }), t.d(n, \"_startAction\", function() {\n        return de;\n      }), t.d(n, \"action\", function() {\n        return on;\n      }), t.d(n, \"autorun\", function() {\n        return sn;\n      }), t.d(n, \"comparer\", function() {\n        return I;\n      }), t.d(n, \"computed\", function() {\n        return te;\n      }), t.d(n, \"configure\", function() {\n        return jn;\n      }), t.d(n, \"createAtom\", function() {\n        return w;\n      }), t.d(n, \"decorate\", function() {\n        return zn;\n      }), t.d(n, \"entries\", function() {\n        return Bn;\n      }), t.d(n, \"extendObservable\", function() {\n        return Tn;\n      }), t.d(n, \"flow\", function() {\n        return Ln;\n      }), t.d(n, \"get\", function() {\n        return Gn;\n      }), t.d(n, \"getAtom\", function() {\n        return bt;\n      }), t.d(n, \"getDebugName\", function() {\n        return Ct;\n      }), t.d(n, \"getDependencyTree\", function() {\n        return dn;\n      }), t.d(n, \"getObserverTree\", function() {\n        return En;\n      }), t.d(n, \"has\", function() {\n        return Zn;\n      }), t.d(n, \"intercept\", function() {\n        return mn;\n      }), t.d(n, \"isAction\", function() {\n        return an;\n      }), t.d(n, \"isArrayLike\", function() {\n        return g;\n      }), t.d(n, \"isBoxedObservable\", function() {\n        return Le;\n      }), t.d(n, \"isComputed\", function() {\n        return kn;\n      }), t.d(n, \"isComputedProp\", function() {\n        return Cn;\n      }), t.d(n, \"isFlowCancellationError\", function() {\n        return xn;\n      }), t.d(n, \"isObservable\", function() {\n        return Un;\n      }), t.d(n, \"isObservableArray\", function() {\n        return zt;\n      }), t.d(n, \"isObservableMap\", function() {\n        return dt;\n      }), t.d(n, \"isObservableObject\", function() {\n        return mt;\n      }), t.d(n, \"isObservableProp\", function() {\n        return Yn;\n      }), t.d(n, \"isObservableSet\", function() {\n        return wt;\n      }), t.d(n, \"keys\", function() {\n        return Qn;\n      }), t.d(n, \"observable\", function() {\n        return q;\n      }), t.d(n, \"observe\", function() {\n        return Hn;\n      }), t.d(n, \"onBecomeObserved\", function() {\n        return Dn;\n      }), t.d(n, \"onBecomeUnobserved\", function() {\n        return gn;\n      }), t.d(n, \"onReactionError\", function() {\n        return Je;\n      }), t.d(n, \"reaction\", function() {\n        return Nn;\n      }), t.d(n, \"remove\", function() {\n        return Rn;\n      }), t.d(n, \"runInAction\", function() {\n        return Mn;\n      }), t.d(n, \"set\", function() {\n        return Pn;\n      }), t.d(n, \"spy\", function() {\n        return en;\n      }), t.d(n, \"toJS\", function() {\n        return Jn;\n      }), t.d(n, \"trace\", function() {\n        return Fn;\n      }), t.d(n, \"transaction\", function() {\n        return Xn;\n      }), t.d(n, \"untracked\", function() {\n        return ce;\n      }), t.d(n, \"values\", function() {\n        return _n;\n      }), t.d(n, \"when\", function() {\n        return Kn;\n      });\n      var r = [];\n      Object.freeze(r);\n      var o = {};\n      function i() {\n        return ++Ye.mobxGuid;\n      }\n      function M(e3) {\n        throw a(false, e3), \"X\";\n      }\n      function a(e3, n2) {\n        if (!e3)\n          throw new Error(\"[mobx] \" + (n2 || \"An invariant failed, however the error is obfuscated because this is a production build.\"));\n      }\n      Object.freeze(o);\n      function u(e3) {\n        var n2 = false;\n        return function() {\n          if (!n2)\n            return n2 = true, e3.apply(this, arguments);\n        };\n      }\n      var s = function() {\n      };\n      function c(e3) {\n        return null !== e3 && \"object\" == typeof e3;\n      }\n      function l(e3) {\n        if (null === e3 || \"object\" != typeof e3)\n          return false;\n        var n2 = Object.getPrototypeOf(e3);\n        return n2 === Object.prototype || null === n2;\n      }\n      function N(e3, n2, t2) {\n        Object.defineProperty(e3, n2, { enumerable: false, writable: true, configurable: true, value: t2 });\n      }\n      function D(e3, n2) {\n        var t2 = \"isMobX\" + e3;\n        return n2.prototype[t2] = true, function(e4) {\n          return c(e4) && true === e4[t2];\n        };\n      }\n      function g(e3) {\n        return Array.isArray(e3) || zt(e3);\n      }\n      function y(e3) {\n        return e3 instanceof Map;\n      }\n      function j(e3) {\n        return e3 instanceof Set;\n      }\n      function z(e3) {\n        var n2 = /* @__PURE__ */ new Set();\n        for (var t2 in e3)\n          n2.add(t2);\n        return Object.getOwnPropertySymbols(e3).forEach(function(t3) {\n          Object.getOwnPropertyDescriptor(e3, t3).enumerable && n2.add(t3);\n        }), Array.from(n2);\n      }\n      function T(e3) {\n        return e3 && e3.toString ? e3.toString() : new String(e3).toString();\n      }\n      function f(e3) {\n        return null === e3 ? null : \"object\" == typeof e3 ? \"\" + e3 : e3;\n      }\n      var A = \"undefined\" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols ? function(e3) {\n        return Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3));\n      } : Object.getOwnPropertyNames, d = Symbol(\"mobx administration\"), p = function() {\n        function e3(e4) {\n          void 0 === e4 && (e4 = \"Atom@\" + i()), this.name = e4, this.isPendingUnobservation = false, this.isBeingObserved = false, this.observers = /* @__PURE__ */ new Set(), this.diffValue = 0, this.lastAccessedBy = 0, this.lowestObserverState = K.NOT_TRACKING;\n        }\n        return e3.prototype.onBecomeObserved = function() {\n          this.onBecomeObservedListeners && this.onBecomeObservedListeners.forEach(function(e4) {\n            return e4();\n          });\n        }, e3.prototype.onBecomeUnobserved = function() {\n          this.onBecomeUnobservedListeners && this.onBecomeUnobservedListeners.forEach(function(e4) {\n            return e4();\n          });\n        }, e3.prototype.reportObserved = function() {\n          return He(this);\n        }, e3.prototype.reportChanged = function() {\n          Ze(), function(e4) {\n            if (e4.lowestObserverState === K.STALE)\n              return;\n            e4.lowestObserverState = K.STALE, e4.observers.forEach(function(n2) {\n              n2.dependenciesState === K.UP_TO_DATE && (n2.isTracing !== $.NONE && We(n2, e4), n2.onBecomeStale()), n2.dependenciesState = K.STALE;\n            });\n          }(this), Ge();\n        }, e3.prototype.toString = function() {\n          return this.name;\n        }, e3;\n      }(), E = D(\"Atom\", p);\n      function w(e3, n2, t2) {\n        void 0 === n2 && (n2 = s), void 0 === t2 && (t2 = s);\n        var r2 = new p(e3);\n        return n2 !== s && Dn(r2, n2), t2 !== s && gn(r2, t2), r2;\n      }\n      var I = { identity: function(e3, n2) {\n        return e3 === n2;\n      }, structural: function(e3, n2) {\n        return Ut(e3, n2);\n      }, default: function(e3, n2) {\n        return Object.is(e3, n2);\n      }, shallow: function(e3, n2) {\n        return Ut(e3, n2, 1);\n      } }, O = function(e3, n2) {\n        return (O = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, n3) {\n          e4.__proto__ = n3;\n        } || function(e4, n3) {\n          for (var t2 in n3)\n            n3.hasOwnProperty(t2) && (e4[t2] = n3[t2]);\n        })(e3, n2);\n      };\n      /*! *****************************************************************************\n      Copyright (c) Microsoft Corporation. All rights reserved.\n      Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n      this file except in compliance with the License. You may obtain a copy of the\n      License at http://www.apache.org/licenses/LICENSE-2.0\n      \n      THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n      KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n      WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n      MERCHANTABLITY OR NON-INFRINGEMENT.\n      \n      See the Apache Version 2.0 License for specific language governing permissions\n      and limitations under the License.\n      ***************************************************************************** */\n      var x = function() {\n        return (x = Object.assign || function(e3) {\n          for (var n2, t2 = 1, r2 = arguments.length; t2 < r2; t2++)\n            for (var o2 in n2 = arguments[t2])\n              Object.prototype.hasOwnProperty.call(n2, o2) && (e3[o2] = n2[o2]);\n          return e3;\n        }).apply(this, arguments);\n      };\n      function L(e3) {\n        var n2 = \"function\" == typeof Symbol && e3[Symbol.iterator], t2 = 0;\n        return n2 ? n2.call(e3) : { next: function() {\n          return e3 && t2 >= e3.length && (e3 = void 0), { value: e3 && e3[t2++], done: !e3 };\n        } };\n      }\n      function h(e3, n2) {\n        var t2 = \"function\" == typeof Symbol && e3[Symbol.iterator];\n        if (!t2)\n          return e3;\n        var r2, o2, i2 = t2.call(e3), M2 = [];\n        try {\n          for (; (void 0 === n2 || n2-- > 0) && !(r2 = i2.next()).done; )\n            M2.push(r2.value);\n        } catch (e4) {\n          o2 = { error: e4 };\n        } finally {\n          try {\n            r2 && !r2.done && (t2 = i2.return) && t2.call(i2);\n          } finally {\n            if (o2)\n              throw o2.error;\n          }\n        }\n        return M2;\n      }\n      function v() {\n        for (var e3 = [], n2 = 0; n2 < arguments.length; n2++)\n          e3 = e3.concat(h(arguments[n2]));\n        return e3;\n      }\n      var m = Symbol(\"mobx did run lazy initializers\"), b = Symbol(\"mobx pending decorators\"), k = {}, C = {};\n      function S(e3, n2) {\n        var t2 = n2 ? k : C;\n        return t2[e3] || (t2[e3] = { configurable: true, enumerable: n2, get: function() {\n          return U(this), this[e3];\n        }, set: function(n3) {\n          U(this), this[e3] = n3;\n        } });\n      }\n      function U(e3) {\n        var n2, t2;\n        if (true !== e3[m]) {\n          var r2 = e3[b];\n          if (r2) {\n            N(e3, m, true);\n            var o2 = v(Object.getOwnPropertySymbols(r2), Object.keys(r2));\n            try {\n              for (var i2 = L(o2), M2 = i2.next(); !M2.done; M2 = i2.next()) {\n                var a2 = r2[M2.value];\n                a2.propertyCreator(e3, a2.prop, a2.descriptor, a2.decoratorTarget, a2.decoratorArguments);\n              }\n            } catch (e4) {\n              n2 = { error: e4 };\n            } finally {\n              try {\n                M2 && !M2.done && (t2 = i2.return) && t2.call(i2);\n              } finally {\n                if (n2)\n                  throw n2.error;\n              }\n            }\n          }\n        }\n      }\n      function Y(e3, n2) {\n        return function() {\n          var t2, o2 = function(r2, o3, i2, M2) {\n            if (true === M2)\n              return n2(r2, o3, i2, r2, t2), null;\n            if (!Object.prototype.hasOwnProperty.call(r2, b)) {\n              var a2 = r2[b];\n              N(r2, b, x({}, a2));\n            }\n            return r2[b][o3] = { prop: o3, propertyCreator: n2, descriptor: i2, decoratorTarget: r2, decoratorArguments: t2 }, S(o3, e3);\n          };\n          return Q(arguments) ? (t2 = r, o2.apply(null, arguments)) : (t2 = Array.prototype.slice.call(arguments), o2);\n        };\n      }\n      function Q(e3) {\n        return (2 === e3.length || 3 === e3.length) && (\"string\" == typeof e3[1] || \"symbol\" == typeof e3[1]) || 4 === e3.length && true === e3[3];\n      }\n      function _(e3, n2, t2) {\n        return Un(e3) ? e3 : Array.isArray(e3) ? q.array(e3, { name: t2 }) : l(e3) ? q.object(e3, void 0, { name: t2 }) : y(e3) ? q.map(e3, { name: t2 }) : j(e3) ? q.set(e3, { name: t2 }) : e3;\n      }\n      function B(e3) {\n        return e3;\n      }\n      function P(e3) {\n        a(e3);\n        var n2 = Y(true, function(n3, t3, r2, o2, i2) {\n          var M2 = r2 ? r2.initializer ? r2.initializer.call(n3) : r2.value : void 0;\n          Ot(n3).addObservableProp(t3, M2, e3);\n        }), t2 = (\"undefined\" != typeof process && \"MISSING_ENV_VAR\", n2);\n        return t2.enhancer = e3, t2;\n      }\n      var R = { deep: true, name: void 0, defaultDecorator: void 0, proxy: true };\n      function Z(e3) {\n        return null == e3 ? R : \"string\" == typeof e3 ? { name: e3, deep: true, proxy: true } : e3;\n      }\n      Object.freeze(R);\n      var G = P(_), H = P(function(e3, n2, t2) {\n        return null == e3 || mt(e3) || zt(e3) || dt(e3) || wt(e3) ? e3 : Array.isArray(e3) ? q.array(e3, { name: t2, deep: false }) : l(e3) ? q.object(e3, void 0, { name: t2, deep: false }) : y(e3) ? q.map(e3, { name: t2, deep: false }) : j(e3) ? q.set(e3, { name: t2, deep: false }) : M(false);\n      }), W = P(B), V = P(function(e3, n2, t2) {\n        return Ut(e3, n2) ? n2 : e3;\n      });\n      function J(e3) {\n        return e3.defaultDecorator ? e3.defaultDecorator.enhancer : false === e3.deep ? B : _;\n      }\n      var F = { box: function(e3, n2) {\n        arguments.length > 2 && X(\"box\");\n        var t2 = Z(n2);\n        return new xe(e3, J(t2), t2.name, true, t2.equals);\n      }, array: function(e3, n2) {\n        arguments.length > 2 && X(\"array\");\n        var t2 = Z(n2);\n        return Nt(e3, J(t2), t2.name);\n      }, map: function(e3, n2) {\n        arguments.length > 2 && X(\"map\");\n        var t2 = Z(n2);\n        return new At(e3, J(t2), t2.name);\n      }, set: function(e3, n2) {\n        arguments.length > 2 && X(\"set\");\n        var t2 = Z(n2);\n        return new Et(e3, J(t2), t2.name);\n      }, object: function(e3, n2, t2) {\n        \"string\" == typeof arguments[1] && X(\"object\");\n        var r2 = Z(t2);\n        if (false === r2.proxy)\n          return Tn({}, e3, n2, r2);\n        var o2 = fn(r2), i2 = Tn({}, void 0, void 0, r2), M2 = ot(i2);\n        return An(M2, e3, n2, o2), M2;\n      }, ref: W, shallow: H, deep: G, struct: V }, q = function(e3, n2, t2) {\n        if (\"string\" == typeof arguments[1] || \"symbol\" == typeof arguments[1])\n          return G.apply(null, arguments);\n        if (Un(e3))\n          return e3;\n        var r2 = l(e3) ? q.object(e3, n2, t2) : Array.isArray(e3) ? q.array(e3, n2) : y(e3) ? q.map(e3, n2) : j(e3) ? q.set(e3, n2) : e3;\n        if (r2 !== e3)\n          return r2;\n        M(false);\n      };\n      function X(e3) {\n        M(\"Expected one or two arguments to observable.\" + e3 + \". Did you accidentally try to use observable.\" + e3 + \" as decorator?\");\n      }\n      Object.keys(F).forEach(function(e3) {\n        return q[e3] = F[e3];\n      });\n      var K, $, ee = Y(false, function(e3, n2, t2, r2, o2) {\n        var i2 = t2.get, M2 = t2.set, a2 = o2[0] || {};\n        Ot(e3).addComputedProp(e3, n2, x({ get: i2, set: M2, context: e3 }, a2));\n      }), ne = ee({ equals: I.structural }), te = function(e3, n2, t2) {\n        if (\"string\" == typeof n2)\n          return ee.apply(null, arguments);\n        if (null !== e3 && \"object\" == typeof e3 && 1 === arguments.length)\n          return ee.apply(null, arguments);\n        var r2 = \"object\" == typeof n2 ? n2 : {};\n        return r2.get = e3, r2.set = \"function\" == typeof n2 ? n2 : r2.set, r2.name = r2.name || e3.name || \"\", new he(r2);\n      };\n      te.struct = ne, function(e3) {\n        e3[e3.NOT_TRACKING = -1] = \"NOT_TRACKING\", e3[e3.UP_TO_DATE = 0] = \"UP_TO_DATE\", e3[e3.POSSIBLY_STALE = 1] = \"POSSIBLY_STALE\", e3[e3.STALE = 2] = \"STALE\";\n      }(K || (K = {})), function(e3) {\n        e3[e3.NONE = 0] = \"NONE\", e3[e3.LOG = 1] = \"LOG\", e3[e3.BREAK = 2] = \"BREAK\";\n      }($ || ($ = {}));\n      var re = function(e3) {\n        this.cause = e3;\n      };\n      function oe(e3) {\n        return e3 instanceof re;\n      }\n      function ie(e3) {\n        switch (e3.dependenciesState) {\n          case K.UP_TO_DATE:\n            return false;\n          case K.NOT_TRACKING:\n          case K.STALE:\n            return true;\n          case K.POSSIBLY_STALE:\n            for (var n2 = De(true), t2 = le(), r2 = e3.observing, o2 = r2.length, i2 = 0; i2 < o2; i2++) {\n              var M2 = r2[i2];\n              if (ve(M2)) {\n                if (Ye.disableErrorBoundaries)\n                  M2.get();\n                else\n                  try {\n                    M2.get();\n                  } catch (e4) {\n                    return Ne(t2), ge(n2), true;\n                  }\n                if (e3.dependenciesState === K.STALE)\n                  return Ne(t2), ge(n2), true;\n              }\n            }\n            return ye(e3), Ne(t2), ge(n2), false;\n        }\n      }\n      function Me() {\n        return null !== Ye.trackingDerivation;\n      }\n      function ae(e3) {\n        var n2 = e3.observers.size > 0;\n        Ye.computationDepth > 0 && n2 && M(false), Ye.allowStateChanges || !n2 && \"strict\" !== Ye.enforceActions || M(false);\n      }\n      function ue(e3, n2, t2) {\n        var r2 = De(true);\n        ye(e3), e3.newObserving = new Array(e3.observing.length + 100), e3.unboundDepsCount = 0, e3.runId = ++Ye.runId;\n        var o2, i2 = Ye.trackingDerivation;\n        if (Ye.trackingDerivation = e3, true === Ye.disableErrorBoundaries)\n          o2 = n2.call(t2);\n        else\n          try {\n            o2 = n2.call(t2);\n          } catch (e4) {\n            o2 = new re(e4);\n          }\n        return Ye.trackingDerivation = i2, function(e4) {\n          for (var n3 = e4.observing, t3 = e4.observing = e4.newObserving, r3 = K.UP_TO_DATE, o3 = 0, i3 = e4.unboundDepsCount, M2 = 0; M2 < i3; M2++) {\n            0 === (a2 = t3[M2]).diffValue && (a2.diffValue = 1, o3 !== M2 && (t3[o3] = a2), o3++), a2.dependenciesState > r3 && (r3 = a2.dependenciesState);\n          }\n          t3.length = o3, e4.newObserving = null, i3 = n3.length;\n          for (; i3--; ) {\n            0 === (a2 = n3[i3]).diffValue && Pe(a2, e4), a2.diffValue = 0;\n          }\n          for (; o3--; ) {\n            var a2;\n            1 === (a2 = t3[o3]).diffValue && (a2.diffValue = 0, Be(a2, e4));\n          }\n          r3 !== K.UP_TO_DATE && (e4.dependenciesState = r3, e4.onBecomeStale());\n        }(e3), ge(r2), o2;\n      }\n      function se(e3) {\n        var n2 = e3.observing;\n        e3.observing = [];\n        for (var t2 = n2.length; t2--; )\n          Pe(n2[t2], e3);\n        e3.dependenciesState = K.NOT_TRACKING;\n      }\n      function ce(e3) {\n        var n2 = le();\n        try {\n          return e3();\n        } finally {\n          Ne(n2);\n        }\n      }\n      function le() {\n        var e3 = Ye.trackingDerivation;\n        return Ye.trackingDerivation = null, e3;\n      }\n      function Ne(e3) {\n        Ye.trackingDerivation = e3;\n      }\n      function De(e3) {\n        var n2 = Ye.allowStateReads;\n        return Ye.allowStateReads = e3, n2;\n      }\n      function ge(e3) {\n        Ye.allowStateReads = e3;\n      }\n      function ye(e3) {\n        if (e3.dependenciesState !== K.UP_TO_DATE) {\n          e3.dependenciesState = K.UP_TO_DATE;\n          for (var n2 = e3.observing, t2 = n2.length; t2--; )\n            n2[t2].lowestObserverState = K.UP_TO_DATE;\n        }\n      }\n      var je = 0, ze = 1, Te = Object.getOwnPropertyDescriptor(function() {\n      }, \"name\");\n      Te && Te.configurable;\n      function fe(e3, n2, t2) {\n        var r2 = function() {\n          return Ae(e3, n2, t2 || this, arguments);\n        };\n        return r2.isMobxAction = true, r2;\n      }\n      function Ae(e3, n2, t2, r2) {\n        var o2 = de(e3, t2, r2);\n        try {\n          return n2.apply(t2, r2);\n        } catch (e4) {\n          throw o2.error = e4, e4;\n        } finally {\n          pe(o2);\n        }\n      }\n      function de(e3, n2, t2) {\n        var r2 = 0, o2 = le();\n        Ze();\n        var i2 = { prevDerivation: o2, prevAllowStateChanges: we(true), prevAllowStateReads: De(true), notifySpy: false, startTime: r2, actionId: ze++, parentActionId: je };\n        return je = i2.actionId, i2;\n      }\n      function pe(e3) {\n        je !== e3.actionId && M(\"invalid action stack. did you forget to finish an action?\"), je = e3.parentActionId, void 0 !== e3.error && (Ye.suppressReactionErrors = true), Ie(e3.prevAllowStateChanges), ge(e3.prevAllowStateReads), Ge(), Ne(e3.prevDerivation), e3.notifySpy, Ye.suppressReactionErrors = false;\n      }\n      function Ee(e3, n2) {\n        var t2, r2 = we(e3);\n        try {\n          t2 = n2();\n        } finally {\n          Ie(r2);\n        }\n        return t2;\n      }\n      function we(e3) {\n        var n2 = Ye.allowStateChanges;\n        return Ye.allowStateChanges = e3, n2;\n      }\n      function Ie(e3) {\n        Ye.allowStateChanges = e3;\n      }\n      function Oe(e3) {\n        var n2, t2 = Ye.computationDepth;\n        Ye.computationDepth = 0;\n        try {\n          n2 = e3();\n        } finally {\n          Ye.computationDepth = t2;\n        }\n        return n2;\n      }\n      var xe = function(e3) {\n        function n2(n3, t2, r2, o2, M2) {\n          void 0 === r2 && (r2 = \"ObservableValue@\" + i()), void 0 === o2 && (o2 = true), void 0 === M2 && (M2 = I.default);\n          var a2 = e3.call(this, r2) || this;\n          return a2.enhancer = t2, a2.name = r2, a2.equals = M2, a2.hasUnreportedChange = false, a2.value = t2(n3, void 0, r2), a2;\n        }\n        return function(e4, n3) {\n          function t2() {\n            this.constructor = e4;\n          }\n          O(e4, n3), e4.prototype = null === n3 ? Object.create(n3) : (t2.prototype = n3.prototype, new t2());\n        }(n2, e3), n2.prototype.dehanceValue = function(e4) {\n          return void 0 !== this.dehancer ? this.dehancer(e4) : e4;\n        }, n2.prototype.set = function(e4) {\n          this.value;\n          if ((e4 = this.prepareNewValue(e4)) !== Ye.UNCHANGED) {\n            0, this.setNewValue(e4);\n          }\n        }, n2.prototype.prepareNewValue = function(e4) {\n          if (ae(this), it(this)) {\n            var n3 = at(this, { object: this, type: \"update\", newValue: e4 });\n            if (!n3)\n              return Ye.UNCHANGED;\n            e4 = n3.newValue;\n          }\n          return e4 = this.enhancer(e4, this.value, this.name), this.equals(this.value, e4) ? Ye.UNCHANGED : e4;\n        }, n2.prototype.setNewValue = function(e4) {\n          var n3 = this.value;\n          this.value = e4, this.reportChanged(), ut(this) && ct(this, { type: \"update\", object: this, newValue: e4, oldValue: n3 });\n        }, n2.prototype.get = function() {\n          return this.reportObserved(), this.dehanceValue(this.value);\n        }, n2.prototype.intercept = function(e4) {\n          return Mt(this, e4);\n        }, n2.prototype.observe = function(e4, n3) {\n          return n3 && e4({ object: this, type: \"update\", newValue: this.value, oldValue: void 0 }), st(this, e4);\n        }, n2.prototype.toJSON = function() {\n          return this.get();\n        }, n2.prototype.toString = function() {\n          return this.name + \"[\" + this.value + \"]\";\n        }, n2.prototype.valueOf = function() {\n          return f(this.get());\n        }, n2.prototype[Symbol.toPrimitive] = function() {\n          return this.valueOf();\n        }, n2;\n      }(p), Le = D(\"ObservableValue\", xe), he = function() {\n        function e3(e4) {\n          this.dependenciesState = K.NOT_TRACKING, this.observing = [], this.newObserving = null, this.isBeingObserved = false, this.isPendingUnobservation = false, this.observers = /* @__PURE__ */ new Set(), this.diffValue = 0, this.runId = 0, this.lastAccessedBy = 0, this.lowestObserverState = K.UP_TO_DATE, this.unboundDepsCount = 0, this.__mapid = \"#\" + i(), this.value = new re(null), this.isComputing = false, this.isRunningSetter = false, this.isTracing = $.NONE, a(e4.get, \"missing option for computed: get\"), this.derivation = e4.get, this.name = e4.name || \"ComputedValue@\" + i(), e4.set && (this.setter = fe(this.name + \"-setter\", e4.set)), this.equals = e4.equals || (e4.compareStructural || e4.struct ? I.structural : I.default), this.scope = e4.context, this.requiresReaction = !!e4.requiresReaction, this.keepAlive = !!e4.keepAlive;\n        }\n        return e3.prototype.onBecomeStale = function() {\n          !function(e4) {\n            if (e4.lowestObserverState !== K.UP_TO_DATE)\n              return;\n            e4.lowestObserverState = K.POSSIBLY_STALE, e4.observers.forEach(function(n2) {\n              n2.dependenciesState === K.UP_TO_DATE && (n2.dependenciesState = K.POSSIBLY_STALE, n2.isTracing !== $.NONE && We(n2, e4), n2.onBecomeStale());\n            });\n          }(this);\n        }, e3.prototype.onBecomeObserved = function() {\n          this.onBecomeObservedListeners && this.onBecomeObservedListeners.forEach(function(e4) {\n            return e4();\n          });\n        }, e3.prototype.onBecomeUnobserved = function() {\n          this.onBecomeUnobservedListeners && this.onBecomeUnobservedListeners.forEach(function(e4) {\n            return e4();\n          });\n        }, e3.prototype.get = function() {\n          this.isComputing && M(\"Cycle detected in computation \" + this.name + \": \" + this.derivation), 0 !== Ye.inBatch || 0 !== this.observers.size || this.keepAlive ? (He(this), ie(this) && this.trackAndCompute() && function(e5) {\n            if (e5.lowestObserverState === K.STALE)\n              return;\n            e5.lowestObserverState = K.STALE, e5.observers.forEach(function(n2) {\n              n2.dependenciesState === K.POSSIBLY_STALE ? n2.dependenciesState = K.STALE : n2.dependenciesState === K.UP_TO_DATE && (e5.lowestObserverState = K.UP_TO_DATE);\n            });\n          }(this)) : ie(this) && (this.warnAboutUntrackedRead(), Ze(), this.value = this.computeValue(false), Ge());\n          var e4 = this.value;\n          if (oe(e4))\n            throw e4.cause;\n          return e4;\n        }, e3.prototype.peek = function() {\n          var e4 = this.computeValue(false);\n          if (oe(e4))\n            throw e4.cause;\n          return e4;\n        }, e3.prototype.set = function(e4) {\n          if (this.setter) {\n            a(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\"), this.isRunningSetter = true;\n            try {\n              this.setter.call(this.scope, e4);\n            } finally {\n              this.isRunningSetter = false;\n            }\n          } else\n            a(false, false);\n        }, e3.prototype.trackAndCompute = function() {\n          var e4 = this.value, n2 = this.dependenciesState === K.NOT_TRACKING, t2 = this.computeValue(true), r2 = n2 || oe(e4) || oe(t2) || !this.equals(e4, t2);\n          return r2 && (this.value = t2), r2;\n        }, e3.prototype.computeValue = function(e4) {\n          var n2;\n          if (this.isComputing = true, Ye.computationDepth++, e4)\n            n2 = ue(this, this.derivation, this.scope);\n          else if (true === Ye.disableErrorBoundaries)\n            n2 = this.derivation.call(this.scope);\n          else\n            try {\n              n2 = this.derivation.call(this.scope);\n            } catch (e5) {\n              n2 = new re(e5);\n            }\n          return Ye.computationDepth--, this.isComputing = false, n2;\n        }, e3.prototype.suspend = function() {\n          this.keepAlive || (se(this), this.value = void 0);\n        }, e3.prototype.observe = function(e4, n2) {\n          var t2 = this, r2 = true, o2 = void 0;\n          return sn(function() {\n            var i2 = t2.get();\n            if (!r2 || n2) {\n              var M2 = le();\n              e4({ type: \"update\", object: t2, newValue: i2, oldValue: o2 }), Ne(M2);\n            }\n            r2 = false, o2 = i2;\n          });\n        }, e3.prototype.warnAboutUntrackedRead = function() {\n        }, e3.prototype.toJSON = function() {\n          return this.get();\n        }, e3.prototype.toString = function() {\n          return this.name + \"[\" + this.derivation.toString() + \"]\";\n        }, e3.prototype.valueOf = function() {\n          return f(this.get());\n        }, e3.prototype[Symbol.toPrimitive] = function() {\n          return this.valueOf();\n        }, e3;\n      }(), ve = D(\"ComputedValue\", he), me = [\"mobxGuid\", \"spyListeners\", \"enforceActions\", \"computedRequiresReaction\", \"reactionRequiresObservable\", \"observableRequiresReaction\", \"allowStateReads\", \"disableErrorBoundaries\", \"runId\", \"UNCHANGED\"], be = function() {\n        this.version = 5, this.UNCHANGED = {}, this.trackingDerivation = null, this.computationDepth = 0, this.runId = 0, this.mobxGuid = 0, this.inBatch = 0, this.pendingUnobservations = [], this.pendingReactions = [], this.isRunningReactions = false, this.allowStateChanges = true, this.allowStateReads = true, this.enforceActions = false, this.spyListeners = [], this.globalReactionErrorHandlers = [], this.computedRequiresReaction = false, this.reactionRequiresObservable = false, this.observableRequiresReaction = false, this.computedConfigurable = false, this.disableErrorBoundaries = false, this.suppressReactionErrors = false;\n      }, ke = {};\n      function Ce() {\n        return \"undefined\" != typeof window ? window : void 0 !== e2 ? e2 : \"undefined\" != typeof self ? self : ke;\n      }\n      var Se = true, Ue = false, Ye = function() {\n        var e3 = Ce();\n        return e3.__mobxInstanceCount > 0 && !e3.__mobxGlobals && (Se = false), e3.__mobxGlobals && e3.__mobxGlobals.version !== new be().version && (Se = false), Se ? e3.__mobxGlobals ? (e3.__mobxInstanceCount += 1, e3.__mobxGlobals.UNCHANGED || (e3.__mobxGlobals.UNCHANGED = {}), e3.__mobxGlobals) : (e3.__mobxInstanceCount = 1, e3.__mobxGlobals = new be()) : (setTimeout(function() {\n          Ue || M(\"There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`\");\n        }, 1), new be());\n      }();\n      function Qe() {\n        return Ye;\n      }\n      function _e() {\n        var e3 = new be();\n        for (var n2 in e3)\n          -1 === me.indexOf(n2) && (Ye[n2] = e3[n2]);\n        Ye.allowStateChanges = !Ye.enforceActions;\n      }\n      function Be(e3, n2) {\n        e3.observers.add(n2), e3.lowestObserverState > n2.dependenciesState && (e3.lowestObserverState = n2.dependenciesState);\n      }\n      function Pe(e3, n2) {\n        e3.observers.delete(n2), 0 === e3.observers.size && Re(e3);\n      }\n      function Re(e3) {\n        false === e3.isPendingUnobservation && (e3.isPendingUnobservation = true, Ye.pendingUnobservations.push(e3));\n      }\n      function Ze() {\n        Ye.inBatch++;\n      }\n      function Ge() {\n        if (0 == --Ye.inBatch) {\n          qe();\n          for (var e3 = Ye.pendingUnobservations, n2 = 0; n2 < e3.length; n2++) {\n            var t2 = e3[n2];\n            t2.isPendingUnobservation = false, 0 === t2.observers.size && (t2.isBeingObserved && (t2.isBeingObserved = false, t2.onBecomeUnobserved()), t2 instanceof he && t2.suspend());\n          }\n          Ye.pendingUnobservations = [];\n        }\n      }\n      function He(e3) {\n        var n2 = Ye.trackingDerivation;\n        return null !== n2 ? (n2.runId !== e3.lastAccessedBy && (e3.lastAccessedBy = n2.runId, n2.newObserving[n2.unboundDepsCount++] = e3, e3.isBeingObserved || (e3.isBeingObserved = true, e3.onBecomeObserved())), true) : (0 === e3.observers.size && Ye.inBatch > 0 && Re(e3), false);\n      }\n      function We(e3, n2) {\n        if (console.log(\"[mobx.trace] '\" + e3.name + \"' is invalidated due to a change in: '\" + n2.name + \"'\"), e3.isTracing === $.BREAK) {\n          var t2 = [];\n          !function e4(n3, t3, r2) {\n            if (t3.length >= 1e3)\n              return void t3.push(\"(and many more)\");\n            t3.push(\"\" + new Array(r2).join(\"\t\") + n3.name), n3.dependencies && n3.dependencies.forEach(function(n4) {\n              return e4(n4, t3, r2 + 1);\n            });\n          }(dn(e3), t2, 1), new Function(\"debugger;\\n/*\\nTracing '\" + e3.name + \"'\\n\\nYou are entering this break point because derivation '\" + e3.name + \"' is being traced and '\" + n2.name + \"' is now forcing it to update.\\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\\n\\n\" + (e3 instanceof he ? e3.derivation.toString().replace(/[*]\\//g, \"/\") : \"\") + \"\\n\\nThe dependencies for this derivation are:\\n\\n\" + t2.join(\"\\n\") + \"\\n*/\\n    \")();\n        }\n      }\n      var Ve = function() {\n        function e3(e4, n2, t2, r2) {\n          void 0 === e4 && (e4 = \"Reaction@\" + i()), void 0 === r2 && (r2 = false), this.name = e4, this.onInvalidate = n2, this.errorHandler = t2, this.requiresObservable = r2, this.observing = [], this.newObserving = [], this.dependenciesState = K.NOT_TRACKING, this.diffValue = 0, this.runId = 0, this.unboundDepsCount = 0, this.__mapid = \"#\" + i(), this.isDisposed = false, this._isScheduled = false, this._isTrackPending = false, this._isRunning = false, this.isTracing = $.NONE;\n        }\n        return e3.prototype.onBecomeStale = function() {\n          this.schedule();\n        }, e3.prototype.schedule = function() {\n          this._isScheduled || (this._isScheduled = true, Ye.pendingReactions.push(this), qe());\n        }, e3.prototype.isScheduled = function() {\n          return this._isScheduled;\n        }, e3.prototype.runReaction = function() {\n          if (!this.isDisposed) {\n            if (Ze(), this._isScheduled = false, ie(this)) {\n              this._isTrackPending = true;\n              try {\n                this.onInvalidate(), this._isTrackPending;\n              } catch (e4) {\n                this.reportExceptionInDerivation(e4);\n              }\n            }\n            Ge();\n          }\n        }, e3.prototype.track = function(e4) {\n          if (!this.isDisposed) {\n            Ze();\n            0, this._isRunning = true;\n            var n2 = ue(this, e4, void 0);\n            this._isRunning = false, this._isTrackPending = false, this.isDisposed && se(this), oe(n2) && this.reportExceptionInDerivation(n2.cause), Ge();\n          }\n        }, e3.prototype.reportExceptionInDerivation = function(e4) {\n          var n2 = this;\n          if (this.errorHandler)\n            this.errorHandler(e4, this);\n          else {\n            if (Ye.disableErrorBoundaries)\n              throw e4;\n            var t2 = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this + \"'\";\n            Ye.suppressReactionErrors ? console.warn(\"[mobx] (error in reaction '\" + this.name + \"' suppressed, fix error of causing action below)\") : console.error(t2, e4), Ye.globalReactionErrorHandlers.forEach(function(t3) {\n              return t3(e4, n2);\n            });\n          }\n        }, e3.prototype.dispose = function() {\n          this.isDisposed || (this.isDisposed = true, this._isRunning || (Ze(), se(this), Ge()));\n        }, e3.prototype.getDisposer = function() {\n          var e4 = this.dispose.bind(this);\n          return e4[d] = this, e4;\n        }, e3.prototype.toString = function() {\n          return \"Reaction[\" + this.name + \"]\";\n        }, e3.prototype.trace = function(e4) {\n          void 0 === e4 && (e4 = false), Fn(this, e4);\n        }, e3;\n      }();\n      function Je(e3) {\n        return Ye.globalReactionErrorHandlers.push(e3), function() {\n          var n2 = Ye.globalReactionErrorHandlers.indexOf(e3);\n          n2 >= 0 && Ye.globalReactionErrorHandlers.splice(n2, 1);\n        };\n      }\n      var Fe = function(e3) {\n        return e3();\n      };\n      function qe() {\n        Ye.inBatch > 0 || Ye.isRunningReactions || Fe(Xe);\n      }\n      function Xe() {\n        Ye.isRunningReactions = true;\n        for (var e3 = Ye.pendingReactions, n2 = 0; e3.length > 0; ) {\n          100 == ++n2 && (console.error(\"Reaction doesn't converge to a stable state after 100 iterations. Probably there is a cycle in the reactive function: \" + e3[0]), e3.splice(0));\n          for (var t2 = e3.splice(0), r2 = 0, o2 = t2.length; r2 < o2; r2++)\n            t2[r2].runReaction();\n        }\n        Ye.isRunningReactions = false;\n      }\n      var Ke = D(\"Reaction\", Ve);\n      function $e(e3) {\n        var n2 = Fe;\n        Fe = function(t2) {\n          return e3(function() {\n            return n2(t2);\n          });\n        };\n      }\n      function en(e3) {\n        return console.warn(\"[mobx.spy] Is a no-op in production builds\"), function() {\n        };\n      }\n      function nn() {\n        M(false);\n      }\n      function tn(e3) {\n        return function(n2, t2, r2) {\n          if (r2) {\n            if (r2.value)\n              return { value: fe(e3, r2.value), enumerable: false, configurable: true, writable: true };\n            var o2 = r2.initializer;\n            return { enumerable: false, configurable: true, writable: true, initializer: function() {\n              return fe(e3, o2.call(this));\n            } };\n          }\n          return rn(e3).apply(this, arguments);\n        };\n      }\n      function rn(e3) {\n        return function(n2, t2, r2) {\n          Object.defineProperty(n2, t2, { configurable: true, enumerable: false, get: function() {\n          }, set: function(n3) {\n            N(this, t2, on(e3, n3));\n          } });\n        };\n      }\n      var on = function(e3, n2, t2, r2) {\n        return 1 === arguments.length && \"function\" == typeof e3 ? fe(e3.name || \"<unnamed action>\", e3) : 2 === arguments.length && \"function\" == typeof n2 ? fe(e3, n2) : 1 === arguments.length && \"string\" == typeof e3 ? tn(e3) : true !== r2 ? tn(n2).apply(null, arguments) : void N(e3, n2, fe(e3.name || n2, t2.value, this));\n      };\n      function Mn(e3, n2) {\n        return Ae(\"string\" == typeof e3 ? e3 : e3.name || \"<unnamed action>\", \"function\" == typeof e3 ? e3 : n2, this, void 0);\n      }\n      function an(e3) {\n        return \"function\" == typeof e3 && true === e3.isMobxAction;\n      }\n      function un(e3, n2, t2) {\n        N(e3, n2, fe(n2, t2.bind(e3)));\n      }\n      function sn(e3, n2) {\n        void 0 === n2 && (n2 = o);\n        var t2, r2 = n2 && n2.name || e3.name || \"Autorun@\" + i();\n        if (!n2.scheduler && !n2.delay)\n          t2 = new Ve(r2, function() {\n            this.track(u2);\n          }, n2.onError, n2.requiresObservable);\n        else {\n          var M2 = ln(n2), a2 = false;\n          t2 = new Ve(r2, function() {\n            a2 || (a2 = true, M2(function() {\n              a2 = false, t2.isDisposed || t2.track(u2);\n            }));\n          }, n2.onError, n2.requiresObservable);\n        }\n        function u2() {\n          e3(t2);\n        }\n        return t2.schedule(), t2.getDisposer();\n      }\n      on.bound = function(e3, n2, t2, r2) {\n        return true === r2 ? (un(e3, n2, t2.value), null) : t2 ? { configurable: true, enumerable: false, get: function() {\n          return un(this, n2, t2.value || t2.initializer.call(this)), this[n2];\n        }, set: nn } : { enumerable: false, configurable: true, set: function(e4) {\n          un(this, n2, e4);\n        }, get: function() {\n        } };\n      };\n      var cn = function(e3) {\n        return e3();\n      };\n      function ln(e3) {\n        return e3.scheduler ? e3.scheduler : e3.delay ? function(n2) {\n          return setTimeout(n2, e3.delay);\n        } : cn;\n      }\n      function Nn(e3, n2, t2) {\n        void 0 === t2 && (t2 = o);\n        var r2, M2, a2, u2 = t2.name || \"Reaction@\" + i(), s2 = on(u2, t2.onError ? (r2 = t2.onError, M2 = n2, function() {\n          try {\n            return M2.apply(this, arguments);\n          } catch (e4) {\n            r2.call(this, e4);\n          }\n        }) : n2), c2 = !t2.scheduler && !t2.delay, l2 = ln(t2), N2 = true, D2 = false, g2 = t2.compareStructural ? I.structural : t2.equals || I.default, y2 = new Ve(u2, function() {\n          N2 || c2 ? j2() : D2 || (D2 = true, l2(j2));\n        }, t2.onError, t2.requiresObservable);\n        function j2() {\n          if (D2 = false, !y2.isDisposed) {\n            var n3 = false;\n            y2.track(function() {\n              var t3 = e3(y2);\n              n3 = N2 || !g2(a2, t3), a2 = t3;\n            }), N2 && t2.fireImmediately && s2(a2, y2), N2 || true !== n3 || s2(a2, y2), N2 && (N2 = false);\n          }\n        }\n        return y2.schedule(), y2.getDisposer();\n      }\n      function Dn(e3, n2, t2) {\n        return yn(\"onBecomeObserved\", e3, n2, t2);\n      }\n      function gn(e3, n2, t2) {\n        return yn(\"onBecomeUnobserved\", e3, n2, t2);\n      }\n      function yn(e3, n2, t2, r2) {\n        var o2 = \"function\" == typeof r2 ? bt(n2, t2) : bt(n2), i2 = \"function\" == typeof r2 ? r2 : t2, a2 = e3 + \"Listeners\";\n        return o2[a2] ? o2[a2].add(i2) : o2[a2] = /* @__PURE__ */ new Set([i2]), \"function\" != typeof o2[e3] ? M(false) : function() {\n          var e4 = o2[a2];\n          e4 && (e4.delete(i2), 0 === e4.size && delete o2[a2]);\n        };\n      }\n      function jn(e3) {\n        var n2 = e3.enforceActions, t2 = e3.computedRequiresReaction, r2 = e3.computedConfigurable, o2 = e3.disableErrorBoundaries, i2 = e3.reactionScheduler, a2 = e3.reactionRequiresObservable, u2 = e3.observableRequiresReaction;\n        if (true === e3.isolateGlobalState && ((Ye.pendingReactions.length || Ye.inBatch || Ye.isRunningReactions) && M(\"isolateGlobalState should be called before MobX is running any reactions\"), Ue = true, Se && (0 == --Ce().__mobxInstanceCount && (Ce().__mobxGlobals = void 0), Ye = new be())), void 0 !== n2) {\n          var s2 = void 0;\n          switch (n2) {\n            case true:\n            case \"observed\":\n              s2 = true;\n              break;\n            case false:\n            case \"never\":\n              s2 = false;\n              break;\n            case \"strict\":\n            case \"always\":\n              s2 = \"strict\";\n              break;\n            default:\n              M(\"Invalid value for 'enforceActions': '\" + n2 + \"', expected 'never', 'always' or 'observed'\");\n          }\n          Ye.enforceActions = s2, Ye.allowStateChanges = true !== s2 && \"strict\" !== s2;\n        }\n        void 0 !== t2 && (Ye.computedRequiresReaction = !!t2), void 0 !== a2 && (Ye.reactionRequiresObservable = !!a2), void 0 !== u2 && (Ye.observableRequiresReaction = !!u2, Ye.allowStateReads = !Ye.observableRequiresReaction), void 0 !== r2 && (Ye.computedConfigurable = !!r2), void 0 !== o2 && (true === o2 && console.warn(\"WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.\"), Ye.disableErrorBoundaries = !!o2), i2 && $e(i2);\n      }\n      function zn(e3, n2) {\n        var t2 = \"function\" == typeof e3 ? e3.prototype : e3, r2 = function(e4) {\n          var r3 = n2[e4];\n          Array.isArray(r3) || (r3 = [r3]);\n          var o3 = Object.getOwnPropertyDescriptor(t2, e4), i2 = r3.reduce(function(n3, r4) {\n            return r4(t2, e4, n3);\n          }, o3);\n          i2 && Object.defineProperty(t2, e4, i2);\n        };\n        for (var o2 in n2)\n          r2(o2);\n        return e3;\n      }\n      function Tn(e3, n2, t2, r2) {\n        var o2 = fn(r2 = Z(r2));\n        return U(e3), Ot(e3, r2.name, o2.enhancer), n2 && An(e3, n2, t2, o2), e3;\n      }\n      function fn(e3) {\n        return e3.defaultDecorator || (false === e3.deep ? W : G);\n      }\n      function An(e3, n2, t2, r2) {\n        var o2, i2;\n        Ze();\n        try {\n          var M2 = A(n2);\n          try {\n            for (var a2 = L(M2), u2 = a2.next(); !u2.done; u2 = a2.next()) {\n              var s2 = u2.value, c2 = Object.getOwnPropertyDescriptor(n2, s2);\n              0;\n              var l2 = (t2 && s2 in t2 ? t2[s2] : c2.get ? ee : r2)(e3, s2, c2, true);\n              l2 && Object.defineProperty(e3, s2, l2);\n            }\n          } catch (e4) {\n            o2 = { error: e4 };\n          } finally {\n            try {\n              u2 && !u2.done && (i2 = a2.return) && i2.call(a2);\n            } finally {\n              if (o2)\n                throw o2.error;\n            }\n          }\n        } finally {\n          Ge();\n        }\n      }\n      function dn(e3, n2) {\n        return pn(bt(e3, n2));\n      }\n      function pn(e3) {\n        var n2, t2, r2 = { name: e3.name };\n        return e3.observing && e3.observing.length > 0 && (r2.dependencies = (n2 = e3.observing, t2 = [], n2.forEach(function(e4) {\n          -1 === t2.indexOf(e4) && t2.push(e4);\n        }), t2).map(pn)), r2;\n      }\n      function En(e3, n2) {\n        return wn(bt(e3, n2));\n      }\n      function wn(e3) {\n        var n2 = { name: e3.name };\n        return function(e4) {\n          return e4.observers && e4.observers.size > 0;\n        }(e3) && (n2.observers = Array.from(function(e4) {\n          return e4.observers;\n        }(e3)).map(wn)), n2;\n      }\n      var In = 0;\n      function On() {\n        this.message = \"FLOW_CANCELLED\";\n      }\n      function xn(e3) {\n        return e3 instanceof On;\n      }\n      function Ln(e3) {\n        1 !== arguments.length && M(\"Flow expects 1 argument and cannot be used as decorator\");\n        var n2 = e3.name || \"<unnamed flow>\";\n        return function() {\n          var t2, r2 = this, o2 = arguments, i2 = ++In, M2 = on(n2 + \" - runid: \" + i2 + \" - init\", e3).apply(r2, o2), a2 = void 0, u2 = new Promise(function(e4, r3) {\n            var o3 = 0;\n            function u3(e5) {\n              var t3;\n              a2 = void 0;\n              try {\n                t3 = on(n2 + \" - runid: \" + i2 + \" - yield \" + o3++, M2.next).call(M2, e5);\n              } catch (e6) {\n                return r3(e6);\n              }\n              c2(t3);\n            }\n            function s2(e5) {\n              var t3;\n              a2 = void 0;\n              try {\n                t3 = on(n2 + \" - runid: \" + i2 + \" - yield \" + o3++, M2.throw).call(M2, e5);\n              } catch (e6) {\n                return r3(e6);\n              }\n              c2(t3);\n            }\n            function c2(n3) {\n              if (!n3 || \"function\" != typeof n3.then)\n                return n3.done ? e4(n3.value) : (a2 = Promise.resolve(n3.value)).then(u3, s2);\n              n3.then(c2, r3);\n            }\n            t2 = r3, u3(void 0);\n          });\n          return u2.cancel = on(n2 + \" - runid: \" + i2 + \" - cancel\", function() {\n            try {\n              a2 && hn(a2);\n              var e4 = M2.return(void 0), n3 = Promise.resolve(e4.value);\n              n3.then(s, s), hn(n3), t2(new On());\n            } catch (e5) {\n              t2(e5);\n            }\n          }), u2;\n        };\n      }\n      function hn(e3) {\n        \"function\" == typeof e3.cancel && e3.cancel();\n      }\n      function vn(e3, n2, t2) {\n        var r2;\n        if (dt(e3) || zt(e3) || Le(e3))\n          r2 = kt(e3);\n        else {\n          if (!mt(e3))\n            return M(false);\n          if (\"string\" != typeof n2)\n            return M(false);\n          r2 = kt(e3, n2);\n        }\n        return void 0 !== r2.dehancer ? M(false) : (r2.dehancer = \"function\" == typeof n2 ? n2 : t2, function() {\n          r2.dehancer = void 0;\n        });\n      }\n      function mn(e3, n2, t2) {\n        return \"function\" == typeof t2 ? function(e4, n3, t3) {\n          return kt(e4, n3).intercept(t3);\n        }(e3, n2, t2) : function(e4, n3) {\n          return kt(e4).intercept(n3);\n        }(e3, n2);\n      }\n      function bn(e3, n2) {\n        if (null == e3)\n          return false;\n        if (void 0 !== n2) {\n          if (false === mt(e3))\n            return false;\n          if (!e3[d].values.has(n2))\n            return false;\n          var t2 = bt(e3, n2);\n          return ve(t2);\n        }\n        return ve(e3);\n      }\n      function kn(e3) {\n        return arguments.length > 1 ? M(false) : bn(e3);\n      }\n      function Cn(e3, n2) {\n        return \"string\" != typeof n2 ? M(false) : bn(e3, n2);\n      }\n      function Sn(e3, n2) {\n        return null != e3 && (void 0 !== n2 ? !!mt(e3) && e3[d].values.has(n2) : mt(e3) || !!e3[d] || E(e3) || Ke(e3) || ve(e3));\n      }\n      function Un(e3) {\n        return 1 !== arguments.length && M(false), Sn(e3);\n      }\n      function Yn(e3, n2) {\n        return \"string\" != typeof n2 ? M(false) : Sn(e3, n2);\n      }\n      function Qn(e3) {\n        return mt(e3) ? e3[d].getKeys() : dt(e3) || wt(e3) ? Array.from(e3.keys()) : zt(e3) ? e3.map(function(e4, n2) {\n          return n2;\n        }) : M(false);\n      }\n      function _n(e3) {\n        return mt(e3) ? Qn(e3).map(function(n2) {\n          return e3[n2];\n        }) : dt(e3) ? Qn(e3).map(function(n2) {\n          return e3.get(n2);\n        }) : wt(e3) ? Array.from(e3.values()) : zt(e3) ? e3.slice() : M(false);\n      }\n      function Bn(e3) {\n        return mt(e3) ? Qn(e3).map(function(n2) {\n          return [n2, e3[n2]];\n        }) : dt(e3) ? Qn(e3).map(function(n2) {\n          return [n2, e3.get(n2)];\n        }) : wt(e3) ? Array.from(e3.entries()) : zt(e3) ? e3.map(function(e4, n2) {\n          return [n2, e4];\n        }) : M(false);\n      }\n      function Pn(e3, n2, t2) {\n        if (2 !== arguments.length || wt(e3))\n          if (mt(e3)) {\n            var r2 = e3[d], o2 = r2.values.get(n2);\n            o2 ? r2.write(n2, t2) : r2.addObservableProp(n2, t2, r2.defaultEnhancer);\n          } else if (dt(e3))\n            e3.set(n2, t2);\n          else if (wt(e3))\n            e3.add(n2);\n          else {\n            if (!zt(e3))\n              return M(false);\n            \"number\" != typeof n2 && (n2 = parseInt(n2, 10)), a(n2 >= 0, \"Not a valid index: '\" + n2 + \"'\"), Ze(), n2 >= e3.length && (e3.length = n2 + 1), e3[n2] = t2, Ge();\n          }\n        else {\n          Ze();\n          var i2 = n2;\n          try {\n            for (var u2 in i2)\n              Pn(e3, u2, i2[u2]);\n          } finally {\n            Ge();\n          }\n        }\n      }\n      function Rn(e3, n2) {\n        if (mt(e3))\n          e3[d].remove(n2);\n        else if (dt(e3))\n          e3.delete(n2);\n        else if (wt(e3))\n          e3.delete(n2);\n        else {\n          if (!zt(e3))\n            return M(false);\n          \"number\" != typeof n2 && (n2 = parseInt(n2, 10)), a(n2 >= 0, \"Not a valid index: '\" + n2 + \"'\"), e3.splice(n2, 1);\n        }\n      }\n      function Zn(e3, n2) {\n        return mt(e3) ? kt(e3).has(n2) : dt(e3) || wt(e3) ? e3.has(n2) : zt(e3) ? n2 >= 0 && n2 < e3.length : M(false);\n      }\n      function Gn(e3, n2) {\n        if (Zn(e3, n2))\n          return mt(e3) ? e3[n2] : dt(e3) ? e3.get(n2) : zt(e3) ? e3[n2] : M(false);\n      }\n      function Hn(e3, n2, t2, r2) {\n        return \"function\" == typeof t2 ? function(e4, n3, t3, r3) {\n          return kt(e4, n3).observe(t3, r3);\n        }(e3, n2, t2, r2) : function(e4, n3, t3) {\n          return kt(e4).observe(n3, t3);\n        }(e3, n2, t2);\n      }\n      On.prototype = Object.create(Error.prototype);\n      var Wn = { detectCycles: true, exportMapsAsObjects: true, recurseEverything: false };\n      function Vn(e3, n2, t2, r2) {\n        return r2.detectCycles && e3.set(n2, t2), t2;\n      }\n      function Jn(e3, n2) {\n        var t2;\n        return \"boolean\" == typeof n2 && (n2 = { detectCycles: n2 }), n2 || (n2 = Wn), n2.detectCycles = void 0 === n2.detectCycles ? true === n2.recurseEverything : true === n2.detectCycles, n2.detectCycles && (t2 = /* @__PURE__ */ new Map()), function e4(n3, t3, r2) {\n          if (!t3.recurseEverything && !Un(n3))\n            return n3;\n          if (\"object\" != typeof n3)\n            return n3;\n          if (null === n3)\n            return null;\n          if (n3 instanceof Date)\n            return n3;\n          if (Le(n3))\n            return e4(n3.get(), t3, r2);\n          if (Un(n3) && Qn(n3), true === t3.detectCycles && null !== n3 && r2.has(n3))\n            return r2.get(n3);\n          if (zt(n3) || Array.isArray(n3)) {\n            var o2 = Vn(r2, n3, [], t3), i2 = n3.map(function(n4) {\n              return e4(n4, t3, r2);\n            });\n            o2.length = i2.length;\n            for (var M2 = 0, a2 = i2.length; M2 < a2; M2++)\n              o2[M2] = i2[M2];\n            return o2;\n          }\n          if (wt(n3) || Object.getPrototypeOf(n3) === Set.prototype) {\n            if (false === t3.exportMapsAsObjects) {\n              var u2 = Vn(r2, n3, /* @__PURE__ */ new Set(), t3);\n              return n3.forEach(function(n4) {\n                u2.add(e4(n4, t3, r2));\n              }), u2;\n            }\n            var s2 = Vn(r2, n3, [], t3);\n            return n3.forEach(function(n4) {\n              s2.push(e4(n4, t3, r2));\n            }), s2;\n          }\n          if (dt(n3) || Object.getPrototypeOf(n3) === Map.prototype) {\n            if (false === t3.exportMapsAsObjects) {\n              var c2 = Vn(r2, n3, /* @__PURE__ */ new Map(), t3);\n              return n3.forEach(function(n4, o3) {\n                c2.set(o3, e4(n4, t3, r2));\n              }), c2;\n            }\n            var l2 = Vn(r2, n3, {}, t3);\n            return n3.forEach(function(n4, o3) {\n              l2[o3] = e4(n4, t3, r2);\n            }), l2;\n          }\n          var N2 = Vn(r2, n3, {}, t3);\n          return z(n3).forEach(function(o3) {\n            N2[o3] = e4(n3[o3], t3, r2);\n          }), N2;\n        }(e3, n2, t2);\n      }\n      function Fn() {\n        for (var e3 = [], n2 = 0; n2 < arguments.length; n2++)\n          e3[n2] = arguments[n2];\n        var t2 = false;\n        \"boolean\" == typeof e3[e3.length - 1] && (t2 = e3.pop());\n        var r2 = qn(e3);\n        if (!r2)\n          return M(false);\n        r2.isTracing === $.NONE && console.log(\"[mobx.trace] '\" + r2.name + \"' tracing enabled\"), r2.isTracing = t2 ? $.BREAK : $.LOG;\n      }\n      function qn(e3) {\n        switch (e3.length) {\n          case 0:\n            return Ye.trackingDerivation;\n          case 1:\n            return bt(e3[0]);\n          case 2:\n            return bt(e3[0], e3[1]);\n        }\n      }\n      function Xn(e3, n2) {\n        void 0 === n2 && (n2 = void 0), Ze();\n        try {\n          return e3.apply(n2);\n        } finally {\n          Ge();\n        }\n      }\n      function Kn(e3, n2, t2) {\n        return 1 === arguments.length || n2 && \"object\" == typeof n2 ? et(e3, n2) : $n(e3, n2, t2 || {});\n      }\n      function $n(e3, n2, t2) {\n        var r2;\n        \"number\" == typeof t2.timeout && (r2 = setTimeout(function() {\n          if (!M2[d].isDisposed) {\n            M2();\n            var e4 = new Error(\"WHEN_TIMEOUT\");\n            if (!t2.onError)\n              throw e4;\n            t2.onError(e4);\n          }\n        }, t2.timeout)), t2.name = t2.name || \"When@\" + i();\n        var o2 = fe(t2.name + \"-effect\", n2), M2 = sn(function(n3) {\n          e3() && (n3.dispose(), r2 && clearTimeout(r2), o2());\n        }, t2);\n        return M2;\n      }\n      function et(e3, n2) {\n        var t2;\n        var r2 = new Promise(function(r3, o2) {\n          var i2 = $n(e3, r3, x(x({}, n2), { onError: o2 }));\n          t2 = function() {\n            i2(), o2(\"WHEN_CANCELLED\");\n          };\n        });\n        return r2.cancel = t2, r2;\n      }\n      function nt(e3) {\n        return e3[d];\n      }\n      function tt(e3) {\n        return \"string\" == typeof e3 || \"number\" == typeof e3 || \"symbol\" == typeof e3;\n      }\n      var rt = { has: function(e3, n2) {\n        if (n2 === d || \"constructor\" === n2 || n2 === m)\n          return true;\n        var t2 = nt(e3);\n        return tt(n2) ? t2.has(n2) : n2 in e3;\n      }, get: function(e3, n2) {\n        if (n2 === d || \"constructor\" === n2 || n2 === m)\n          return e3[n2];\n        var t2 = nt(e3), r2 = t2.values.get(n2);\n        if (r2 instanceof p) {\n          var o2 = r2.get();\n          return void 0 === o2 && t2.has(n2), o2;\n        }\n        return tt(n2) && t2.has(n2), e3[n2];\n      }, set: function(e3, n2, t2) {\n        return !!tt(n2) && (Pn(e3, n2, t2), true);\n      }, deleteProperty: function(e3, n2) {\n        return !!tt(n2) && (nt(e3).remove(n2), true);\n      }, ownKeys: function(e3) {\n        return nt(e3).keysAtom.reportObserved(), Reflect.ownKeys(e3);\n      }, preventExtensions: function(e3) {\n        return M(\"Dynamic observable objects cannot be frozen\"), false;\n      } };\n      function ot(e3) {\n        var n2 = new Proxy(e3, rt);\n        return e3[d].proxy = n2, n2;\n      }\n      function it(e3) {\n        return void 0 !== e3.interceptors && e3.interceptors.length > 0;\n      }\n      function Mt(e3, n2) {\n        var t2 = e3.interceptors || (e3.interceptors = []);\n        return t2.push(n2), u(function() {\n          var e4 = t2.indexOf(n2);\n          -1 !== e4 && t2.splice(e4, 1);\n        });\n      }\n      function at(e3, n2) {\n        var t2 = le();\n        try {\n          for (var r2 = v(e3.interceptors || []), o2 = 0, i2 = r2.length; o2 < i2 && (a(!(n2 = r2[o2](n2)) || n2.type, \"Intercept handlers should return nothing or a change object\"), n2); o2++)\n            ;\n          return n2;\n        } finally {\n          Ne(t2);\n        }\n      }\n      function ut(e3) {\n        return void 0 !== e3.changeListeners && e3.changeListeners.length > 0;\n      }\n      function st(e3, n2) {\n        var t2 = e3.changeListeners || (e3.changeListeners = []);\n        return t2.push(n2), u(function() {\n          var e4 = t2.indexOf(n2);\n          -1 !== e4 && t2.splice(e4, 1);\n        });\n      }\n      function ct(e3, n2) {\n        var t2 = le(), r2 = e3.changeListeners;\n        if (r2) {\n          for (var o2 = 0, i2 = (r2 = r2.slice()).length; o2 < i2; o2++)\n            r2[o2](n2);\n          Ne(t2);\n        }\n      }\n      var lt = { get: function(e3, n2) {\n        return n2 === d ? e3[d] : \"length\" === n2 ? e3[d].getArrayLength() : \"number\" == typeof n2 ? gt.get.call(e3, n2) : \"string\" != typeof n2 || isNaN(n2) ? gt.hasOwnProperty(n2) ? gt[n2] : e3[n2] : gt.get.call(e3, parseInt(n2));\n      }, set: function(e3, n2, t2) {\n        return \"length\" === n2 && e3[d].setArrayLength(t2), \"number\" == typeof n2 && gt.set.call(e3, n2, t2), \"symbol\" == typeof n2 || isNaN(n2) ? e3[n2] = t2 : gt.set.call(e3, parseInt(n2), t2), true;\n      }, preventExtensions: function(e3) {\n        return M(\"Observable arrays cannot be frozen\"), false;\n      } };\n      function Nt(e3, n2, t2, r2) {\n        void 0 === t2 && (t2 = \"ObservableArray@\" + i()), void 0 === r2 && (r2 = false);\n        var o2, M2, a2, u2 = new Dt(t2, n2, r2);\n        o2 = u2.values, M2 = d, a2 = u2, Object.defineProperty(o2, M2, { enumerable: false, writable: false, configurable: true, value: a2 });\n        var s2 = new Proxy(u2.values, lt);\n        if (u2.proxy = s2, e3 && e3.length) {\n          var c2 = we(true);\n          u2.spliceWithArray(0, 0, e3), Ie(c2);\n        }\n        return s2;\n      }\n      var Dt = function() {\n        function e3(e4, n2, t2) {\n          this.owned = t2, this.values = [], this.proxy = void 0, this.lastKnownLength = 0, this.atom = new p(e4 || \"ObservableArray@\" + i()), this.enhancer = function(t3, r2) {\n            return n2(t3, r2, e4 + \"[..]\");\n          };\n        }\n        return e3.prototype.dehanceValue = function(e4) {\n          return void 0 !== this.dehancer ? this.dehancer(e4) : e4;\n        }, e3.prototype.dehanceValues = function(e4) {\n          return void 0 !== this.dehancer && e4.length > 0 ? e4.map(this.dehancer) : e4;\n        }, e3.prototype.intercept = function(e4) {\n          return Mt(this, e4);\n        }, e3.prototype.observe = function(e4, n2) {\n          return void 0 === n2 && (n2 = false), n2 && e4({ object: this.proxy, type: \"splice\", index: 0, added: this.values.slice(), addedCount: this.values.length, removed: [], removedCount: 0 }), st(this, e4);\n        }, e3.prototype.getArrayLength = function() {\n          return this.atom.reportObserved(), this.values.length;\n        }, e3.prototype.setArrayLength = function(e4) {\n          if (\"number\" != typeof e4 || e4 < 0)\n            throw new Error(\"[mobx.array] Out of range: \" + e4);\n          var n2 = this.values.length;\n          if (e4 !== n2)\n            if (e4 > n2) {\n              for (var t2 = new Array(e4 - n2), r2 = 0; r2 < e4 - n2; r2++)\n                t2[r2] = void 0;\n              this.spliceWithArray(n2, 0, t2);\n            } else\n              this.spliceWithArray(e4, n2 - e4);\n        }, e3.prototype.updateArrayLength = function(e4, n2) {\n          if (e4 !== this.lastKnownLength)\n            throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed.\");\n          this.lastKnownLength += n2;\n        }, e3.prototype.spliceWithArray = function(e4, n2, t2) {\n          var o2 = this;\n          ae(this.atom);\n          var i2 = this.values.length;\n          if (void 0 === e4 ? e4 = 0 : e4 > i2 ? e4 = i2 : e4 < 0 && (e4 = Math.max(0, i2 + e4)), n2 = 1 === arguments.length ? i2 - e4 : null == n2 ? 0 : Math.max(0, Math.min(n2, i2 - e4)), void 0 === t2 && (t2 = r), it(this)) {\n            var M2 = at(this, { object: this.proxy, type: \"splice\", index: e4, removedCount: n2, added: t2 });\n            if (!M2)\n              return r;\n            n2 = M2.removedCount, t2 = M2.added;\n          }\n          t2 = 0 === t2.length ? t2 : t2.map(function(e5) {\n            return o2.enhancer(e5, void 0);\n          });\n          var a2 = this.spliceItemsIntoValues(e4, n2, t2);\n          return 0 === n2 && 0 === t2.length || this.notifyArraySplice(e4, t2, a2), this.dehanceValues(a2);\n        }, e3.prototype.spliceItemsIntoValues = function(e4, n2, t2) {\n          var r2;\n          if (t2.length < 1e4)\n            return (r2 = this.values).splice.apply(r2, v([e4, n2], t2));\n          var o2 = this.values.slice(e4, e4 + n2);\n          return this.values = this.values.slice(0, e4).concat(t2, this.values.slice(e4 + n2)), o2;\n        }, e3.prototype.notifyArrayChildUpdate = function(e4, n2, t2) {\n          var r2 = !this.owned && false, o2 = ut(this), i2 = o2 || r2 ? { object: this.proxy, type: \"update\", index: e4, newValue: n2, oldValue: t2 } : null;\n          this.atom.reportChanged(), o2 && ct(this, i2);\n        }, e3.prototype.notifyArraySplice = function(e4, n2, t2) {\n          var r2 = !this.owned && false, o2 = ut(this), i2 = o2 || r2 ? { object: this.proxy, type: \"splice\", index: e4, removed: t2, added: n2, removedCount: t2.length, addedCount: n2.length } : null;\n          this.atom.reportChanged(), o2 && ct(this, i2);\n        }, e3;\n      }(), gt = { intercept: function(e3) {\n        return this[d].intercept(e3);\n      }, observe: function(e3, n2) {\n        return void 0 === n2 && (n2 = false), this[d].observe(e3, n2);\n      }, clear: function() {\n        return this.splice(0);\n      }, replace: function(e3) {\n        var n2 = this[d];\n        return n2.spliceWithArray(0, n2.values.length, e3);\n      }, toJS: function() {\n        return this.slice();\n      }, toJSON: function() {\n        return this.toJS();\n      }, splice: function(e3, n2) {\n        for (var t2 = [], r2 = 2; r2 < arguments.length; r2++)\n          t2[r2 - 2] = arguments[r2];\n        var o2 = this[d];\n        switch (arguments.length) {\n          case 0:\n            return [];\n          case 1:\n            return o2.spliceWithArray(e3);\n          case 2:\n            return o2.spliceWithArray(e3, n2);\n        }\n        return o2.spliceWithArray(e3, n2, t2);\n      }, spliceWithArray: function(e3, n2, t2) {\n        return this[d].spliceWithArray(e3, n2, t2);\n      }, push: function() {\n        for (var e3 = [], n2 = 0; n2 < arguments.length; n2++)\n          e3[n2] = arguments[n2];\n        var t2 = this[d];\n        return t2.spliceWithArray(t2.values.length, 0, e3), t2.values.length;\n      }, pop: function() {\n        return this.splice(Math.max(this[d].values.length - 1, 0), 1)[0];\n      }, shift: function() {\n        return this.splice(0, 1)[0];\n      }, unshift: function() {\n        for (var e3 = [], n2 = 0; n2 < arguments.length; n2++)\n          e3[n2] = arguments[n2];\n        var t2 = this[d];\n        return t2.spliceWithArray(0, 0, e3), t2.values.length;\n      }, reverse: function() {\n        var e3 = this.slice();\n        return e3.reverse.apply(e3, arguments);\n      }, sort: function(e3) {\n        var n2 = this.slice();\n        return n2.sort.apply(n2, arguments);\n      }, remove: function(e3) {\n        var n2 = this[d], t2 = n2.dehanceValues(n2.values).indexOf(e3);\n        return t2 > -1 && (this.splice(t2, 1), true);\n      }, get: function(e3) {\n        var n2 = this[d];\n        if (n2) {\n          if (e3 < n2.values.length)\n            return n2.atom.reportObserved(), n2.dehanceValue(n2.values[e3]);\n          console.warn(\"[mobx.array] Attempt to read an array index (\" + e3 + \") that is out of bounds (\" + n2.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n      }, set: function(e3, n2) {\n        var t2 = this[d], r2 = t2.values;\n        if (e3 < r2.length) {\n          ae(t2.atom);\n          var o2 = r2[e3];\n          if (it(t2)) {\n            var i2 = at(t2, { type: \"update\", object: t2.proxy, index: e3, newValue: n2 });\n            if (!i2)\n              return;\n            n2 = i2.newValue;\n          }\n          (n2 = t2.enhancer(n2, o2)) !== o2 && (r2[e3] = n2, t2.notifyArrayChildUpdate(e3, n2, o2));\n        } else {\n          if (e3 !== r2.length)\n            throw new Error(\"[mobx.array] Index out of bounds, \" + e3 + \" is larger than \" + r2.length);\n          t2.spliceWithArray(e3, 0, [n2]);\n        }\n      } };\n      [\"concat\", \"flat\", \"includes\", \"indexOf\", \"join\", \"lastIndexOf\", \"slice\", \"toString\", \"toLocaleString\"].forEach(function(e3) {\n        \"function\" == typeof Array.prototype[e3] && (gt[e3] = function() {\n          var n2 = this[d];\n          n2.atom.reportObserved();\n          var t2 = n2.dehanceValues(n2.values);\n          return t2[e3].apply(t2, arguments);\n        });\n      }), [\"every\", \"filter\", \"find\", \"findIndex\", \"flatMap\", \"forEach\", \"map\", \"some\"].forEach(function(e3) {\n        \"function\" == typeof Array.prototype[e3] && (gt[e3] = function(n2, t2) {\n          var r2 = this, o2 = this[d];\n          return o2.atom.reportObserved(), o2.dehanceValues(o2.values)[e3](function(e4, o3) {\n            return n2.call(t2, e4, o3, r2);\n          }, t2);\n        });\n      }), [\"reduce\", \"reduceRight\"].forEach(function(e3) {\n        gt[e3] = function() {\n          var n2 = this, t2 = this[d];\n          t2.atom.reportObserved();\n          var r2 = arguments[0];\n          return arguments[0] = function(e4, o2, i2) {\n            return o2 = t2.dehanceValue(o2), r2(e4, o2, i2, n2);\n          }, t2.values[e3].apply(t2.values, arguments);\n        };\n      });\n      var yt, jt = D(\"ObservableArrayAdministration\", Dt);\n      function zt(e3) {\n        return c(e3) && jt(e3[d]);\n      }\n      var Tt, ft = {}, At = function() {\n        function e3(e4, n2, t2) {\n          if (void 0 === n2 && (n2 = _), void 0 === t2 && (t2 = \"ObservableMap@\" + i()), this.enhancer = n2, this.name = t2, this[yt] = ft, this._keysAtom = w(this.name + \".keys()\"), this[Symbol.toStringTag] = \"Map\", \"function\" != typeof Map)\n            throw new Error(\"mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js\");\n          this._data = /* @__PURE__ */ new Map(), this._hasMap = /* @__PURE__ */ new Map(), this.merge(e4);\n        }\n        return e3.prototype._has = function(e4) {\n          return this._data.has(e4);\n        }, e3.prototype.has = function(e4) {\n          var n2 = this;\n          if (!Ye.trackingDerivation)\n            return this._has(e4);\n          var t2 = this._hasMap.get(e4);\n          if (!t2) {\n            var r2 = t2 = new xe(this._has(e4), B, this.name + \".\" + T(e4) + \"?\", false);\n            this._hasMap.set(e4, r2), gn(r2, function() {\n              return n2._hasMap.delete(e4);\n            });\n          }\n          return t2.get();\n        }, e3.prototype.set = function(e4, n2) {\n          var t2 = this._has(e4);\n          if (it(this)) {\n            var r2 = at(this, { type: t2 ? \"update\" : \"add\", object: this, newValue: n2, name: e4 });\n            if (!r2)\n              return this;\n            n2 = r2.newValue;\n          }\n          return t2 ? this._updateValue(e4, n2) : this._addValue(e4, n2), this;\n        }, e3.prototype.delete = function(e4) {\n          var n2 = this;\n          if ((ae(this._keysAtom), it(this)) && !(r2 = at(this, { type: \"delete\", object: this, name: e4 })))\n            return false;\n          if (this._has(e4)) {\n            var t2 = ut(this), r2 = t2 ? { type: \"delete\", object: this, oldValue: this._data.get(e4).value, name: e4 } : null;\n            return Xn(function() {\n              n2._keysAtom.reportChanged(), n2._updateHasMapEntry(e4, false), n2._data.get(e4).setNewValue(void 0), n2._data.delete(e4);\n            }), t2 && ct(this, r2), true;\n          }\n          return false;\n        }, e3.prototype._updateHasMapEntry = function(e4, n2) {\n          var t2 = this._hasMap.get(e4);\n          t2 && t2.setNewValue(n2);\n        }, e3.prototype._updateValue = function(e4, n2) {\n          var t2 = this._data.get(e4);\n          if ((n2 = t2.prepareNewValue(n2)) !== Ye.UNCHANGED) {\n            var r2 = ut(this), o2 = r2 ? { type: \"update\", object: this, oldValue: t2.value, name: e4, newValue: n2 } : null;\n            0, t2.setNewValue(n2), r2 && ct(this, o2);\n          }\n        }, e3.prototype._addValue = function(e4, n2) {\n          var t2 = this;\n          ae(this._keysAtom), Xn(function() {\n            var r3 = new xe(n2, t2.enhancer, t2.name + \".\" + T(e4), false);\n            t2._data.set(e4, r3), n2 = r3.value, t2._updateHasMapEntry(e4, true), t2._keysAtom.reportChanged();\n          });\n          var r2 = ut(this), o2 = r2 ? { type: \"add\", object: this, name: e4, newValue: n2 } : null;\n          r2 && ct(this, o2);\n        }, e3.prototype.get = function(e4) {\n          return this.has(e4) ? this.dehanceValue(this._data.get(e4).get()) : this.dehanceValue(void 0);\n        }, e3.prototype.dehanceValue = function(e4) {\n          return void 0 !== this.dehancer ? this.dehancer(e4) : e4;\n        }, e3.prototype.keys = function() {\n          return this._keysAtom.reportObserved(), this._data.keys();\n        }, e3.prototype.values = function() {\n          var e4 = this, n2 = this.keys();\n          return _t({ next: function() {\n            var t2 = n2.next(), r2 = t2.done, o2 = t2.value;\n            return { done: r2, value: r2 ? void 0 : e4.get(o2) };\n          } });\n        }, e3.prototype.entries = function() {\n          var e4 = this, n2 = this.keys();\n          return _t({ next: function() {\n            var t2 = n2.next(), r2 = t2.done, o2 = t2.value;\n            return { done: r2, value: r2 ? void 0 : [o2, e4.get(o2)] };\n          } });\n        }, e3.prototype[yt = d, Symbol.iterator] = function() {\n          return this.entries();\n        }, e3.prototype.forEach = function(e4, n2) {\n          var t2, r2;\n          try {\n            for (var o2 = L(this), i2 = o2.next(); !i2.done; i2 = o2.next()) {\n              var M2 = h(i2.value, 2), a2 = M2[0], u2 = M2[1];\n              e4.call(n2, u2, a2, this);\n            }\n          } catch (e5) {\n            t2 = { error: e5 };\n          } finally {\n            try {\n              i2 && !i2.done && (r2 = o2.return) && r2.call(o2);\n            } finally {\n              if (t2)\n                throw t2.error;\n            }\n          }\n        }, e3.prototype.merge = function(e4) {\n          var n2 = this;\n          return dt(e4) && (e4 = e4.toJS()), Xn(function() {\n            var t2 = we(true);\n            try {\n              l(e4) ? z(e4).forEach(function(t3) {\n                return n2.set(t3, e4[t3]);\n              }) : Array.isArray(e4) ? e4.forEach(function(e5) {\n                var t3 = h(e5, 2), r2 = t3[0], o2 = t3[1];\n                return n2.set(r2, o2);\n              }) : y(e4) ? (e4.constructor !== Map && M(\"Cannot initialize from classes that inherit from Map: \" + e4.constructor.name), e4.forEach(function(e5, t3) {\n                return n2.set(t3, e5);\n              })) : null != e4 && M(\"Cannot initialize map from \" + e4);\n            } finally {\n              Ie(t2);\n            }\n          }), this;\n        }, e3.prototype.clear = function() {\n          var e4 = this;\n          Xn(function() {\n            ce(function() {\n              var n2, t2;\n              try {\n                for (var r2 = L(e4.keys()), o2 = r2.next(); !o2.done; o2 = r2.next()) {\n                  var i2 = o2.value;\n                  e4.delete(i2);\n                }\n              } catch (e5) {\n                n2 = { error: e5 };\n              } finally {\n                try {\n                  o2 && !o2.done && (t2 = r2.return) && t2.call(r2);\n                } finally {\n                  if (n2)\n                    throw n2.error;\n                }\n              }\n            });\n          });\n        }, e3.prototype.replace = function(e4) {\n          var n2 = this;\n          return Xn(function() {\n            var t2, r2, o2, i2, a2 = function(e5) {\n              if (y(e5) || dt(e5))\n                return e5;\n              if (Array.isArray(e5))\n                return new Map(e5);\n              if (l(e5)) {\n                var n3 = /* @__PURE__ */ new Map();\n                for (var t3 in e5)\n                  n3.set(t3, e5[t3]);\n                return n3;\n              }\n              return M(\"Cannot convert to map from '\" + e5 + \"'\");\n            }(e4), u2 = /* @__PURE__ */ new Map(), s2 = false;\n            try {\n              for (var c2 = L(n2._data.keys()), N2 = c2.next(); !N2.done; N2 = c2.next()) {\n                var D2 = N2.value;\n                if (!a2.has(D2))\n                  if (n2.delete(D2))\n                    s2 = true;\n                  else {\n                    var g2 = n2._data.get(D2);\n                    u2.set(D2, g2);\n                  }\n              }\n            } catch (e5) {\n              t2 = { error: e5 };\n            } finally {\n              try {\n                N2 && !N2.done && (r2 = c2.return) && r2.call(c2);\n              } finally {\n                if (t2)\n                  throw t2.error;\n              }\n            }\n            try {\n              for (var j2 = L(a2.entries()), z2 = j2.next(); !z2.done; z2 = j2.next()) {\n                var T2 = h(z2.value, 2), f2 = (D2 = T2[0], g2 = T2[1], n2._data.has(D2));\n                if (n2.set(D2, g2), n2._data.has(D2)) {\n                  var A2 = n2._data.get(D2);\n                  u2.set(D2, A2), f2 || (s2 = true);\n                }\n              }\n            } catch (e5) {\n              o2 = { error: e5 };\n            } finally {\n              try {\n                z2 && !z2.done && (i2 = j2.return) && i2.call(j2);\n              } finally {\n                if (o2)\n                  throw o2.error;\n              }\n            }\n            if (!s2)\n              if (n2._data.size !== u2.size)\n                n2._keysAtom.reportChanged();\n              else\n                for (var d2 = n2._data.keys(), p2 = u2.keys(), E2 = d2.next(), w2 = p2.next(); !E2.done; ) {\n                  if (E2.value !== w2.value) {\n                    n2._keysAtom.reportChanged();\n                    break;\n                  }\n                  E2 = d2.next(), w2 = p2.next();\n                }\n            n2._data = u2;\n          }), this;\n        }, Object.defineProperty(e3.prototype, \"size\", { get: function() {\n          return this._keysAtom.reportObserved(), this._data.size;\n        }, enumerable: true, configurable: true }), e3.prototype.toPOJO = function() {\n          var e4, n2, t2 = {};\n          try {\n            for (var r2 = L(this), o2 = r2.next(); !o2.done; o2 = r2.next()) {\n              var i2 = h(o2.value, 2), M2 = i2[0], a2 = i2[1];\n              t2[\"symbol\" == typeof M2 ? M2 : T(M2)] = a2;\n            }\n          } catch (n3) {\n            e4 = { error: n3 };\n          } finally {\n            try {\n              o2 && !o2.done && (n2 = r2.return) && n2.call(r2);\n            } finally {\n              if (e4)\n                throw e4.error;\n            }\n          }\n          return t2;\n        }, e3.prototype.toJS = function() {\n          return new Map(this);\n        }, e3.prototype.toJSON = function() {\n          return this.toPOJO();\n        }, e3.prototype.toString = function() {\n          var e4 = this;\n          return this.name + \"[{ \" + Array.from(this.keys()).map(function(n2) {\n            return T(n2) + \": \" + e4.get(n2);\n          }).join(\", \") + \" }]\";\n        }, e3.prototype.observe = function(e4, n2) {\n          return st(this, e4);\n        }, e3.prototype.intercept = function(e4) {\n          return Mt(this, e4);\n        }, e3;\n      }(), dt = D(\"ObservableMap\", At), pt = {}, Et = function() {\n        function e3(e4, n2, t2) {\n          if (void 0 === n2 && (n2 = _), void 0 === t2 && (t2 = \"ObservableSet@\" + i()), this.name = t2, this[Tt] = pt, this._data = /* @__PURE__ */ new Set(), this._atom = w(this.name), this[Symbol.toStringTag] = \"Set\", \"function\" != typeof Set)\n            throw new Error(\"mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js\");\n          this.enhancer = function(e5, r2) {\n            return n2(e5, r2, t2);\n          }, e4 && this.replace(e4);\n        }\n        return e3.prototype.dehanceValue = function(e4) {\n          return void 0 !== this.dehancer ? this.dehancer(e4) : e4;\n        }, e3.prototype.clear = function() {\n          var e4 = this;\n          Xn(function() {\n            ce(function() {\n              var n2, t2;\n              try {\n                for (var r2 = L(e4._data.values()), o2 = r2.next(); !o2.done; o2 = r2.next()) {\n                  var i2 = o2.value;\n                  e4.delete(i2);\n                }\n              } catch (e5) {\n                n2 = { error: e5 };\n              } finally {\n                try {\n                  o2 && !o2.done && (t2 = r2.return) && t2.call(r2);\n                } finally {\n                  if (n2)\n                    throw n2.error;\n                }\n              }\n            });\n          });\n        }, e3.prototype.forEach = function(e4, n2) {\n          var t2, r2;\n          try {\n            for (var o2 = L(this), i2 = o2.next(); !i2.done; i2 = o2.next()) {\n              var M2 = i2.value;\n              e4.call(n2, M2, M2, this);\n            }\n          } catch (e5) {\n            t2 = { error: e5 };\n          } finally {\n            try {\n              i2 && !i2.done && (r2 = o2.return) && r2.call(o2);\n            } finally {\n              if (t2)\n                throw t2.error;\n            }\n          }\n        }, Object.defineProperty(e3.prototype, \"size\", { get: function() {\n          return this._atom.reportObserved(), this._data.size;\n        }, enumerable: true, configurable: true }), e3.prototype.add = function(e4) {\n          var n2 = this;\n          if ((ae(this._atom), it(this)) && !(r2 = at(this, { type: \"add\", object: this, newValue: e4 })))\n            return this;\n          if (!this.has(e4)) {\n            Xn(function() {\n              n2._data.add(n2.enhancer(e4, void 0)), n2._atom.reportChanged();\n            });\n            var t2 = ut(this), r2 = t2 ? { type: \"add\", object: this, newValue: e4 } : null;\n            0, t2 && ct(this, r2);\n          }\n          return this;\n        }, e3.prototype.delete = function(e4) {\n          var n2 = this;\n          if (it(this) && !(r2 = at(this, { type: \"delete\", object: this, oldValue: e4 })))\n            return false;\n          if (this.has(e4)) {\n            var t2 = ut(this), r2 = t2 ? { type: \"delete\", object: this, oldValue: e4 } : null;\n            return Xn(function() {\n              n2._atom.reportChanged(), n2._data.delete(e4);\n            }), t2 && ct(this, r2), true;\n          }\n          return false;\n        }, e3.prototype.has = function(e4) {\n          return this._atom.reportObserved(), this._data.has(this.dehanceValue(e4));\n        }, e3.prototype.entries = function() {\n          var e4 = 0, n2 = Array.from(this.keys()), t2 = Array.from(this.values());\n          return _t({ next: function() {\n            var r2 = e4;\n            return e4 += 1, r2 < t2.length ? { value: [n2[r2], t2[r2]], done: false } : { done: true };\n          } });\n        }, e3.prototype.keys = function() {\n          return this.values();\n        }, e3.prototype.values = function() {\n          this._atom.reportObserved();\n          var e4 = this, n2 = 0, t2 = Array.from(this._data.values());\n          return _t({ next: function() {\n            return n2 < t2.length ? { value: e4.dehanceValue(t2[n2++]), done: false } : { done: true };\n          } });\n        }, e3.prototype.replace = function(e4) {\n          var n2 = this;\n          return wt(e4) && (e4 = e4.toJS()), Xn(function() {\n            var t2 = we(true);\n            try {\n              Array.isArray(e4) || j(e4) ? (n2.clear(), e4.forEach(function(e5) {\n                return n2.add(e5);\n              })) : null != e4 && M(\"Cannot initialize set from \" + e4);\n            } finally {\n              Ie(t2);\n            }\n          }), this;\n        }, e3.prototype.observe = function(e4, n2) {\n          return st(this, e4);\n        }, e3.prototype.intercept = function(e4) {\n          return Mt(this, e4);\n        }, e3.prototype.toJS = function() {\n          return new Set(this);\n        }, e3.prototype.toString = function() {\n          return this.name + \"[ \" + Array.from(this).join(\", \") + \" ]\";\n        }, e3.prototype[Tt = d, Symbol.iterator] = function() {\n          return this.values();\n        }, e3;\n      }(), wt = D(\"ObservableSet\", Et), It = function() {\n        function e3(e4, n2, t2, r2) {\n          void 0 === n2 && (n2 = /* @__PURE__ */ new Map()), this.target = e4, this.values = n2, this.name = t2, this.defaultEnhancer = r2, this.keysAtom = new p(t2 + \".keys\");\n        }\n        return e3.prototype.read = function(e4) {\n          return this.values.get(e4).get();\n        }, e3.prototype.write = function(e4, n2) {\n          var t2 = this.target, r2 = this.values.get(e4);\n          if (r2 instanceof he)\n            r2.set(n2);\n          else {\n            if (it(this)) {\n              if (!(i2 = at(this, { type: \"update\", object: this.proxy || t2, name: e4, newValue: n2 })))\n                return;\n              n2 = i2.newValue;\n            }\n            if ((n2 = r2.prepareNewValue(n2)) !== Ye.UNCHANGED) {\n              var o2 = ut(this), i2 = o2 ? { type: \"update\", object: this.proxy || t2, oldValue: r2.value, name: e4, newValue: n2 } : null;\n              0, r2.setNewValue(n2), o2 && ct(this, i2);\n            }\n          }\n        }, e3.prototype.has = function(e4) {\n          var n2 = this.pendingKeys || (this.pendingKeys = /* @__PURE__ */ new Map()), t2 = n2.get(e4);\n          if (t2)\n            return t2.get();\n          var r2 = !!this.values.get(e4);\n          return t2 = new xe(r2, B, this.name + \".\" + T(e4) + \"?\", false), n2.set(e4, t2), t2.get();\n        }, e3.prototype.addObservableProp = function(e4, n2, t2) {\n          void 0 === t2 && (t2 = this.defaultEnhancer);\n          var r2 = this.target;\n          if (it(this)) {\n            var o2 = at(this, { object: this.proxy || r2, name: e4, type: \"add\", newValue: n2 });\n            if (!o2)\n              return;\n            n2 = o2.newValue;\n          }\n          var i2 = new xe(n2, t2, this.name + \".\" + T(e4), false);\n          this.values.set(e4, i2), n2 = i2.value, Object.defineProperty(r2, e4, function(e5) {\n            return xt[e5] || (xt[e5] = { configurable: true, enumerable: true, get: function() {\n              return this[d].read(e5);\n            }, set: function(n3) {\n              this[d].write(e5, n3);\n            } });\n          }(e4)), this.notifyPropertyAddition(e4, n2);\n        }, e3.prototype.addComputedProp = function(e4, n2, t2) {\n          var r2, o2, i2, M2 = this.target;\n          t2.name = t2.name || this.name + \".\" + T(n2), this.values.set(n2, new he(t2)), (e4 === M2 || (r2 = e4, o2 = n2, !(i2 = Object.getOwnPropertyDescriptor(r2, o2)) || false !== i2.configurable && false !== i2.writable)) && Object.defineProperty(e4, n2, function(e5) {\n            return Lt[e5] || (Lt[e5] = { configurable: Ye.computedConfigurable, enumerable: false, get: function() {\n              return ht(this).read(e5);\n            }, set: function(n3) {\n              ht(this).write(e5, n3);\n            } });\n          }(n2));\n        }, e3.prototype.remove = function(e4) {\n          if (this.values.has(e4)) {\n            var n2 = this.target;\n            if (it(this)) {\n              if (!(M2 = at(this, { object: this.proxy || n2, name: e4, type: \"remove\" })))\n                return;\n            }\n            try {\n              Ze();\n              var t2 = ut(this), r2 = this.values.get(e4), o2 = r2 && r2.get();\n              if (r2 && r2.set(void 0), this.keysAtom.reportChanged(), this.values.delete(e4), this.pendingKeys) {\n                var i2 = this.pendingKeys.get(e4);\n                i2 && i2.set(false);\n              }\n              delete this.target[e4];\n              var M2 = t2 ? { type: \"remove\", object: this.proxy || n2, oldValue: o2, name: e4 } : null;\n              0, t2 && ct(this, M2);\n            } finally {\n              Ge();\n            }\n          }\n        }, e3.prototype.illegalAccess = function(e4, n2) {\n          console.warn(\"Property '\" + n2 + \"' of '\" + e4 + \"' was accessed through the prototype chain. Use 'decorate' instead to declare the prop or access it statically through it's owner\");\n        }, e3.prototype.observe = function(e4, n2) {\n          return st(this, e4);\n        }, e3.prototype.intercept = function(e4) {\n          return Mt(this, e4);\n        }, e3.prototype.notifyPropertyAddition = function(e4, n2) {\n          var t2 = ut(this), r2 = t2 ? { type: \"add\", object: this.proxy || this.target, name: e4, newValue: n2 } : null;\n          if (t2 && ct(this, r2), this.pendingKeys) {\n            var o2 = this.pendingKeys.get(e4);\n            o2 && o2.set(true);\n          }\n          this.keysAtom.reportChanged();\n        }, e3.prototype.getKeys = function() {\n          var e4, n2;\n          this.keysAtom.reportObserved();\n          var t2 = [];\n          try {\n            for (var r2 = L(this.values), o2 = r2.next(); !o2.done; o2 = r2.next()) {\n              var i2 = h(o2.value, 2), M2 = i2[0];\n              i2[1] instanceof xe && t2.push(M2);\n            }\n          } catch (n3) {\n            e4 = { error: n3 };\n          } finally {\n            try {\n              o2 && !o2.done && (n2 = r2.return) && n2.call(r2);\n            } finally {\n              if (e4)\n                throw e4.error;\n            }\n          }\n          return t2;\n        }, e3;\n      }();\n      function Ot(e3, n2, t2) {\n        if (void 0 === n2 && (n2 = \"\"), void 0 === t2 && (t2 = _), Object.prototype.hasOwnProperty.call(e3, d))\n          return e3[d];\n        l(e3) || (n2 = (e3.constructor.name || \"ObservableObject\") + \"@\" + i()), n2 || (n2 = \"ObservableObject@\" + i());\n        var r2 = new It(e3, /* @__PURE__ */ new Map(), T(n2), t2);\n        return N(e3, d, r2), r2;\n      }\n      var xt = /* @__PURE__ */ Object.create(null), Lt = /* @__PURE__ */ Object.create(null);\n      function ht(e3) {\n        var n2 = e3[d];\n        return n2 || (U(e3), e3[d]);\n      }\n      var vt = D(\"ObservableObjectAdministration\", It);\n      function mt(e3) {\n        return !!c(e3) && (U(e3), vt(e3[d]));\n      }\n      function bt(e3, n2) {\n        if (\"object\" == typeof e3 && null !== e3) {\n          if (zt(e3))\n            return void 0 !== n2 && M(false), e3[d].atom;\n          if (wt(e3))\n            return e3[d];\n          if (dt(e3)) {\n            var t2 = e3;\n            return void 0 === n2 ? t2._keysAtom : ((r2 = t2._data.get(n2) || t2._hasMap.get(n2)) || M(false), r2);\n          }\n          var r2;\n          if (U(e3), n2 && !e3[d] && e3[n2], mt(e3))\n            return n2 ? ((r2 = e3[d].values.get(n2)) || M(false), r2) : M(false);\n          if (E(e3) || ve(e3) || Ke(e3))\n            return e3;\n        } else if (\"function\" == typeof e3 && Ke(e3[d]))\n          return e3[d];\n        return M(false);\n      }\n      function kt(e3, n2) {\n        return e3 || M(\"Expecting some object\"), void 0 !== n2 ? kt(bt(e3, n2)) : E(e3) || ve(e3) || Ke(e3) || dt(e3) || wt(e3) ? e3 : (U(e3), e3[d] ? e3[d] : void M(false));\n      }\n      function Ct(e3, n2) {\n        return (void 0 !== n2 ? bt(e3, n2) : mt(e3) || dt(e3) || wt(e3) ? kt(e3) : bt(e3)).name;\n      }\n      var St = Object.prototype.toString;\n      function Ut(e3, n2, t2) {\n        return void 0 === t2 && (t2 = -1), function e4(n3, t3, r2, o2, i2) {\n          if (n3 === t3)\n            return 0 !== n3 || 1 / n3 == 1 / t3;\n          if (null == n3 || null == t3)\n            return false;\n          if (n3 != n3)\n            return t3 != t3;\n          var M2 = typeof n3;\n          if (\"function\" !== M2 && \"object\" !== M2 && \"object\" != typeof t3)\n            return false;\n          var a2 = St.call(n3);\n          if (a2 !== St.call(t3))\n            return false;\n          switch (a2) {\n            case \"[object RegExp]\":\n            case \"[object String]\":\n              return \"\" + n3 == \"\" + t3;\n            case \"[object Number]\":\n              return +n3 != +n3 ? +t3 != +t3 : 0 == +n3 ? 1 / +n3 == 1 / t3 : +n3 == +t3;\n            case \"[object Date]\":\n            case \"[object Boolean]\":\n              return +n3 == +t3;\n            case \"[object Symbol]\":\n              return \"undefined\" != typeof Symbol && Symbol.valueOf.call(n3) === Symbol.valueOf.call(t3);\n            case \"[object Map]\":\n            case \"[object Set]\":\n              r2 >= 0 && r2++;\n          }\n          n3 = Yt(n3), t3 = Yt(t3);\n          var u2 = \"[object Array]\" === a2;\n          if (!u2) {\n            if (\"object\" != typeof n3 || \"object\" != typeof t3)\n              return false;\n            var s2 = n3.constructor, c2 = t3.constructor;\n            if (s2 !== c2 && !(\"function\" == typeof s2 && s2 instanceof s2 && \"function\" == typeof c2 && c2 instanceof c2) && \"constructor\" in n3 && \"constructor\" in t3)\n              return false;\n          }\n          if (0 === r2)\n            return false;\n          r2 < 0 && (r2 = -1);\n          i2 = i2 || [];\n          var l2 = (o2 = o2 || []).length;\n          for (; l2--; )\n            if (o2[l2] === n3)\n              return i2[l2] === t3;\n          if (o2.push(n3), i2.push(t3), u2) {\n            if ((l2 = n3.length) !== t3.length)\n              return false;\n            for (; l2--; )\n              if (!e4(n3[l2], t3[l2], r2 - 1, o2, i2))\n                return false;\n          } else {\n            var N2 = Object.keys(n3), D2 = void 0;\n            if (l2 = N2.length, Object.keys(t3).length !== l2)\n              return false;\n            for (; l2--; )\n              if (D2 = N2[l2], !Qt(t3, D2) || !e4(n3[D2], t3[D2], r2 - 1, o2, i2))\n                return false;\n          }\n          return o2.pop(), i2.pop(), true;\n        }(e3, n2, t2);\n      }\n      function Yt(e3) {\n        return zt(e3) ? e3.slice() : y(e3) || dt(e3) || j(e3) || wt(e3) ? Array.from(e3.entries()) : e3;\n      }\n      function Qt(e3, n2) {\n        return Object.prototype.hasOwnProperty.call(e3, n2);\n      }\n      function _t(e3) {\n        return e3[Symbol.iterator] = Bt, e3;\n      }\n      function Bt() {\n        return this;\n      }\n      if (\"undefined\" == typeof Proxy || \"undefined\" == typeof Symbol)\n        throw new Error(\"[mobx] MobX 5+ requires Proxy and Symbol objects. If your environment doesn't support Symbol or Proxy objects, please downgrade to MobX 4. For React Native Android, consider upgrading JSCore.\");\n      \"object\" == typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({ spy: en, extras: { getDebugName: Ct }, $mobx: d });\n    }.call(this, t(3));\n  }, function(e, n, t) {\n    \"use strict\";\n    t.r(n), function(e2) {\n      t.d(n, \"observer\", function() {\n        return f;\n      }), t.d(n, \"Observer\", function() {\n        return d;\n      }), t.d(n, \"useStaticRendering\", function() {\n        return g;\n      }), t.d(n, \"connect\", function() {\n        return x;\n      }), t.d(n, \"inject\", function() {\n        return O;\n      }), t.d(n, \"Provider\", function() {\n        return v;\n      });\n      var r = t(0), o = t(1);\n      function i(e3) {\n        return !(e3.prototype && e3.prototype.render || r.Component.isPrototypeOf(e3));\n      }\n      function M(e3) {\n        var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, t2 = n2.prefix, r2 = void 0 === t2 ? \"\" : t2, o2 = n2.suffix, i2 = void 0 === o2 ? \"\" : o2, M2 = e3.displayName || e3.name || e3.constructor && e3.constructor.name || \"<component>\";\n        return r2 + M2 + i2;\n      }\n      var a = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      }, u = function(e3, n2) {\n        if (!(e3 instanceof n2))\n          throw new TypeError(\"Cannot call a class as a function\");\n      }, s = function() {\n        function e3(e4, n2) {\n          for (var t2 = 0; t2 < n2.length; t2++) {\n            var r2 = n2[t2];\n            r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e4, r2.key, r2);\n          }\n        }\n        return function(n2, t2, r2) {\n          return t2 && e3(n2.prototype, t2), r2 && e3(n2, r2), n2;\n        };\n      }(), c = function(e3, n2) {\n        if (\"function\" != typeof n2 && null !== n2)\n          throw new TypeError(\"Super expression must either be null or a function, not \" + typeof n2);\n        e3.prototype = Object.create(n2 && n2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }), n2 && (Object.setPrototypeOf ? Object.setPrototypeOf(e3, n2) : e3.__proto__ = n2);\n      }, l = function(e3, n2) {\n        if (!e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return !n2 || \"object\" != typeof n2 && \"function\" != typeof n2 ? e3 : n2;\n      }, N = false, D = console;\n      function g(e3) {\n        N = e3;\n      }\n      function y(e3, n2, t2, r2, i2) {\n        var M2 = function(e4) {\n          var n3 = Object(o._getGlobalState)().allowStateChanges;\n          return Object(o._getGlobalState)().allowStateChanges = e4, n3;\n        }(e3), a2 = void 0;\n        try {\n          a2 = n2(t2, r2, i2);\n        } finally {\n          !function(e4) {\n            Object(o._getGlobalState)().allowStateChanges = e4;\n          }(M2);\n        }\n        return a2;\n      }\n      function j(e3, n2) {\n        var t2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r2 = e3[n2], o2 = T[n2], i2 = r2 ? true === t2 ? function() {\n          o2.apply(this, arguments), r2.apply(this, arguments);\n        } : function() {\n          r2.apply(this, arguments), o2.apply(this, arguments);\n        } : o2;\n        e3[n2] = i2;\n      }\n      function z(e3, n2) {\n        if (null == e3 || null == n2 || \"object\" !== (void 0 === e3 ? \"undefined\" : a(e3)) || \"object\" !== (void 0 === n2 ? \"undefined\" : a(n2)))\n          return e3 !== n2;\n        var t2 = Object.keys(e3);\n        if (t2.length !== Object.keys(n2).length)\n          return true;\n        for (var r2 = void 0, o2 = t2.length - 1; r2 = t2[o2]; o2--)\n          if (n2[r2] !== e3[r2])\n            return true;\n        return false;\n      }\n      var T = { componentWillMount: function() {\n        var e3 = this;\n        if (true !== N) {\n          var n2 = M(this), t2 = false, i2 = false;\n          l2.call(this, \"props\"), l2.call(this, \"state\");\n          var a2 = this.render.bind(this), u2 = null, s2 = false, c2 = function(e4, n3, t3) {\n            s2 = false;\n            var r2 = void 0, o2 = void 0;\n            if (u2.track(function() {\n              try {\n                o2 = y(false, a2, e4, n3, t3);\n              } catch (e5) {\n                r2 = e5;\n              }\n            }), r2)\n              throw r2;\n            return o2;\n          };\n          this.render = function() {\n            return (u2 = new o.Reaction(n2 + \".render()\", function() {\n              if (!s2 && (s2 = true, \"function\" == typeof e3.componentWillReact && e3.componentWillReact(), true !== e3.__$mobxIsUnmounted)) {\n                var n3 = true;\n                try {\n                  i2 = true, t2 || r.Component.prototype.forceUpdate.call(e3), n3 = false;\n                } finally {\n                  i2 = false, n3 && u2.dispose();\n                }\n              }\n            })).reactComponent = e3, c2.$mobx = u2, e3.render = c2, c2(e3.props, e3.state, e3.context);\n          };\n        }\n        function l2(e4) {\n          var n3 = this[e4], r2 = Object(o.createAtom)(\"reactive \" + e4);\n          Object.defineProperty(this, e4, { configurable: true, enumerable: true, get: function() {\n            return r2.reportObserved(), n3;\n          }, set: function(e5) {\n            !i2 && z(n3, e5) ? (n3 = e5, t2 = true, r2.reportChanged(), t2 = false) : n3 = e5;\n          } });\n        }\n      }, componentWillUnmount: function() {\n        true !== N && (this.render.$mobx && this.render.$mobx.dispose(), this.__$mobxIsUnmounted = true);\n      }, componentDidMount: function() {\n      }, componentDidUpdate: function() {\n      }, shouldComponentUpdate: function(e3, n2) {\n        return N && D.warn(\"[mobx-preact] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side.\"), this.state !== n2 || z(this.props, e3);\n      } };\n      function f(e3) {\n        var n2, t2;\n        if (arguments.length > 1 && D.warn('Mobx observer: Using observer to inject stores is not supported. Use `@connect([\"store1\", \"store2\"]) ComponentClass instead or preferably, use `@inject(\"store1\", \"store2\") @observer ComponentClass` or `inject(\"store1\", \"store2\")(observer(componentClass))``'), true === e3.isMobxInjector && D.warn(\"Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'\"), i(e3))\n          return f((t2 = n2 = function(n3) {\n            function t3() {\n              return u(this, t3), l(this, (t3.__proto__ || Object.getPrototypeOf(t3)).apply(this, arguments));\n            }\n            return c(t3, n3), s(t3, [{ key: \"render\", value: function() {\n              return e3.call(this, this.props, this.context);\n            } }]), t3;\n          }(r.Component), n2.displayName = M(e3), t2));\n        if (!e3)\n          throw new Error(\"Please pass a valid component to 'observer'\");\n        var o2 = e3.prototype || e3;\n        return A(o2), e3.isMobXReactObserver = true, e3;\n      }\n      function A(e3) {\n        j(e3, \"componentWillMount\", true), j(e3, \"componentDidMount\"), e3.shouldComponentUpdate || (e3.shouldComponentUpdate = T.shouldComponentUpdate);\n      }\n      var d = f(function(e3) {\n        return e3.children[0]();\n      });\n      d.displayName = \"Observer\";\n      \"undefined\" != typeof window ? window : void 0 !== e2 || \"undefined\" != typeof self && self;\n      var p = function(e3, n2) {\n        return e3(n2 = { exports: {} }, n2.exports), n2.exports;\n      }(function(e3, n2) {\n        var t2, r2, o2, i2, M2, a2, u2, s2;\n        e3.exports = (t2 = { childContextTypes: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true }, r2 = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true }, o2 = Object.defineProperty, i2 = Object.getOwnPropertyNames, M2 = Object.getOwnPropertySymbols, a2 = Object.getOwnPropertyDescriptor, u2 = Object.getPrototypeOf, s2 = u2 && u2(Object), function e4(n3, c2, l2) {\n          if (\"string\" != typeof c2) {\n            if (s2) {\n              var N2 = u2(c2);\n              N2 && N2 !== s2 && e4(n3, N2, l2);\n            }\n            var D2 = i2(c2);\n            M2 && (D2 = D2.concat(M2(c2)));\n            for (var g2 = 0; g2 < D2.length; ++g2) {\n              var y2 = D2[g2];\n              if (!(t2[y2] || r2[y2] || l2 && l2[y2])) {\n                var j2 = a2(c2, y2);\n                try {\n                  o2(n3, y2, j2);\n                } catch (e5) {\n                }\n              }\n            }\n            return n3;\n          }\n          return n3;\n        });\n      }), E = { isMobxInjector: { value: true, writable: true, configurable: true, enumerable: true } };\n      function w(e3, n2, t2) {\n        var o2, i2, a2 = M(n2, { prefix: \"inject-\", suffix: t2 ? \"-with-\" + t2 : \"\" }), N2 = (i2 = o2 = function(t3) {\n          function o3() {\n            return u(this, o3), l(this, (o3.__proto__ || Object.getPrototypeOf(o3)).apply(this, arguments));\n          }\n          return c(o3, t3), s(o3, [{ key: \"render\", value: function() {\n            var t4 = {};\n            for (var o4 in this.props)\n              this.props.hasOwnProperty(o4) && (t4[o4] = this.props[o4]);\n            var i3 = e3(this.context.mobxStores || {}, t4, this.context) || {};\n            for (var M2 in i3)\n              t4[M2] = i3[M2];\n            return Object(r.h)(n2, t4);\n          } }]), o3;\n        }(r.Component), o2.displayName = a2, i2);\n        return p(N2, n2), N2.wrappedComponent = n2, Object.defineProperties(N2, E), N2;\n      }\n      function I(e3) {\n        return function(n2, t2) {\n          return e3.forEach(function(e4) {\n            if (!(e4 in t2)) {\n              if (!(e4 in n2))\n                throw new Error(\"MobX injector: Store '\" + e4 + \"' is not available! Make sure it is provided by some Provider\");\n              t2[e4] = n2[e4];\n            }\n          }), t2;\n        };\n      }\n      function O() {\n        var e3 = void 0;\n        if (\"function\" == typeof arguments[0])\n          return e3 = arguments[0], function(n3) {\n            var t3 = w(e3, n3);\n            return t3.isMobxInjector = false, (t3 = f(t3)).isMobxInjector = true, t3;\n          };\n        for (var n2 = [], t2 = 0; t2 < arguments.length; t2++)\n          n2[t2] = arguments[t2];\n        return e3 = I(n2), function(t3) {\n          return w(e3, t3, n2.join(\"-\"));\n        };\n      }\n      function x(e3, n2) {\n        if (\"string\" == typeof e3)\n          throw new Error(\"Store names should be provided as array\");\n        return Array.isArray(e3) ? n2 ? O.apply(null, e3)(x(n2)) : function(n3) {\n          return x(e3, n3);\n        } : f(e3);\n      }\n      var L = { children: true, key: true, ref: true }, h = console, v = function(e3) {\n        function n2() {\n          return u(this, n2), l(this, (n2.__proto__ || Object.getPrototypeOf(n2)).apply(this, arguments));\n        }\n        return c(n2, e3), s(n2, [{ key: \"render\", value: function(e4) {\n          var n3 = e4.children;\n          return n3.length > 1 ? Object(r.h)(\"div\", null, \" \", n3, \" \") : n3[0];\n        } }, { key: \"getChildContext\", value: function() {\n          var e4 = {}, n3 = this.context.mobxStores;\n          if (n3)\n            for (var t2 in n3)\n              e4[t2] = n3[t2];\n          for (var r2 in this.props)\n            L[r2] || \"suppressChangedStoreWarning\" === r2 || (e4[r2] = this.props[r2]);\n          return { mobxStores: e4 };\n        } }, { key: \"componentWillReceiveProps\", value: function(e4) {\n          if (Object.keys(e4).length !== Object.keys(this.props).length && h.warn(\"MobX Provider: The set of provided stores has changed. Please avoid changing stores as the change might not propagate to all children\"), !e4.suppressChangedStoreWarning)\n            for (var n3 in e4)\n              L[n3] || this.props[n3] === e4[n3] || h.warn(\"MobX Provider: Provided store '\" + n3 + \"' has changed. Please avoid replacing stores as the change might not propagate to all children\");\n        } }]), n2;\n      }(r.Component);\n      if (!r.Component)\n        throw new Error(\"mobx-preact requires Preact to be available\");\n    }.call(this, t(3));\n  }, function(e, n) {\n    var t;\n    t = function() {\n      return this;\n    }();\n    try {\n      t = t || new Function(\"return this\")();\n    } catch (e2) {\n      \"object\" == typeof window && (t = window);\n    }\n    e.exports = t;\n  }, function(e, n, t) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.JSONHTTPError = n.TextHTTPError = n.HTTPError = n.getPagination = void 0;\n    var r = Object.assign || function(e2) {\n      for (var n2 = 1; n2 < arguments.length; n2++) {\n        var t2 = arguments[n2];\n        for (var r2 in t2)\n          Object.prototype.hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);\n      }\n      return e2;\n    }, o = function() {\n      function e2(e3, n2) {\n        for (var t2 = 0; t2 < n2.length; t2++) {\n          var r2 = n2[t2];\n          r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e3, r2.key, r2);\n        }\n      }\n      return function(n2, t2, r2) {\n        return t2 && e2(n2.prototype, t2), r2 && e2(n2, r2), n2;\n      };\n    }(), i = t(10);\n    function M(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function a(e2, n2) {\n      if (!e2)\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return !n2 || \"object\" != typeof n2 && \"function\" != typeof n2 ? e2 : n2;\n    }\n    function u(e2, n2) {\n      if (\"function\" != typeof n2 && null !== n2)\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof n2);\n      e2.prototype = Object.create(n2 && n2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }), n2 && (Object.setPrototypeOf ? Object.setPrototypeOf(e2, n2) : e2.__proto__ = n2);\n    }\n    Object.defineProperty(n, \"getPagination\", { enumerable: true, get: function() {\n      return i.getPagination;\n    } });\n    var s = n.HTTPError = function(e2) {\n      function n2(e3) {\n        M(this, n2);\n        var t2 = a(this, (n2.__proto__ || Object.getPrototypeOf(n2)).call(this, e3.statusText));\n        return t2.name = t2.constructor.name, \"function\" == typeof Error.captureStackTrace ? Error.captureStackTrace(t2, t2.constructor) : t2.stack = new Error(e3.statusText).stack, t2.status = e3.status, t2;\n      }\n      return u(n2, e2), n2;\n    }(function(e2) {\n      function n2() {\n        var n3 = Reflect.construct(e2, Array.from(arguments));\n        return Object.setPrototypeOf(n3, Object.getPrototypeOf(this)), n3;\n      }\n      return n2.prototype = Object.create(e2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }), Object.setPrototypeOf ? Object.setPrototypeOf(n2, e2) : n2.__proto__ = e2, n2;\n    }(Error)), c = n.TextHTTPError = function(e2) {\n      function n2(e3, t2) {\n        M(this, n2);\n        var r2 = a(this, (n2.__proto__ || Object.getPrototypeOf(n2)).call(this, e3));\n        return r2.data = t2, r2;\n      }\n      return u(n2, e2), n2;\n    }(s), l = n.JSONHTTPError = function(e2) {\n      function n2(e3, t2) {\n        M(this, n2);\n        var r2 = a(this, (n2.__proto__ || Object.getPrototypeOf(n2)).call(this, e3));\n        return r2.json = t2, r2;\n      }\n      return u(n2, e2), n2;\n    }(s), N = function() {\n      function e2() {\n        var n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : \"\", t2 = arguments[1];\n        M(this, e2), this.apiURL = n2, this.apiURL.match(/\\/[^\\/]?/) && (this._sameOrigin = true), this.defaultHeaders = t2 && t2.defaultHeaders || {};\n      }\n      return o(e2, [{ key: \"headers\", value: function() {\n        var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n        return r({}, this.defaultHeaders, { \"Content-Type\": \"application/json\" }, e3);\n      } }, { key: \"parseJsonResponse\", value: function(e3) {\n        return e3.json().then(function(n2) {\n          if (!e3.ok)\n            return Promise.reject(new l(e3, n2));\n          var t2 = (0, i.getPagination)(e3);\n          return t2 ? { pagination: t2, items: n2 } : n2;\n        });\n      } }, { key: \"request\", value: function(e3) {\n        var n2 = this, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, o2 = this.headers(t2.headers || {});\n        return this._sameOrigin && (t2.credentials = t2.credentials || \"same-origin\"), fetch(this.apiURL + e3, r({}, t2, { headers: o2 })).then(function(e4) {\n          var t3 = e4.headers.get(\"Content-Type\");\n          return t3 && t3.match(/json/) ? n2.parseJsonResponse(e4) : e4.ok ? e4.text().then(function(e5) {\n          }) : e4.text().then(function(n3) {\n            return Promise.reject(new c(e4, n3));\n          });\n        });\n      } }]), e2;\n    }();\n    n.default = N;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o = t(0);\n    function i(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function M(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function a(e2, n2) {\n      return (a = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function u(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = c(e2);\n        if (n2) {\n          var o2 = c(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return s(this, t2);\n      };\n    }\n    function s(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function c(e2) {\n      return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var l = function(e2) {\n      !function(e3, n3) {\n        if (\"function\" != typeof n3 && null !== n3)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && a(e3, n3);\n      }(c2, e2);\n      var n2, t2, r2, s2 = u(c2);\n      function c2() {\n        return i(this, c2), s2.apply(this, arguments);\n      }\n      return n2 = c2, (t2 = [{ key: \"render\", value: function() {\n        var e3 = this.props, n3 = e3.saving, t3 = e3.text, r3 = e3.saving_text;\n        return (0, o.h)(\"button\", { type: \"submit\", className: \"btn\".concat(n3 ? \" saving\" : \"\") }, n3 ? r3 || \"Saving\" : t3 || \"Save\");\n      } }]) && M(n2.prototype, t2), r2 && M(n2, r2), c2;\n    }(o.Component);\n    n.default = l;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o = t(0);\n    function i(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function M(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function a(e2, n2) {\n      return (a = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function u(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = c(e2);\n        if (n2) {\n          var o2 = c(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return s(this, t2);\n      };\n    }\n    function s(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function c(e2) {\n      return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var l = { confirm: { type: \"success\", text: \"message_confirm\" }, password_mail: { type: \"success\", text: \"message_password_mail\" }, email_changed: { type: \"sucess\", text: \"message_email_changed\" }, verfication_error: { type: \"error\", text: \"message_verfication_error\" }, signup_disabled: { type: \"error\", text: \"message_signup_disabled\" } }, N = function(e2) {\n      !function(e3, n3) {\n        if (\"function\" != typeof n3 && null !== n3)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && a(e3, n3);\n      }(c2, e2);\n      var n2, t2, r2, s2 = u(c2);\n      function c2() {\n        return i(this, c2), s2.apply(this, arguments);\n      }\n      return n2 = c2, (t2 = [{ key: \"render\", value: function() {\n        var e3 = this.props, n3 = e3.type, t3 = e3.t, r3 = l[n3];\n        return (0, o.h)(\"div\", { className: \"flashMessage \".concat(r3.type) }, (0, o.h)(\"span\", null, t3(r3.text)));\n      } }]) && M(n2.prototype, t2), r2 && M(n2, r2), c2;\n    }(o.Component);\n    n.default = N;\n  }, function(e, n, t) {\n    \"use strict\";\n    e.exports = function(e2) {\n      var n2 = [];\n      return n2.toString = function() {\n        return this.map(function(n3) {\n          var t2 = function(e3, n4) {\n            var t3 = e3[1] || \"\", r = e3[3];\n            if (!r)\n              return t3;\n            if (n4 && \"function\" == typeof btoa) {\n              var o = (M = r, a = btoa(unescape(encodeURIComponent(JSON.stringify(M)))), u = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(a), \"/*# \".concat(u, \" */\")), i = r.sources.map(function(e4) {\n                return \"/*# sourceURL=\".concat(r.sourceRoot || \"\").concat(e4, \" */\");\n              });\n              return [t3].concat(i).concat([o]).join(\"\\n\");\n            }\n            var M, a, u;\n            return [t3].join(\"\\n\");\n          }(n3, e2);\n          return n3[2] ? \"@media \".concat(n3[2], \" {\").concat(t2, \"}\") : t2;\n        }).join(\"\");\n      }, n2.i = function(e3, t2, r) {\n        \"string\" == typeof e3 && (e3 = [[null, e3, \"\"]]);\n        var o = {};\n        if (r)\n          for (var i = 0; i < this.length; i++) {\n            var M = this[i][0];\n            null != M && (o[M] = true);\n          }\n        for (var a = 0; a < e3.length; a++) {\n          var u = [].concat(e3[a]);\n          r && o[u[0]] || (t2 && (u[2] ? u[2] = \"\".concat(t2, \" and \").concat(u[2]) : u[2] = t2), n2.push(u));\n        }\n      }, n2;\n    };\n  }, function(e, n, t) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var r = t(0), o = t(1), i = t(2), M = l(t(9)), a = l(t(13)), u = l(t(19)), s = l(t(29)), c = l(t(30));\n    function l(e2) {\n      return e2 && e2.__esModule ? e2 : { default: e2 };\n    }\n    function N(e2, n2) {\n      return function(e3) {\n        if (Array.isArray(e3))\n          return e3;\n      }(e2) || function(e3, n3) {\n        var t2 = e3 && (\"undefined\" != typeof Symbol && e3[Symbol.iterator] || e3[\"@@iterator\"]);\n        if (null == t2)\n          return;\n        var r2, o2, i2 = [], M2 = true, a2 = false;\n        try {\n          for (t2 = t2.call(e3); !(M2 = (r2 = t2.next()).done) && (i2.push(r2.value), !n3 || i2.length !== n3); M2 = true)\n            ;\n        } catch (e4) {\n          a2 = true, o2 = e4;\n        } finally {\n          try {\n            M2 || null == t2.return || t2.return();\n          } finally {\n            if (a2)\n              throw o2;\n          }\n        }\n        return i2;\n      }(e2, n2) || function(e3, n3) {\n        if (!e3)\n          return;\n        if (\"string\" == typeof e3)\n          return D(e3, n3);\n        var t2 = Object.prototype.toString.call(e3).slice(8, -1);\n        \"Object\" === t2 && e3.constructor && (t2 = e3.constructor.name);\n        if (\"Map\" === t2 || \"Set\" === t2)\n          return Array.from(e3);\n        if (\"Arguments\" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2))\n          return D(e3, n3);\n      }(e2, n2) || function() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }();\n    }\n    function D(e2, n2) {\n      (null == n2 || n2 > e2.length) && (n2 = e2.length);\n      for (var t2 = 0, r2 = new Array(n2); t2 < n2; t2++)\n        r2[t2] = e2[t2];\n      return r2;\n    }\n    function g(e2, n2) {\n      var t2 = Object.keys(e2);\n      if (Object.getOwnPropertySymbols) {\n        var r2 = Object.getOwnPropertySymbols(e2);\n        n2 && (r2 = r2.filter(function(n3) {\n          return Object.getOwnPropertyDescriptor(e2, n3).enumerable;\n        })), t2.push.apply(t2, r2);\n      }\n      return t2;\n    }\n    function y(e2) {\n      for (var n2 = 1; n2 < arguments.length; n2++) {\n        var t2 = null != arguments[n2] ? arguments[n2] : {};\n        n2 % 2 ? g(Object(t2), true).forEach(function(n3) {\n          j(e2, n3, t2[n3]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : g(Object(t2)).forEach(function(n3) {\n          Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t2, n3));\n        });\n      }\n      return e2;\n    }\n    function j(e2, n2, t2) {\n      return n2 in e2 ? Object.defineProperty(e2, n2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[n2] = t2, e2;\n    }\n    var z = {};\n    function T(e2) {\n      var n2 = arguments, t2 = z[e2] || /* @__PURE__ */ new Set();\n      Array.from(t2.values()).forEach(function(e3) {\n        e3.apply(e3, Array.prototype.slice.call(n2, 1));\n      });\n    }\n    var f = { login: true, signup: true, error: true }, A = { on: function(e2, n2) {\n      z[e2] = z[e2] || /* @__PURE__ */ new Set(), z[e2].add(n2);\n    }, off: function(e2, n2) {\n      z[e2] && (n2 ? z[e2].delete(n2) : z[e2].clear());\n    }, open: function(e2) {\n      if (!f[e2 = e2 || \"login\"])\n        throw new Error(\"Invalid action for open: \".concat(e2));\n      u.default.openModal(u.default.user ? \"user\" : e2);\n    }, close: function() {\n      u.default.closeModal();\n    }, currentUser: function() {\n      return u.default.gotrue && u.default.gotrue.currentUser();\n    }, logout: function() {\n      return u.default.logout();\n    }, get gotrue() {\n      return u.default.gotrue || u.default.openModal(\"login\"), u.default.gotrue;\n    }, refresh: function(e2) {\n      return u.default.gotrue || u.default.openModal(\"login\"), u.default.gotrue.currentUser().jwt(e2);\n    }, init: function(e2) {\n      !function() {\n        var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = e3.APIUrl, t2 = e3.logo, o2 = void 0 === t2 || t2, M2 = e3.namePlaceholder, l2 = e3.locale;\n        l2 && (u.default.locale = l2);\n        var N2 = document.querySelectorAll(\"[data-netlify-identity-menu],[data-netlify-identity-button]\");\n        Array.prototype.slice.call(N2).forEach(function(e4) {\n          var n3 = null === e4.getAttribute(\"data-netlify-identity-menu\") ? \"button\" : \"menu\";\n          (0, r.render)((0, r.h)(i.Provider, { store: u.default }, (0, r.h)(s.default, { mode: n3, text: e4.innerText.trim() })), e4, null);\n        }), u.default.init(O(n2)), u.default.modal.logo = o2, u.default.setNamePlaceholder(M2), (w = document.createElement(\"iframe\")).id = \"netlify-identity-widget\", w.title = \"Netlify identity widget\", w.onload = function() {\n          var e4 = w.contentDocument.createElement(\"style\");\n          e4.innerHTML = c.default.toString(), w.contentDocument.head.appendChild(e4), E = (0, r.render)((0, r.h)(i.Provider, { store: u.default }, (0, r.h)(a.default, null)), w.contentDocument.body, E), m();\n        }, p(w, x), w.src = \"about:blank\";\n        var D2 = e3.container ? document.querySelector(e3.container) : document.body;\n        D2.appendChild(w), d && (w.setAttribute(\"style\", d), d = null);\n      }(e2);\n    }, setLocale: function(e2) {\n      e2 && (u.default.locale = e2);\n    }, store: u.default }, d = null;\n    function p(e2, n2) {\n      var t2 = \"\";\n      for (var r2 in n2)\n        t2 += \"\".concat(r2, \": \").concat(n2[r2], \"; \");\n      e2 ? e2.setAttribute(\"style\", t2) : d = t2;\n    }\n    var E, w, I = { localhost: true, \"127.0.0.1\": true, \"0.0.0.0\": true };\n    function O(e2) {\n      var n2 = I[document.location.hostname];\n      if (e2)\n        return new M.default({ APIUrl: e2, setCookie: !n2 });\n      if (n2) {\n        u.default.setIsLocal(n2);\n        var t2 = localStorage.getItem(\"netlifySiteURL\");\n        return t2 && u.default.setSiteURL(t2), null;\n      }\n      return new M.default({ setCookie: !n2 });\n    }\n    var x = { position: \"fixed\", top: 0, left: 0, border: \"none\", width: \"100%\", height: \"100%\", overflow: \"visible\", background: \"transparent\", display: \"none\", \"z-index\": 99 };\n    (0, o.observe)(u.default.modal, \"isOpen\", function() {\n      u.default.settings || u.default.loadSettings(), p(w, y(y({}, x), {}, { display: u.default.modal.isOpen ? \"block !important\" : \"none\" })), u.default.modal.isOpen ? T(\"open\", u.default.modal.page) : T(\"close\");\n    }), (0, o.observe)(u.default, \"siteURL\", function() {\n      var e2;\n      if (null === u.default.siteURL || void 0 === u.default.siteURL ? localStorage.removeItem(\"netlifySiteURL\") : localStorage.setItem(\"netlifySiteURL\", u.default.siteURL), u.default.siteURL) {\n        var n2 = u.default.siteURL.replace(/\\/$/, \"\");\n        e2 = \"\".concat(n2, \"/.netlify/identity\");\n      }\n      u.default.init(O(e2), true);\n    }), (0, o.observe)(u.default, \"user\", function() {\n      u.default.user ? T(\"login\", u.default.user) : T(\"logout\");\n    }), (0, o.observe)(u.default, \"gotrue\", function() {\n      u.default.gotrue && T(\"init\", u.default.gotrue.currentUser());\n    }), (0, o.observe)(u.default, \"error\", function() {\n      T(\"error\", u.default.error);\n    });\n    var L = /(confirmation|invite|recovery|email_change)_token=([^&]+)/, h = /error=access_denied&error_description=403/, v = /access_token=/;\n    function m() {\n      var e2 = (document.location.hash || \"\").replace(/^#\\/?/, \"\");\n      if (e2) {\n        var n2 = e2.match(L);\n        if (n2 && (u.default.verifyToken(n2[1], n2[2]), document.location.hash = \"\"), e2.match(h) && (u.default.openModal(\"signup\"), document.location.hash = \"\"), e2.match(v)) {\n          var t2 = {};\n          if (e2.split(\"&\").forEach(function(e3) {\n            var n3 = N(e3.split(\"=\"), 2), r3 = n3[0], o2 = n3[1];\n            t2[r3] = o2;\n          }), document && t2.access_token && (document.cookie = \"nf_jwt=\".concat(t2.access_token)), t2.state)\n            try {\n              var r2 = decodeURIComponent(t2.state);\n              if (\"implicit\" === JSON.parse(r2).auth_type)\n                return;\n            } catch (e3) {\n            }\n          document.location.hash = \"\", u.default.openModal(\"login\"), u.default.completeExternalLogin(t2);\n        }\n      }\n    }\n    var b = A;\n    n.default = b;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o, i = function(e2) {\n      if (e2 && e2.__esModule)\n        return e2;\n      if (null === e2 || \"object\" !== r(e2) && \"function\" != typeof e2)\n        return { default: e2 };\n      var n2 = a();\n      if (n2 && n2.has(e2))\n        return n2.get(e2);\n      var t2 = {}, o2 = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var i2 in e2)\n        if (Object.prototype.hasOwnProperty.call(e2, i2)) {\n          var M2 = o2 ? Object.getOwnPropertyDescriptor(e2, i2) : null;\n          M2 && (M2.get || M2.set) ? Object.defineProperty(t2, i2, M2) : t2[i2] = e2[i2];\n        }\n      t2.default = e2, n2 && n2.set(e2, t2);\n      return t2;\n    }(t(4)), M = (o = t(11)) && o.__esModule ? o : { default: o };\n    function a() {\n      if (\"function\" != typeof WeakMap)\n        return null;\n      var e2 = /* @__PURE__ */ new WeakMap();\n      return a = function() {\n        return e2;\n      }, e2;\n    }\n    function u(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function s(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    var c = /^http:\\/\\//, l = function() {\n      function e2() {\n        var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t3 = n3.APIUrl, r3 = void 0 === t3 ? \"/.netlify/identity\" : t3, o2 = n3.audience, M2 = void 0 === o2 ? \"\" : o2, a2 = n3.setCookie, s2 = void 0 !== a2 && a2;\n        u(this, e2), r3.match(c) && console.warn(\"Warning:\\n\\nDO NOT USE HTTP IN PRODUCTION FOR GOTRUE EVER!\\nGoTrue REQUIRES HTTPS to work securely.\"), M2 && (this.audience = M2), this.setCookie = s2, this.api = new i.default(r3);\n      }\n      var n2, t2, r2;\n      return n2 = e2, (t2 = [{ key: \"_request\", value: function(e3) {\n        var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        n3.headers = n3.headers || {};\n        var t3 = n3.audience || this.audience;\n        return t3 && (n3.headers[\"X-JWT-AUD\"] = t3), this.api.request(e3, n3).catch(function(e4) {\n          return e4 instanceof i.JSONHTTPError && e4.json && (e4.json.msg ? e4.message = e4.json.msg : e4.json.error && (e4.message = \"\".concat(e4.json.error, \": \").concat(e4.json.error_description))), Promise.reject(e4);\n        });\n      } }, { key: \"settings\", value: function() {\n        return this._request(\"/settings\");\n      } }, { key: \"signup\", value: function(e3, n3, t3) {\n        return this._request(\"/signup\", { method: \"POST\", body: JSON.stringify({ email: e3, password: n3, data: t3 }) });\n      } }, { key: \"login\", value: function(e3, n3, t3) {\n        var r3 = this;\n        return this._setRememberHeaders(t3), this._request(\"/token\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" }, body: \"grant_type=password&username=\".concat(encodeURIComponent(e3), \"&password=\").concat(encodeURIComponent(n3)) }).then(function(e4) {\n          return M.default.removeSavedSession(), r3.createUser(e4, t3);\n        });\n      } }, { key: \"loginExternalUrl\", value: function(e3) {\n        return \"\".concat(this.api.apiURL, \"/authorize?provider=\").concat(e3);\n      } }, { key: \"confirm\", value: function(e3, n3) {\n        return this._setRememberHeaders(n3), this.verify(\"signup\", e3, n3);\n      } }, { key: \"requestPasswordRecovery\", value: function(e3) {\n        return this._request(\"/recover\", { method: \"POST\", body: JSON.stringify({ email: e3 }) });\n      } }, { key: \"recover\", value: function(e3, n3) {\n        return this._setRememberHeaders(n3), this.verify(\"recovery\", e3, n3);\n      } }, { key: \"acceptInvite\", value: function(e3, n3, t3) {\n        var r3 = this;\n        return this._setRememberHeaders(t3), this._request(\"/verify\", { method: \"POST\", body: JSON.stringify({ token: e3, password: n3, type: \"signup\" }) }).then(function(e4) {\n          return r3.createUser(e4, t3);\n        });\n      } }, { key: \"acceptInviteExternalUrl\", value: function(e3, n3) {\n        return \"\".concat(this.api.apiURL, \"/authorize?provider=\").concat(e3, \"&invite_token=\").concat(n3);\n      } }, { key: \"createUser\", value: function(e3) {\n        var n3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        this._setRememberHeaders(n3);\n        var t3 = new M.default(this.api, e3, this.audience);\n        return t3.getUserData().then(function(e4) {\n          return n3 && e4._saveSession(), e4;\n        });\n      } }, { key: \"currentUser\", value: function() {\n        var e3 = M.default.recoverSession(this.api);\n        return e3 && this._setRememberHeaders(e3._fromStorage), e3;\n      } }, { key: \"verify\", value: function(e3, n3, t3) {\n        var r3 = this;\n        return this._setRememberHeaders(t3), this._request(\"/verify\", { method: \"POST\", body: JSON.stringify({ token: n3, type: e3 }) }).then(function(e4) {\n          return r3.createUser(e4, t3);\n        });\n      } }, { key: \"_setRememberHeaders\", value: function(e3) {\n        this.setCookie && (this.api.defaultHeaders = this.api.defaultHeaders || {}, this.api.defaultHeaders[\"X-Use-Cookie\"] = e3 ? \"1\" : \"session\");\n      } }]) && s(n2.prototype, t2), r2 && s(n2, r2), e2;\n    }();\n    n.default = l, \"undefined\" != typeof window && (window.GoTrue = l);\n  }, function(e, n, t) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: true });\n    var r = function(e2, n2) {\n      if (Array.isArray(e2))\n        return e2;\n      if (Symbol.iterator in Object(e2))\n        return function(e3, n3) {\n          var t2 = [], r2 = true, o = false, i = void 0;\n          try {\n            for (var M, a = e3[Symbol.iterator](); !(r2 = (M = a.next()).done) && (t2.push(M.value), !n3 || t2.length !== n3); r2 = true)\n              ;\n          } catch (e4) {\n            o = true, i = e4;\n          } finally {\n            try {\n              !r2 && a.return && a.return();\n            } finally {\n              if (o)\n                throw i;\n            }\n          }\n          return t2;\n        }(e2, n2);\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    };\n    n.getPagination = function(e2) {\n      var n2 = e2.headers.get(\"Link\"), t2 = {};\n      if (null == n2)\n        return null;\n      n2 = n2.split(\",\");\n      for (var o = e2.headers.get(\"X-Total-Count\"), i = 0, M = n2.length; i < M; i++) {\n        var a = n2[i].replace(/(^\\s*|\\s*$)/, \"\").split(\";\"), u = r(a, 2), s = u[0], c = u[1], l = s.match(/page=(\\d+)/), N = l && parseInt(l[1], 10);\n        c.match(/last/) ? t2.last = N : c.match(/next/) ? t2.next = N : c.match(/prev/) ? t2.prev = N : c.match(/first/) && (t2.first = N);\n      }\n      return t2.last = Math.max(t2.last || 0, t2.prev && t2.prev + 1 || 0), t2.current = t2.next ? t2.next - 1 : t2.last || 1, t2.total = o ? parseInt(o, 10) : null, t2;\n    };\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o, i = function(e2) {\n      if (e2 && e2.__esModule)\n        return e2;\n      if (null === e2 || \"object\" !== r(e2) && \"function\" != typeof e2)\n        return { default: e2 };\n      var n2 = a();\n      if (n2 && n2.has(e2))\n        return n2.get(e2);\n      var t2 = {}, o2 = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var i2 in e2)\n        if (Object.prototype.hasOwnProperty.call(e2, i2)) {\n          var M2 = o2 ? Object.getOwnPropertyDescriptor(e2, i2) : null;\n          M2 && (M2.get || M2.set) ? Object.defineProperty(t2, i2, M2) : t2[i2] = e2[i2];\n        }\n      t2.default = e2, n2 && n2.set(e2, t2);\n      return t2;\n    }(t(4)), M = (o = t(12)) && o.__esModule ? o : { default: o };\n    function a() {\n      if (\"function\" != typeof WeakMap)\n        return null;\n      var e2 = /* @__PURE__ */ new WeakMap();\n      return a = function() {\n        return e2;\n      }, e2;\n    }\n    function u(e2, n2) {\n      var t2 = Object.keys(e2);\n      if (Object.getOwnPropertySymbols) {\n        var r2 = Object.getOwnPropertySymbols(e2);\n        n2 && (r2 = r2.filter(function(n3) {\n          return Object.getOwnPropertyDescriptor(e2, n3).enumerable;\n        })), t2.push.apply(t2, r2);\n      }\n      return t2;\n    }\n    function s(e2) {\n      for (var n2 = 1; n2 < arguments.length; n2++) {\n        var t2 = null != arguments[n2] ? arguments[n2] : {};\n        n2 % 2 ? u(Object(t2), true).forEach(function(n3) {\n          c(e2, n3, t2[n3]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : u(Object(t2)).forEach(function(n3) {\n          Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t2, n3));\n        });\n      }\n      return e2;\n    }\n    function c(e2, n2, t2) {\n      return n2 in e2 ? Object.defineProperty(e2, n2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[n2] = t2, e2;\n    }\n    function l(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    var N = {}, D = null, g = { api: 1, token: 1, audience: 1, url: 1 }, y = { api: 1 }, j = function() {\n      return \"undefined\" != typeof window;\n    }, z = function() {\n      function e2(n3, t3, r3) {\n        !function(e3, n4) {\n          if (!(e3 instanceof n4))\n            throw new TypeError(\"Cannot call a class as a function\");\n        }(this, e2), this.api = n3, this.url = n3.apiURL, this.audience = r3, this._processTokenResponse(t3), D = this;\n      }\n      var n2, t2, r2;\n      return n2 = e2, r2 = [{ key: \"removeSavedSession\", value: function() {\n        j() && localStorage.removeItem(\"gotrue.user\");\n      } }, { key: \"recoverSession\", value: function(n3) {\n        if (D)\n          return D;\n        var t3 = j() && localStorage.getItem(\"gotrue.user\");\n        if (t3)\n          try {\n            var r3 = JSON.parse(t3), o2 = r3.url, M2 = r3.token, a2 = r3.audience;\n            return o2 && M2 ? new e2(n3 || new i.default(o2, {}), M2, a2)._saveUserData(r3, true) : null;\n          } catch (e3) {\n            return console.error(new Error(\"Gotrue-js: Error recovering session: \".concat(e3))), null;\n          }\n        return null;\n      } }], (t2 = [{ key: \"update\", value: function(e3) {\n        var n3 = this;\n        return this._request(\"/user\", { method: \"PUT\", body: JSON.stringify(e3) }).then(function(e4) {\n          return n3._saveUserData(e4)._refreshSavedSession();\n        });\n      } }, { key: \"jwt\", value: function(e3) {\n        var n3 = this.tokenDetails();\n        if (null == n3)\n          return Promise.reject(new Error(\"Gotrue-js: failed getting jwt access token\"));\n        var t3 = n3.expires_at, r3 = n3.refresh_token, o2 = n3.access_token;\n        return e3 || t3 - 6e4 < Date.now() ? this._refreshToken(r3) : Promise.resolve(o2);\n      } }, { key: \"logout\", value: function() {\n        return this._request(\"/logout\", { method: \"POST\" }).then(this.clearSession.bind(this)).catch(this.clearSession.bind(this));\n      } }, { key: \"_refreshToken\", value: function(e3) {\n        var n3 = this;\n        return N[e3] ? N[e3] : N[e3] = this.api.request(\"/token\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" }, body: \"grant_type=refresh_token&refresh_token=\".concat(e3) }).then(function(t3) {\n          return delete N[e3], n3._processTokenResponse(t3), n3._refreshSavedSession(), n3.token.access_token;\n        }).catch(function(t3) {\n          return delete N[e3], n3.clearSession(), Promise.reject(t3);\n        });\n      } }, { key: \"_request\", value: function(e3) {\n        var n3 = this, t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        t3.headers = t3.headers || {};\n        var r3 = t3.audience || this.audience;\n        return r3 && (t3.headers[\"X-JWT-AUD\"] = r3), this.jwt().then(function(r4) {\n          return n3.api.request(e3, s({ headers: Object.assign(t3.headers, { Authorization: \"Bearer \".concat(r4) }) }, t3)).catch(function(e4) {\n            return e4 instanceof i.JSONHTTPError && e4.json && (e4.json.msg ? e4.message = e4.json.msg : e4.json.error && (e4.message = \"\".concat(e4.json.error, \": \").concat(e4.json.error_description))), Promise.reject(e4);\n          });\n        });\n      } }, { key: \"getUserData\", value: function() {\n        return this._request(\"/user\").then(this._saveUserData.bind(this)).then(this._refreshSavedSession.bind(this));\n      } }, { key: \"_saveUserData\", value: function(n3, t3) {\n        for (var r3 in n3)\n          r3 in e2.prototype || r3 in g || (this[r3] = n3[r3]);\n        return t3 && (this._fromStorage = true), this;\n      } }, { key: \"_processTokenResponse\", value: function(e3) {\n        this.token = e3;\n        try {\n          var n3 = JSON.parse(function(e4) {\n            var n4 = e4.replace(/-/g, \"+\").replace(/_/g, \"/\");\n            switch (n4.length % 4) {\n              case 0:\n                break;\n              case 2:\n                n4 += \"==\";\n                break;\n              case 3:\n                n4 += \"=\";\n                break;\n              default:\n                throw \"Illegal base64url string!\";\n            }\n            var t3 = window.atob(n4);\n            try {\n              return decodeURIComponent(escape(t3));\n            } catch (e5) {\n              return t3;\n            }\n          }(e3.access_token.split(\".\")[1]));\n          this.token.expires_at = 1e3 * n3.exp;\n        } catch (e4) {\n          console.error(new Error(\"Gotrue-js: Failed to parse tokenResponse claims: \".concat(e4)));\n        }\n      } }, { key: \"_refreshSavedSession\", value: function() {\n        return j() && localStorage.getItem(\"gotrue.user\") && this._saveSession(), this;\n      } }, { key: \"_saveSession\", value: function() {\n        return j() && localStorage.setItem(\"gotrue.user\", JSON.stringify(this._details)), this;\n      } }, { key: \"tokenDetails\", value: function() {\n        return this.token;\n      } }, { key: \"clearSession\", value: function() {\n        e2.removeSavedSession(), this.token = null, D = null;\n      } }, { key: \"admin\", get: function() {\n        return new M.default(this);\n      } }, { key: \"_details\", get: function() {\n        var n3 = {};\n        for (var t3 in this)\n          t3 in e2.prototype || t3 in y || (n3[t3] = this[t3]);\n        return n3;\n      } }]) && l(n2.prototype, t2), r2 && l(n2, r2), e2;\n    }();\n    n.default = z;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o = function() {\n      function e2(n3) {\n        !function(e3, n4) {\n          if (!(e3 instanceof n4))\n            throw new TypeError(\"Cannot call a class as a function\");\n        }(this, e2), this.user = n3;\n      }\n      var n2, t2, o2;\n      return n2 = e2, (t2 = [{ key: \"listUsers\", value: function(e3) {\n        return this.user._request(\"/admin/users\", { method: \"GET\", audience: e3 });\n      } }, { key: \"getUser\", value: function(e3) {\n        return this.user._request(\"/admin/users/\".concat(e3.id));\n      } }, { key: \"updateUser\", value: function(e3) {\n        var n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n        return this.user._request(\"/admin/users/\".concat(e3.id), { method: \"PUT\", body: JSON.stringify(n3) });\n      } }, { key: \"createUser\", value: function(e3, n3) {\n        var t3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n        return t3.email = e3, t3.password = n3, this.user._request(\"/admin/users\", { method: \"POST\", body: JSON.stringify(t3) });\n      } }, { key: \"deleteUser\", value: function(e3) {\n        return this.user._request(\"/admin/users/\".concat(e3.id), { method: \"DELETE\" });\n      } }]) && r(n2.prototype, t2), o2 && r(n2, o2), e2;\n    }();\n    n.default = o;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o, i = t(0), M = t(2), a = D(t(14)), u = D(t(15)), s = D(t(16)), c = D(t(17)), l = D(t(18)), N = D(t(6));\n    function D(e2) {\n      return e2 && e2.__esModule ? e2 : { default: e2 };\n    }\n    function g(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function y(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function j(e2, n2) {\n      return (j = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function z(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = f(e2);\n        if (n2) {\n          var o2 = f(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return T(this, t2);\n      };\n    }\n    function T(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function f(e2) {\n      return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var A = { login: true, signup: true }, d = { login: { login: true, button: \"log_in\", button_saving: \"logging_in\", email: true, password: \"current-password\", link: \"amnesia\", link_text: \"forgot_password\", providers: true }, signup: { signup: true, button: \"sign_up\", button_saving: \"signing_up\", name: true, email: true, password: \"new-password\", providers: true }, amnesia: { title: \"recover_password\", button: \"send_recovery_email\", button_saving: \"sending_recovery_email\", email: true, link: \"login\", link_text: \"never_mind\" }, recovery: { title: \"recover_password\", button: \"update_password\", button_saving: \"updating_password\", password: \"new-password\", link: \"login\", link_text: \"never_mind\" }, invite: { title: \"complete_your_signup\", button: \"sign_up\", button_saving: \"signing_up\", password: \"new-password\", providers: true }, user: { title: \"logged_in\" } }, p = (0, M.connect)([\"store\"])(o = function(e2) {\n      !function(e3, n3) {\n        if (\"function\" != typeof n3 && null !== n3)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && j(e3, n3);\n      }(M2, e2);\n      var n2, t2, r2, o2 = z(M2);\n      function M2() {\n        var e3;\n        g(this, M2);\n        for (var n3 = arguments.length, t3 = new Array(n3), r3 = 0; r3 < n3; r3++)\n          t3[r3] = arguments[r3];\n        return (e3 = o2.call.apply(o2, [this].concat(t3))).handleClose = function() {\n          return e3.props.store.closeModal();\n        }, e3.handlePage = function(n4) {\n          return e3.props.store.openModal(n4);\n        }, e3.handleLogout = function() {\n          return e3.props.store.logout();\n        }, e3.handleSiteURL = function(n4) {\n          return e3.props.store.setSiteURL(n4);\n        }, e3.clearSiteURL = function(n4) {\n          return e3.props.store.clearSiteURL();\n        }, e3.clearStoreError = function() {\n          return e3.props.store.setError();\n        }, e3.handleExternalLogin = function(n4) {\n          return e3.props.store.externalLogin(n4);\n        }, e3.handleUser = function(n4) {\n          var t4 = n4.name, r4 = n4.email, o3 = n4.password, i2 = e3.props.store;\n          switch (i2.modal.page) {\n            case \"login\":\n              i2.login(r4, o3);\n              break;\n            case \"signup\":\n              i2.signup(t4, r4, o3);\n              break;\n            case \"amnesia\":\n              i2.requestPasswordRecovery(r4);\n              break;\n            case \"invite\":\n              i2.acceptInvite(o3);\n              break;\n            case \"recovery\":\n              i2.updatePassword(o3);\n          }\n        }, e3;\n      }\n      return n2 = M2, (t2 = [{ key: \"renderBody\", value: function() {\n        var e3 = this, n3 = this.props.store, t3 = d[n3.modal.page] || {};\n        return n3.isLocal && null === n3.siteURL ? (0, i.h)(u.default, { devMode: null != n3.siteURL, onSiteURL: n3.siteURL ? this.clearSiteURL : this.handleSiteURL, t: n3.translate }) : n3.settings ? n3.user ? (0, i.h)(s.default, { user: n3.user, saving: n3.saving, onLogout: this.handleLogout, t: n3.translate }) : \"signup\" === n3.modal.page && n3.settings.disable_signup ? (0, i.h)(N.default, { type: \"signup_disabled\", t: n3.translate }) : (0, i.h)(\"div\", null, (0, i.h)(c.default, { page: d[n3.modal.page] || {}, message: n3.message, saving: n3.saving, onSubmit: this.handleUser, namePlaceholder: n3.namePlaceholder, t: n3.translate }), !n3.user && t3.link && n3.gotrue && (0, i.h)(\"button\", { onclick: function() {\n          return e3.handlePage(t3.link);\n        }, className: \"btnLink forgotPasswordLink\" }, n3.translate(t3.link_text)), n3.isLocal ? (0, i.h)(u.default, { devMode: null != n3.siteURL, onSiteURL: n3.siteURL ? this.clearSiteURL : this.handleSiteURL, t: n3.translate }) : (0, i.h)(\"div\", null)) : void 0;\n      } }, { key: \"renderProviders\", value: function() {\n        var e3 = this.props.store;\n        if (!e3.gotrue || !e3.settings)\n          return null;\n        if (\"signup\" === e3.modal.page && e3.settings.disable_signup)\n          return null;\n        if (!(d[e3.modal.page] || {}).providers)\n          return null;\n        var n3 = [\"Google\", \"GitHub\", \"GitLab\", \"BitBucket\", \"SAML\"].filter(function(n4) {\n          return e3.settings.external[n4.toLowerCase()];\n        });\n        return n3.length ? (0, i.h)(l.default, { providers: n3, labels: e3.settings.external_labels || {}, onLogin: this.handleExternalLogin, t: e3.translate }) : null;\n      } }, { key: \"render\", value: function() {\n        var e3 = this.props.store, n3 = A[e3.modal.page], t3 = e3.settings && !e3.settings.disable_signup, r3 = d[e3.modal.page] || {};\n        return (0, i.h)(\"div\", null, (0, i.h)(a.default, { page: r3, error: e3.error, showHeader: n3, showSignup: t3, devSettings: !e3.gotrue, loading: !e3.error && e3.gotrue && !e3.settings, isOpen: e3.modal.isOpen, onPage: this.handlePage, onClose: this.handleClose, logo: e3.modal.logo, t: e3.translate, isLocal: e3.isLocal, clearSiteURL: this.clearSiteURL, clearStoreError: this.clearStoreError }, this.renderBody(), this.renderProviders()));\n      } }]) && y(n2.prototype, t2), r2 && y(n2, r2), M2;\n    }(i.Component)) || o;\n    n.default = p;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o = t(0);\n    function i(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function M(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function a(e2, n2) {\n      return (a = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function u(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = c(e2);\n        if (n2) {\n          var o2 = c(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return s(this, t2);\n      };\n    }\n    function s(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function c(e2) {\n      return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var l = function(e2) {\n      !function(e3, n3) {\n        if (\"function\" != typeof n3 && null !== n3)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && a(e3, n3);\n      }(c2, e2);\n      var n2, t2, r2, s2 = u(c2);\n      function c2() {\n        var e3;\n        i(this, c2);\n        for (var n3 = arguments.length, t3 = new Array(n3), r3 = 0; r3 < n3; r3++)\n          t3[r3] = arguments[r3];\n        return (e3 = s2.call.apply(s2, [this].concat(t3))).handleClose = function(n4) {\n          n4.preventDefault(), e3.props.onClose();\n        }, e3.blockEvent = function(e4) {\n          e4.stopPropagation();\n        }, e3.linkHandler = function(n4) {\n          return function(t4) {\n            t4.preventDefault(), e3.props.onPage(n4);\n          };\n        }, e3;\n      }\n      return n2 = c2, (t2 = [{ key: \"render\", value: function() {\n        var e3 = this.props, n3 = e3.page, t3 = e3.error, r3 = e3.loading, i2 = e3.showHeader, M2 = e3.showSignup, a2 = e3.devSettings, u2 = e3.isOpen, s3 = e3.children, c3 = e3.logo, l2 = e3.t, N = e3.isLocal, D = e3.clearSiteURL, g = e3.clearStoreError, y = r3 || !u2, j = t3 ? function(e4) {\n          return e4.json && e4.json.error_description || e4.message || e4.toString();\n        }(t3) : null;\n        return (0, o.h)(\"div\", { className: \"modalContainer\", role: \"dialog\", \"aria-hidden\": \"\".concat(y), onClick: this.handleClose }, (0, o.h)(\"div\", { className: \"modalDialog\".concat(r3 ? \" visuallyHidden\" : \"\"), onClick: this.blockEvent }, (0, o.h)(\"div\", { className: \"modalContent\" }, (0, o.h)(\"button\", { onclick: this.handleClose, className: \"btn btnClose\" }, (0, o.h)(\"span\", { className: \"visuallyHidden\" }, \"Close\")), i2 && (0, o.h)(\"div\", { className: \"header\" }, M2 && (0, o.h)(\"button\", { className: \"btn btnHeader \".concat(n3.signup ? \"active\" : \"\"), onclick: this.linkHandler(\"signup\") }, l2(\"sign_up\")), !a2 && (0, o.h)(\"button\", { className: \"btn btnHeader \".concat(n3.login ? \"active\" : \"\"), onclick: this.linkHandler(\"login\") }, l2(\"log_in\"))), n3.title && (0, o.h)(\"div\", { className: \"header\" }, (0, o.h)(\"button\", { className: \"btn btnHeader active\" }, l2(n3.title))), a2 && (0, o.h)(\"div\", { className: \"header\" }, (0, o.h)(\"button\", { className: \"btn btnHeader active\" }, l2(\"site_url_title\"))), j && (0, o.h)(\"div\", { className: \"flashMessage error\" }, (0, o.h)(\"span\", null, l2(j))), N && j && j.includes(\"Failed to load settings from\") && (0, o.h)(\"div\", null, (0, o.h)(\"button\", { onclick: function(e4) {\n          D(e4), g();\n        }, className: \"btnLink forgotPasswordLink\" }, l2(\"site_url_link_text\"))), s3)), c3 && (0, o.h)(\"a\", { href: \"https://www.netlify.com\", className: \"callOut\".concat(r3 ? \" visuallyHidden\" : \"\") }, (0, o.h)(\"span\", { className: \"netlifyLogo\" }), l2(\"coded_by\")));\n      } }]) && M(n2.prototype, t2), r2 && M(n2, r2), c2;\n    }(o.Component);\n    n.default = l;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o = t(0);\n    function i(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function M(e2, n2) {\n      return (M = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function a(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = s(e2);\n        if (n2) {\n          var o2 = s(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return u(this, t2);\n      };\n    }\n    function u(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function s(e2) {\n      return (s = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var c = function(e2) {\n      !function(e3, n3) {\n        if (\"function\" != typeof n3 && null !== n3)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && M(e3, n3);\n      }(s2, e2);\n      var n2, t2, r2, u2 = a(s2);\n      function s2(e3) {\n        var n3;\n        return function(e4, n4) {\n          if (!(e4 instanceof n4))\n            throw new TypeError(\"Cannot call a class as a function\");\n        }(this, s2), (n3 = u2.call(this, e3)).handleInput = function(e4) {\n          var t3, r3, o2;\n          n3.setState((t3 = {}, r3 = e4.target.name, o2 = e4.target.value, r3 in t3 ? Object.defineProperty(t3, r3, { value: o2, enumerable: true, configurable: true, writable: true }) : t3[r3] = o2, t3));\n        }, n3.addSiteURL = function(e4) {\n          e4.preventDefault();\n          var t3, r3, o2 = (t3 = n3.state.url, r3 = \"/.netlify/identity\", -1 === t3.indexOf(r3) ? t3 : t3.substring(0, t3.length - r3.length));\n          n3.props.onSiteURL(o2);\n        }, n3.clearSiteURL = function(e4) {\n          e4.preventDefault, n3.props.onSiteURL();\n        }, n3.state = { url: \"\", development: e3.devMode || false }, n3;\n      }\n      return n2 = s2, (t2 = [{ key: \"render\", value: function() {\n        var e3 = this, n3 = this.state, t3 = n3.url, r3 = n3.development, i2 = this.props.t;\n        return (0, o.h)(\"div\", null, r3 ? (0, o.h)(\"div\", { class: \"subheader\" }, (0, o.h)(\"h3\", null, i2(\"site_url_title\")), (0, o.h)(\"button\", { onclick: function(n4) {\n          return e3.clearSiteURL(n4);\n        }, className: \"btnLink forgotPasswordLink\" }, i2(\"site_url_link_text\"))) : (0, o.h)(\"form\", { onsubmit: this.addSiteURL, className: \"form\" }, (0, o.h)(\"div\", { className: \"flashMessage\" }, i2(\"site_url_message\")), (0, o.h)(\"div\", { className: \"formGroup\" }, (0, o.h)(\"label\", null, (0, o.h)(\"span\", { className: \"visuallyHidden\" }, i2(\"site_url_label\")), (0, o.h)(\"input\", { className: \"formControl\", type: \"url\", name: \"url\", value: t3, placeholder: i2(\"site_url_placeholder\"), autocapitalize: \"off\", required: true, oninput: this.handleInput }), (0, o.h)(\"div\", { className: \"inputFieldIcon inputFieldUrl\" }))), (0, o.h)(\"button\", { type: \"submit\", className: \"btn\" }, i2(\"site_url_submit\"))));\n      } }]) && i(n2.prototype, t2), r2 && i(n2, r2), s2;\n    }(o.Component);\n    n.default = c;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o, i = t(0), M = (o = t(5)) && o.__esModule ? o : { default: o };\n    function a(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function u(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function s(e2, n2) {\n      return (s = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function c(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = N(e2);\n        if (n2) {\n          var o2 = N(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return l(this, t2);\n      };\n    }\n    function l(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function N(e2) {\n      return (N = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var D = function(e2) {\n      !function(e3, n3) {\n        if (\"function\" != typeof n3 && null !== n3)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && s(e3, n3);\n      }(l2, e2);\n      var n2, t2, r2, o2 = c(l2);\n      function l2() {\n        var e3;\n        a(this, l2);\n        for (var n3 = arguments.length, t3 = new Array(n3), r3 = 0; r3 < n3; r3++)\n          t3[r3] = arguments[r3];\n        return (e3 = o2.call.apply(o2, [this].concat(t3))).handleLogout = function(n4) {\n          n4.preventDefault(), e3.props.onLogout();\n        }, e3;\n      }\n      return n2 = l2, (t2 = [{ key: \"render\", value: function() {\n        var e3 = this.props, n3 = e3.user, t3 = e3.saving, r3 = e3.t;\n        return (0, i.h)(\"form\", { onSubmit: this.handleLogout, className: \"form \".concat(t3 ? \"disabled\" : \"\") }, (0, i.h)(\"p\", { className: \"infoText\" }, r3(\"logged_in_as\"), \" \", (0, i.h)(\"br\", null), (0, i.h)(\"span\", { className: \"infoTextEmail\" }, n3.user_metadata.full_name || n3.user_metadata.name || n3.email)), (0, i.h)(M.default, { saving: t3, text: r3(\"log_out\"), saving_text: r3(\"logging_out\") }));\n      } }]) && u(n2.prototype, t2), r2 && u(n2, r2), l2;\n    }(i.Component);\n    n.default = D;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o = t(0), i = a(t(6)), M = a(t(5));\n    function a(e2) {\n      return e2 && e2.__esModule ? e2 : { default: e2 };\n    }\n    function u(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function s(e2, n2) {\n      return (s = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function c(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = N(e2);\n        if (n2) {\n          var o2 = N(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return l(this, t2);\n      };\n    }\n    function l(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function N(e2) {\n      return (N = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var D = function(e2) {\n      !function(e3, n3) {\n        if (\"function\" != typeof n3 && null !== n3)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && s(e3, n3);\n      }(l2, e2);\n      var n2, t2, r2, a2 = c(l2);\n      function l2(e3) {\n        var n3;\n        return function(e4, n4) {\n          if (!(e4 instanceof n4))\n            throw new TypeError(\"Cannot call a class as a function\");\n        }(this, l2), (n3 = a2.call(this, e3)).handleInput = function(e4) {\n          var t3, r3, o2;\n          n3.setState((t3 = {}, r3 = e4.target.name, o2 = e4.target.value, r3 in t3 ? Object.defineProperty(t3, r3, { value: o2, enumerable: true, configurable: true, writable: true }) : t3[r3] = o2, t3));\n        }, n3.handleLogin = function(e4) {\n          e4.preventDefault(), n3.props.onSubmit(n3.state);\n        }, n3.state = { name: \"\", email: \"\", password: \"\" }, n3;\n      }\n      return n2 = l2, (t2 = [{ key: \"render\", value: function() {\n        var e3 = this.props, n3 = e3.page, t3 = e3.message, r3 = e3.saving, a3 = e3.namePlaceholder, u2 = e3.t, s2 = this.state, c2 = s2.name, l3 = s2.email, N2 = s2.password;\n        return (0, o.h)(\"form\", { onsubmit: this.handleLogin, className: \"form \".concat(r3 ? \"disabled\" : \"\") }, t3 && (0, o.h)(i.default, { type: t3, t: u2 }), n3.name && (0, o.h)(\"div\", { className: \"formGroup\" }, (0, o.h)(\"label\", null, (0, o.h)(\"span\", { className: \"visuallyHidden\" }, u2(\"form_name_placeholder\")), (0, o.h)(\"input\", { className: \"formControl\", type: \"name\", name: \"name\", value: c2, placeholder: a3 || u2(\"form_name_label\"), autocapitalize: \"off\", required: true, oninput: this.handleInput }), (0, o.h)(\"div\", { className: \"inputFieldIcon inputFieldName\" }))), n3.email && (0, o.h)(\"div\", { className: \"formGroup\" }, (0, o.h)(\"label\", null, (0, o.h)(\"span\", { className: \"visuallyHidden\" }, u2(\"form_name_label\")), (0, o.h)(\"input\", { className: \"formControl\", type: \"email\", name: \"email\", value: l3, placeholder: u2(\"form_email_placeholder\"), autocapitalize: \"off\", required: true, oninput: this.handleInput }), (0, o.h)(\"div\", { className: \"inputFieldIcon inputFieldEmail\" }))), n3.password && (0, o.h)(\"div\", { className: \"formGroup\" }, (0, o.h)(\"label\", null, (0, o.h)(\"span\", { className: \"visuallyHidden\" }, u2(\"form_password_label\")), (0, o.h)(\"input\", { className: \"formControl\", type: \"password\", name: \"password\", value: N2, placeholder: u2(\"form_password_placeholder\"), autocomplete: n3.password, required: true, oninput: this.handleInput }), (0, o.h)(\"div\", { className: \"inputFieldIcon inputFieldPassword\" }))), (0, o.h)(M.default, { saving: r3, text: u2(n3.button), saving_text: u2(n3.button_saving) }));\n      } }]) && u(n2.prototype, t2), r2 && u(n2, r2), l2;\n    }(o.Component);\n    n.default = D;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o = t(0);\n    function i(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function M(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function a(e2, n2, t2) {\n      return n2 && M(e2.prototype, n2), t2 && M(e2, t2), e2;\n    }\n    function u(e2, n2) {\n      if (\"function\" != typeof n2 && null !== n2)\n        throw new TypeError(\"Super expression must either be null or a function\");\n      e2.prototype = Object.create(n2 && n2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), n2 && s(e2, n2);\n    }\n    function s(e2, n2) {\n      return (s = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function c(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = N(e2);\n        if (n2) {\n          var o2 = N(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return l(this, t2);\n      };\n    }\n    function l(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function N(e2) {\n      return (N = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var D = function(e2) {\n      u(t2, e2);\n      var n2 = c(t2);\n      function t2() {\n        var e3;\n        i(this, t2);\n        for (var r2 = arguments.length, o2 = new Array(r2), M2 = 0; M2 < r2; M2++)\n          o2[M2] = arguments[M2];\n        return (e3 = n2.call.apply(n2, [this].concat(o2))).handleLogin = function(n3) {\n          n3.preventDefault(), e3.props.onLogin(e3.props.provider.toLowerCase());\n        }, e3;\n      }\n      return a(t2, [{ key: \"render\", value: function() {\n        var e3 = this.props, n3 = e3.provider, t3 = e3.label, r2 = e3.t;\n        return (0, o.h)(\"button\", { onClick: this.handleLogin, className: \"provider\".concat(n3, \" btn btnProvider\") }, \"\".concat(r2(\"continue_with\"), \" \").concat(t3));\n      } }]), t2;\n    }(o.Component), g = function(e2) {\n      u(t2, e2);\n      var n2 = c(t2);\n      function t2() {\n        return i(this, t2), n2.apply(this, arguments);\n      }\n      return a(t2, [{ key: \"getLabel\", value: function(e3) {\n        var n3 = e3.toLowerCase();\n        return n3 in this.props.labels ? this.props.labels[n3] : e3;\n      } }, { key: \"render\", value: function() {\n        var e3 = this, n3 = this.props, t3 = n3.providers, r2 = n3.onLogin, i2 = n3.t;\n        return (0, o.h)(\"div\", { className: \"providersGroup\" }, (0, o.h)(\"hr\", { className: \"hr\" }), t3.map(function(n4) {\n          return (0, o.h)(D, { key: n4, provider: n4, label: e3.getLabel(n4), onLogin: r2, t: i2 });\n        }));\n      } }]), t2;\n    }(o.Component);\n    n.default = g;\n  }, function(e, n, t) {\n    \"use strict\";\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var r = t(1), o = t(20), i = (0, r.observable)({ user: null, recovered_user: null, message: null, settings: null, gotrue: null, error: null, siteURL: null, remember: true, saving: false, invite_token: null, email_change_token: null, namePlaceholder: null, modal: { page: \"login\", isOpen: false, logo: true }, locale: o.defaultLocale });\n    i.setNamePlaceholder = (0, r.action)(function(e2) {\n      i.namePlaceholder = e2;\n    }), i.startAction = (0, r.action)(function() {\n      i.saving = true, i.error = null, i.message = null;\n    }), i.setError = (0, r.action)(function(e2) {\n      i.saving = false, i.error = e2;\n    }), i.init = (0, r.action)(function(e2, n2) {\n      e2 && (i.gotrue = e2, i.user = e2.currentUser(), i.user && (i.modal.page = \"user\")), n2 && i.loadSettings();\n    }), i.loadSettings = (0, r.action)(function() {\n      i.settings || i.gotrue && i.gotrue.settings().then((0, r.action)(function(e2) {\n        return i.settings = e2;\n      })).catch((0, r.action)(function(e2) {\n        i.error = new Error(\"Failed to load settings from \".concat(i.gotrue.api.apiURL));\n      }));\n    }), i.setIsLocal = (0, r.action)(function(e2) {\n      i.isLocal = e2;\n    }), i.setSiteURL = (0, r.action)(function(e2) {\n      i.siteURL = e2;\n    }), i.clearSiteURL = (0, r.action)(function() {\n      i.gotrue = null, i.siteURL = null, i.settings = null;\n    }), i.login = (0, r.action)(function(e2, n2) {\n      return i.startAction(), i.gotrue.login(e2, n2, i.remember).then((0, r.action)(function(e3) {\n        i.user = e3, i.modal.page = \"user\", i.invite_token = null, i.email_change_token && i.doEmailChange(), i.saving = false;\n      })).catch(i.setError);\n    }), i.externalLogin = (0, r.action)(function(e2) {\n      i.error = null, i.message = null;\n      var n2 = i.invite_token ? i.gotrue.acceptInviteExternalUrl(e2, i.invite_token) : i.gotrue.loginExternalUrl(e2);\n      window.location.href = n2;\n    }), i.completeExternalLogin = (0, r.action)(function(e2) {\n      i.startAction(), i.gotrue.createUser(e2, i.remember).then(function(e3) {\n        i.user = e3, i.modal.page = \"user\", i.saving = false;\n      }).catch(i.setError);\n    }), i.signup = (0, r.action)(function(e2, n2, t2) {\n      return i.startAction(), i.gotrue.signup(n2, t2, { full_name: e2 }).then((0, r.action)(function() {\n        i.settings.autoconfirm ? i.login(n2, t2, i.remember) : i.message = \"confirm\", i.saving = false;\n      })).catch(i.setError);\n    }), i.logout = (0, r.action)(function() {\n      if (i.user)\n        return i.startAction(), i.user.logout().then((0, r.action)(function() {\n          i.user = null, i.modal.page = \"login\", i.saving = false;\n        })).catch(i.setError);\n      i.modal.page = \"login\", i.saving = false;\n    }), i.updatePassword = (0, r.action)(function(e2) {\n      i.startAction(), (i.recovered_user || i.user).update({ password: e2 }).then(function(e3) {\n        i.user = e3, i.recovered_user = null, i.modal.page = \"user\", i.saving = false;\n      }).catch(i.setError);\n    }), i.acceptInvite = (0, r.action)(function(e2) {\n      i.startAction(), i.gotrue.acceptInvite(i.invite_token, e2, i.remember).then(function(e3) {\n        i.saving = false, i.invite_token = null, i.user = e3, i.modal.page = \"user\";\n      }).catch(i.setError);\n    }), i.doEmailChange = (0, r.action)(function() {\n      return i.startAction(), i.user.update({ email_change_token: i.email_change_token }).then((0, r.action)(function(e2) {\n        i.user = e2, i.email_change_token = null, i.message = \"email_changed\", i.saving = false;\n      })).catch(i.setError);\n    }), i.verifyToken = (0, r.action)(function(e2, n2) {\n      var t2 = i.gotrue;\n      switch (i.modal.isOpen = true, e2) {\n        case \"confirmation\":\n          i.startAction(), i.modal.page = \"signup\", t2.confirm(n2, i.remember).then((0, r.action)(function(e3) {\n            i.user = e3, i.saving = false;\n          })).catch((0, r.action)(function(e3) {\n            console.error(e3), i.message = \"verfication_error\", i.modal.page = \"signup\", i.saving = false;\n          }));\n          break;\n        case \"email_change\":\n          i.email_change_token = n2, i.modal.page = \"message\", i.user ? i.doEmailChange() : i.modal.page = \"login\";\n          break;\n        case \"invite\":\n          i.modal.page = e2, i.invite_token = n2;\n          break;\n        case \"recovery\":\n          i.startAction(), i.modal.page = e2, i.gotrue.recover(n2, i.remember).then(function(e3) {\n            i.saving = false, i.recovered_user = e3;\n          }).catch(function(e3) {\n            i.saving = false, i.error = e3, i.modal.page = \"login\";\n          });\n          break;\n        default:\n          i.error = \"Unkown token type\";\n      }\n    }), i.requestPasswordRecovery = (0, r.action)(function(e2) {\n      i.startAction(), i.gotrue.requestPasswordRecovery(e2).then((0, r.action)(function() {\n        i.message = \"password_mail\", i.saving = false;\n      })).catch(i.setError);\n    }), i.openModal = (0, r.action)(function(e2) {\n      i.modal.page = e2, i.modal.isOpen = true;\n    }), i.closeModal = (0, r.action)(function() {\n      i.modal.isOpen = false, i.error = null, i.message = null, i.saving = false;\n    }), i.translate = (0, r.action)(function(e2) {\n      return (0, o.getTranslation)(e2, i.locale);\n    });\n    var M = i;\n    n.default = M;\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.getTranslation = n.defaultLocale = void 0;\n    var o = D(t(21)), i = D(t(22)), M = D(t(23)), a = D(t(24)), u = D(t(25)), s = D(t(26)), c = D(t(27)), l = D(t(28));\n    function N(e2) {\n      if (\"function\" != typeof WeakMap)\n        return null;\n      var n2 = /* @__PURE__ */ new WeakMap(), t2 = /* @__PURE__ */ new WeakMap();\n      return (N = function(e3) {\n        return e3 ? t2 : n2;\n      })(e2);\n    }\n    function D(e2, n2) {\n      if (!n2 && e2 && e2.__esModule)\n        return e2;\n      if (null === e2 || \"object\" !== r(e2) && \"function\" != typeof e2)\n        return { default: e2 };\n      var t2 = N(n2);\n      if (t2 && t2.has(e2))\n        return t2.get(e2);\n      var o2 = {}, i2 = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var M2 in e2)\n        if (\"default\" !== M2 && Object.prototype.hasOwnProperty.call(e2, M2)) {\n          var a2 = i2 ? Object.getOwnPropertyDescriptor(e2, M2) : null;\n          a2 && (a2.get || a2.set) ? Object.defineProperty(o2, M2, a2) : o2[M2] = e2[M2];\n        }\n      return o2.default = e2, t2 && t2.set(e2, o2), o2;\n    }\n    n.defaultLocale = \"en\";\n    var g = { en: o, fr: i, es: M, hu: a, pt: u, pl: s, cs: c, sk: l };\n    n.getTranslation = function(e2) {\n      var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"en\", t2 = g[n2] && g[n2][e2];\n      return t2 || g.en[e2] || e2;\n    };\n  }, function(e) {\n    e.exports = JSON.parse(`{\"log_in\":\"Log in\",\"log_out\":\"Log out\",\"logged_in_as\":\"Logged in as\",\"logged_in\":\"Logged in\",\"logging_in\":\"Logging in\",\"logging_out\":\"Logging out\",\"sign_up\":\"Sign up\",\"signing_up\":\"Signing up\",\"forgot_password\":\"Forgot password?\",\"recover_password\":\"Recover password\",\"send_recovery_email\":\"Send recovery email\",\"sending_recovery_email\":\"Sending recovery email\",\"never_mind\":\"Never mind\",\"update_password\":\"Update password\",\"updating_password\":\"Updating password\",\"complete_your_signup\":\"Complete your signup\",\"site_url_title\":\"Development Settings\",\"site_url_link_text\":\"Clear localhost URL\",\"site_url_message\":\"Looks like you're running a local server. Please let us know the URL of your Netlify site.\",\"site_url_label\":\"Enter your Netlify Site URL\",\"site_url_placeholder\":\"URL of your Netlify site\",\"site_url_submit\":\"Set site's URL\",\"message_confirm\":\"A confirmation message was sent to your email, click the link there to continue.\",\"message_password_mail\":\"We've sent a recovery email to your account, follow the link there to reset your password.\",\"message_email_changed\":\"Your email address has been updated!\",\"message_verfication_error\":\"There was an error verifying your account. Please try again or contact an administrator.\",\"message_signup_disabled\":\"Public signups are disabled. Contact an administrator and ask for an invite.\",\"form_name_placeholder\":\"Name\",\"form_email_label\":\"Enter your email\",\"form_name_label\":\"Enter your name\",\"form_email_placeholder\":\"Email\",\"form_password_label\":\"Enter your password\",\"form_password_placeholder\":\"Password\",\"coded_by\":\"Coded by Netlify\",\"continue_with\":\"Continue with\",\"No user found with this email\":\"No user found with this email\",\"Invalid Password\":\"Invalid Password\",\"Email not confirmed\":\"Email not confirmed\",\"User not found\":\"User not found\"}`);\n  }, function(e) {\n    e.exports = JSON.parse(`{\"log_in\":\"Connexion\",\"log_out\":\"D\\xE9connexion\",\"logged_in_as\":\"Connect\\xE9 en tant que\",\"logged_in\":\"Connect\\xE9\",\"logging_in\":\"Connexion\",\"logging_out\":\"D\\xE9connexion\",\"sign_up\":\"Inscription\",\"signing_up\":\"Inscription\",\"forgot_password\":\"Mot de passe oubli\\xE9 ?\",\"recover_password\":\"R\\xE9cup\\xE9rer le mot de passe\",\"send_recovery_email\":\"Envoyer l'e-mail de r\\xE9cup\\xE9ration\",\"sending_recovery_email\":\"Envoi de l'e-mail de r\\xE9cup\\xE9ration\",\"never_mind\":\"Annuler\",\"update_password\":\"Mettre \\xE0 jour le mot de passe\",\"updating_password\":\"Mise \\xE0 jour du mot de passe\",\"complete_your_signup\":\"Compl\\xE9ter l'inscription\",\"site_url_title\":\"Param\\xE8tres de d\\xE9veloppement\",\"site_url_link_text\":\"Effacer l'URL localhost\",\"site_url_message\":\"On dirait que vous faites tourner un serveur local. Veuillez nous indiquer l'URL de votre site Netlify.\",\"site_url_label\":\"Entrez l'URL de votre site Netlify\",\"site_url_placeholder\":\"URL de votre site Netlify\",\"site_url_submit\":\"D\\xE9finir l'URL du site\",\"message_confirm\":\"Un message de confirmation a \\xE9t\\xE9 envoy\\xE9 \\xE0 votre adresse \\xE9lectronique, cliquez sur le lien pour continuer.\",\"message_password_mail\":\"Nous avons envoy\\xE9 un e-mail de r\\xE9cup\\xE9ration \\xE0 votre compte, suivez le lien qui s'y trouve pour r\\xE9initialiser votre mot de passe.\",\"message_email_changed\":\"Votre adresse e-mail a \\xE9t\\xE9 mise \\xE0 jour !\",\"message_verfication_error\":\"Il y a eu une erreur lors de la v\\xE9rification de votre compte. Veuillez r\\xE9essayer ou contacter un administrateur.\",\"message_signup_disabled\":\"Les inscriptions publiques sont d\\xE9sactiv\\xE9es. Contactez un administrateur et demandez une invitation.\",\"form_name_placeholder\":\"Nom\",\"form_email_label\":\"Entrez votre adresse e-mail\",\"form_name_label\":\"Saisissez votre nom\",\"form_email_placeholder\":\"E-mail\",\"form_password_label\":\"Saisissez votre mot de passe\",\"form_password_placeholder\":\"Mot de passe\",\"coded_by\":\"Cod\\xE9 par Netlify\",\"continue_with\":\"Continuer avec\",\"No user found with this email\":\"Aucun utilisateur trouv\\xE9 avec cet e-mail\",\"Invalid Password\":\"Mot de passe incorrect\",\"Email not confirmed\":\"Adresse e-mail non confirm\\xE9e\",\"User not found\":\"Aucun utilisateur trouv\\xE9\"}`);\n  }, function(e) {\n    e.exports = JSON.parse('{\"log_in\":\"Iniciar sesi\\xF3n\",\"log_out\":\"Cerrar sesi\\xF3n\",\"logged_in_as\":\"Conectado como\",\"logged_in\":\"Conectado\",\"logging_in\":\"Iniciando sesi\\xF3n\",\"logging_out\":\"Cerrando sesi\\xF3n\",\"sign_up\":\"Registrate\",\"signing_up\":\"Registrandose\",\"forgot_password\":\"\\xBFOlvidaste tu contrase\\xF1a?\",\"recover_password\":\"Recuperar contrase\\xF1a\",\"send_recovery_email\":\"Enviar correo electr\\xF3nico de recuperaci\\xF3n\",\"sending_recovery_email\":\"Enviando correo electr\\xF3nico de recuperaci\\xF3n\",\"never_mind\":\"Regresar\",\"update_password\":\"Actualizar contrase\\xF1a\",\"updating_password\":\"Actualizando contrase\\xF1a\",\"complete_your_signup\":\"Completa tu registro\",\"site_url_title\":\"Configuraci\\xF3n de desarrollo\",\"site_url_link_text\":\"Borrar URL del localhost\",\"site_url_message\":\"Parece que estas corriendo un servidor local. Por favor haznos saber la URL de tu sitio en Netlify.\",\"site_url_label\":\"Ingresa la URL de tu sitio en Netlify\",\"site_url_placeholder\":\"URL de tu sitio en Netlify\",\"site_url_submit\":\"Establecer la URL del sitio\",\"message_confirm\":\"Se envi\\xF3 un mensaje de confirmaci\\xF3n a tu correo electr\\xF3nico, haz clic en el enlace all\\xED para continuar.\",\"message_password_mail\":\"Hemos enviado un correo electr\\xF3nico de recuperaci\\xF3n a tu correo electr\\xF3nico, sigue el enlace all\\xED para restablecer tu contrase\\xF1a.\",\"message_email_changed\":\"\\xA1Tu direcci\\xF3n de correo electr\\xF3nico ha sido actualizada!\",\"message_verfication_error\":\"Se produjo un error al verificar tu cuenta. Por favor intenta nuevamente o contacta a un administrador.\",\"message_signup_disabled\":\"Los registros p\\xFAblicos est\\xE1n deshabilitados. Contacta a un administrador y solicita una invitaci\\xF3n.\",\"form_name_placeholder\":\"Nombre\",\"form_email_label\":\"Ingresa tu correo electr\\xF3nico\",\"form_name_label\":\"Ingresa tu nombre\",\"form_email_placeholder\":\"Correo electr\\xF3nico\",\"form_password_label\":\"Ingresa tu contrase\\xF1a\",\"form_password_placeholder\":\"Contrase\\xF1a\",\"coded_by\":\"Codificado por Netlify\",\"continue_with\":\"Contin\\xFAa con\",\"No user found with this email\":\"No existe ning\\xFAn usuario con este correo electr\\xF3nico\",\"Invalid Password\":\"La contrase\\xF1a es invalida\",\"Email not confirmed\":\"Correo electr\\xF3nico no confirmado\",\"User not found\":\"Usuario no encontrado\"}');\n  }, function(e) {\n    e.exports = JSON.parse('{\"log_in\":\"Bejelentkez\\xE9s\",\"log_out\":\"Kijelentkez\\xE9s\",\"logged_in_as\":\"Bejelentkezve mint\",\"logged_in\":\"Bejelentkezve\",\"logging_in\":\"Bejelentkez\\xE9s\",\"logging_out\":\"Kijelentkez\\xE9s\",\"sign_up\":\"Regisztr\\xE1ci\\xF3\",\"signing_up\":\"Regisztr\\xE1l\\xE1s\",\"forgot_password\":\"Elfelejtette a jelszav\\xE1t?\",\"recover_password\":\"Jelsz\\xF3 vissza\\xE1ll\\xEDt\\xE1sa\",\"send_recovery_email\":\"Jelsz\\xF3p\\xF3tl\\xF3 lev\\xE9l k\\xFCld\\xE9se\",\"sending_recovery_email\":\"Jelsz\\xF3p\\xF3tl\\xF3 lev\\xE9l k\\xFCld\\xE9se\",\"never_mind\":\"M\\xE9gsem\",\"update_password\":\"\\xDAj jelsz\\xF3 be\\xE1ll\\xEDt\\xE1sa\",\"updating_password\":\"\\xDAj jelsz\\xF3 be\\xE1ll\\xEDt\\xE1sa\",\"complete_your_signup\":\"Regisztr\\xE1ci\\xF3 befejez\\xE9se\",\"site_url_title\":\"Fejleszt\\u0151i Be\\xE1ll\\xEDt\\xE1sok\",\"site_url_link_text\":\"Localhost URL t\\xF6rl\\xE9se\",\"site_url_message\":\"\\xDAgy n\\xE9z ki egy helyi szervert futtat. K\\xE9rj\\xFCk adja meg a Netlify oldala URL-j\\xE9t.\",\"site_url_label\":\"Adja meg a Netlify oldala URL-j\\xE9t\",\"site_url_placeholder\":\"a Netlify oldala URL-je\",\"site_url_submit\":\"URL be\\xE1ll\\xEDt\\xE1sa\",\"message_confirm\":\"Elk\\xFCldt\\xFCnk egy meger\\u0151s\\xEDt\\u0151 levelet e-mailben, k\\xE9rj\\xFCk kattintson a linkre a lev\\xE9lben a folytat\\xE1shoz.\",\"message_password_mail\":\"Elk\\xFCldt\\xFCnk egy jelsz\\xF3p\\xF3tl\\xF3 levelet e-mailben, k\\xE9rj\\xFCk k\\xF6vesse a linket a lev\\xE9lben a jelszava vissza\\xE1ll\\xEDt\\xE1s\\xE1hoz.\",\"message_email_changed\":\"Az e-mail c\\xEDm\\xE9t friss\\xEDtett\\xFCk!\",\"message_verfication_error\":\"Probl\\xE9ma t\\xF6rt\\xE9nt a fi\\xF3kja meger\\u0151s\\xEDt\\xE9se k\\xF6zben. K\\xE9rj\\xFCk pr\\xF3b\\xE1lja \\xFAjra, vagy vegye fel a kapcsolatot egy adminisztr\\xE1torral.\",\"message_signup_disabled\":\"A nyilv\\xE1nos regisztr\\xE1ci\\xF3 nincs enged\\xE9lyezve. Vegye fel a kapcsolatot egy adminisztr\\xE1torral \\xE9s k\\xE9rjen megh\\xEDv\\xF3t.\",\"form_name_placeholder\":\"N\\xE9v\",\"form_email_label\":\"Adja meg az e-mail c\\xEDm\\xE9t\",\"form_name_label\":\"Adja meg a nev\\xE9t\",\"form_email_placeholder\":\"E-mail\",\"form_password_label\":\"Adja meg a jelszav\\xE1t\",\"form_password_placeholder\":\"Jelsz\\xF3\",\"coded_by\":\"Fejlesztette a Netlify\",\"continue_with\":\"Bejelentkez\\xE9s ezzel:\",\"No user found with this email\":\"Nem tal\\xE1lhat\\xF3 fi\\xF3k ezzel az e-mail c\\xEDmmel\",\"Invalid Password\":\"Helytelen Jelsz\\xF3\",\"Email not confirmed\":\"Az e-mail nem er\\u0151s\\xFClt meg\",\"User not found\":\"Felhaszn\\xE1l\\xF3 nem tal\\xE1lhat\\xF3\"}');\n  }, function(e) {\n    e.exports = JSON.parse('{\"log_in\":\"Entrar\",\"log_out\":\"Sair\",\"logged_in_as\":\"Logado como\",\"logged_in\":\"Logado em\",\"logging_in\":\"Logando em\",\"logging_out\":\"Saindo\",\"sign_up\":\"Registrar\",\"signing_up\":\"Registrando\",\"forgot_password\":\"Esqueceu a senha?\",\"recover_password\":\"Recuperar senha\",\"send_recovery_email\":\"Enviar email de recupera\\xE7\\xE3o de senha\",\"sending_recovery_email\":\"Enviando email de recupera\\xE7\\xE3o de senha\",\"never_mind\":\"Deixa pra l\\xE1\",\"update_password\":\"Atualizar senha\",\"updating_password\":\"Atualizando senha\",\"complete_your_signup\":\"Complete seu registro\",\"site_url_title\":\"Configura\\xE7\\xF5es de desenvolvimento\",\"site_url_link_text\":\"Limpar URL do localhost\",\"site_url_message\":\"Parece que voc\\xEA est\\xE1 executando um servidor local. Informe-nos o URL do seu site Netlify.\",\"site_url_label\":\"Insira o URL do seu site Netlify\",\"site_url_placeholder\":\"URL do seu site Netlify\",\"site_url_submit\":\"Configure a URL do seu site\",\"message_confirm\":\"Uma mensagem de confirma\\xE7\\xE3o foi enviada para o seu email, clique no link para continuar.\",\"message_password_mail\":\"Enviamos um e-mail de recupera\\xE7\\xE3o para sua conta, siga o link para redefinir sua senha.\",\"message_email_changed\":\"Seu email foi atualizado!\",\"message_verfication_error\":\"Ocorreu um erro ao verificar sua conta. Tente novamente ou entre em contato com um administrador.\",\"message_signup_disabled\":\"Registros p\\xFAblicos est\\xE3o desabilitados. Contate um administrador e pe\\xE7a por um convite.\",\"form_name_placeholder\":\"Nome\",\"form_email_label\":\"Insira seu email\",\"form_name_label\":\"Insira seu nome\",\"form_email_placeholder\":\"Email\",\"form_password_label\":\"Insira sua senha\",\"form_password_placeholder\":\"Senha\",\"coded_by\":\"Desenvolvido por Netlify\",\"continue_with\":\"Continue com\",\"No user found with this email\":\"Nenhum usu\\xE1rio encontrado com esse email\",\"Invalid Password\":\"Senha inv\\xE1lida\",\"Email not confirmed\":\"Email n\\xE3o confirmado\",\"User not found\":\"Usu\\xE1rio n\\xE3o encontrado\"}');\n  }, function(e) {\n    e.exports = JSON.parse('{\"log_in\":\"Zaloguj si\\u0119\",\"log_out\":\"Wyloguj si\\u0119\",\"logged_in_as\":\"Zaloguj jako\",\"logged_in\":\"Zalogowany\",\"logging_in\":\"Logowanie\",\"logging_out\":\"Wylogowywanie\",\"sign_up\":\"Zarejestruj si\\u0119\",\"signing_up\":\"Rejestracja\",\"forgot_password\":\"Nie pami\\u0119tasz has\\u0142a?\",\"recover_password\":\"Resetuj has\\u0142o\",\"send_recovery_email\":\"Wy\\u015Blij link do resetowania has\\u0142a\",\"sending_recovery_email\":\"Wysy\\u0142anie linku do resetowania has\\u0142a\",\"never_mind\":\"Nieistotne\",\"update_password\":\"Zaktualizuj has\\u0142o\",\"updating_password\":\"Aktualizowanie has\\u0142o\",\"complete_your_signup\":\"Doko\\u0144cz rejestracj\\u0119\",\"site_url_title\":\"Ustawienia strony\",\"site_url_link_text\":\"Usu\\u0144 adres localhost\",\"site_url_message\":\"Wygl\\u0105da na to \\u017Ce zosta\\u0142 uruchomiony lokalny serwer. Wprowad\\u017A adres Twojej strony na Netlify.\",\"site_url_label\":\"Wprowadz adres strony na Netlify\",\"site_url_placeholder\":\"Adres Twojej strony na Netlify\",\"site_url_submit\":\"Ustaw adres strony\",\"message_confirm\":\"Potwierdzenie zosta\\u0142o wys\\u0142ane na Tw\\xF3j adres email. Kliknij w link w wiadomo\\u015Bci aby kontunuowa\\u0107.\",\"message_password_mail\":\"Wys\\u0142ali\\u015Bmy link resetuj\\u0105cy has\\u0142o na Tw\\xF3j adres email. Klknij w link w wiadomo\\u015Bci aby zresetowa\\u0107 has\\u0142o.\",\"message_email_changed\":\"Tw\\xF3j adres email zosta\\u0142 zaktualizowany!\",\"message_verfication_error\":\"Wyst\\u0105pi\\u0142 b\\u0142\\u0105d podczas weryfikcacji Twoje konta. Spr\\xF3buj ponownie lub skontaktuj si\\u0119 z administratorem,\",\"message_signup_disabled\":\"Publiczna rejestracja jest wy\\u0142\\u0105czona. Skontaktuj si\\u0119 z administratorem by uzyska\\u0107 zaproszenie.\",\"form_name_placeholder\":\"Imi\\u0119\",\"form_email_label\":\"Wprowad\\u017A Tw\\xF3j adres email\",\"form_name_label\":\"Wprowad\\u017A Twoje imi\\u0119\",\"form_email_placeholder\":\"Email\",\"form_password_label\":\"Wprowad\\u017A twoje has\\u0142o\",\"form_password_placeholder\":\"Has\\u0142o\",\"coded_by\":\"Coded by Netlify\",\"continue_with\":\"Kontynuuj z\",\"No user found with this email\":\"Nie znaleziono u\\u017Cytkownika o tym adresie\",\"Invalid Password\":\"Has\\u0142o nieprawid\\u0142owe\",\"Email not confirmed\":\"Email nie zosta\\u0142 potwierdzony\",\"User not found\":\"Nie znaleziono u\\u017Cytkownika\"}');\n  }, function(e) {\n    e.exports = JSON.parse('{\"log_in\":\"P\\u0159ihl\\xE1sit se\",\"log_out\":\"Odhl\\xE1sit se\",\"logged_in_as\":\"P\\u0159ihl\\xE1\\u0161en jako\",\"logged_in\":\"P\\u0159ihl\\xE1\\u0161en\\xFD u\\u017Eivatel\",\"logging_in\":\"Prob\\xEDh\\xE1 p\\u0159ihl\\xE1\\u0161en\\xED\",\"logging_out\":\"Prob\\xEDh\\xE1 odhl\\xE1\\u0161en\\xED\",\"sign_up\":\"Zaregistrovat se\",\"signing_up\":\"Registrace\",\"forgot_password\":\"Zapomn\\u011Bli jste heslo?\",\"recover_password\":\"Obnovit heslo\",\"send_recovery_email\":\"Odeslat e-mail pro obnoven\\xED\",\"sending_recovery_email\":\"Odes\\xEDl\\xE1n\\xED e-mailu pro obnoven\\xED\",\"never_mind\":\"Zp\\u011Bt\",\"update_password\":\"Aktualizovat heslo\",\"updated_password\":\"Aktualizace hesla\",\"complete_your_signup\":\"Dokon\\u010Dete registraci\",\"site_url_title\":\"Nastaven\\xED v\\xFDvoje\",\"site_url_link_text\":\"Vymazat URL localhost\",\"site_url_message\":\"Zd\\xE1 se, \\u017Ee pou\\u017E\\xEDv\\xE1te lok\\xE1ln\\xED server. Sd\\u011Blte n\\xE1m pros\\xEDm adresu URL sv\\xE9ho Netlify serveru.\",\"site_url_label\":\"Zadejte adresu URL sv\\xE9ho serveru Netlify\",\"site_url_placeholder\":\"URL va\\u0161eho Netlify serveru\",\"site_url_submit\":\"Nastavit adresu URL\",\"message_confirm\":\"Na v\\xE1\\u0161 e-mail byl odesl\\xE1n odkaz k potvrzen\\xED registrace, pokra\\u010Dujte kliknut\\xEDm na tento odkaz.\",\"message_password_mail\":\"Zaslali jsme v\\xE1m e-mail pro obnoven\\xED hesla, heslo obnov\\xEDte kliknut\\xEDm na odkaz v e-mailu.\",\"message_email_changed\":\"Va\\u0161e e-mailov\\xE1 adresa byla aktualizov\\xE1na!\",\"message_verfication_error\":\"P\\u0159i ov\\u011B\\u0159ov\\xE1n\\xED va\\u0161eho \\xFA\\u010Dtu do\\u0161lo k chyb\\u011B. Zkuste to pros\\xEDm znovu nebo kontaktujte spr\\xE1vce.\",\"message_signup_disabled\":\"Registrace pro ve\\u0159ejnost jsou zak\\xE1z\\xE1ny. Kontaktujte spr\\xE1vce a po\\u017E\\xE1dejte o pozv\\xE1nku.\",\"form_name_placeholder\":\"Jm\\xE9no\",\"form_email_label\":\"Zadejte sv\\u016Fj e-mail\",\"form_name_label\":\"Zadejte sv\\xE9 jm\\xE9no\",\"form_email_placeholder\":\"E-mail\",\"form_password_label\":\"Zadejte sv\\xE9 heslo\",\"form_password_placeholder\":\"Heslo\",\"coded_by\":\"Vytvo\\u0159eno Netlify\",\"continue_with\":\"Pokra\\u010Dovat p\\u0159es\",\"No user found with this email\":\"Nebyl nalezen \\u017E\\xE1dn\\xFD u\\u017Eivatel s t\\xEDmto e-mailem\",\"Invalid Password\":\"Neplatn\\xE9 heslo\",\"Email not confirmed\":\"E-mail nebyl potvrzen\",\"User not found\":\"U\\u017Eivatel nebyl nalezen\"}');\n  }, function(e) {\n    e.exports = JSON.parse('{\"log_in\":\"Prihl\\xE1si\\u0165 sa\",\"log_out\":\"Odhl\\xE1si\\u0165 sa\",\"logged_in_as\":\"Prihl\\xE1sen\\xFD ako\",\"logged_in\":\"Prihl\\xE1sen\\xFD u\\u017E\\xEDvate\\u013E\",\"logging_in\":\"Prebieha prihl\\xE1senie\",\"logging_out\":\"Prebieha odhl\\xE1senie\",\"sign_up\":\"Zaregistrova\\u0165 sa\",\"signing_up\":\"Registr\\xE1cia\",\"forgot_password\":\"Zabudli ste heslo?\",\"recover_password\":\"Obnovi\\u0165 heslo\",\"send_recovery_email\":\"Odosla\\u0165 e-mail pre obnovenie\",\"sending_recovery_email\":\"Odosielanie e-mailu pre obnovenie\",\"never_mind\":\"Nasp\\xE4\\u0165\",\"update_password\":\"Aktualizova\\u0165 heslo\",\"updated_password\":\"Aktualiz\\xE1cia hesla\",\"complete_your_signup\":\"Dokon\\u010Dite registr\\xE1ciu\",\"site_url_title\":\"Nastavenie v\\xFDvoja\",\"site_url_link_text\":\"Vymaza\\u0165 URL localhost\",\"site_url_message\":\"Zd\\xE1 sa, \\u017Ee pou\\u017E\\xEDvate lok\\xE1lny server. Pros\\xEDm, nastavte URL adresu svojho Netlify servera.\",\"site_url_label\":\"Zadajte URL svojho Netlify servera\",\"site_url_placeholder\":\"URL v\\xE1\\u0161ho Netlify servera\",\"site_url_submit\":\"Nastavi\\u0165 URL adresu\",\"message_confirm\":\"Potvr\\u010Fte registr\\xE1ciu kliknut\\xEDm na odkaz v spr\\xE1ve, ktor\\xFA sme V\\xE1m pr\\xE1ve zaslali na v\\xE1\\u0161 email.\",\"message_password_mail\":\"Poslali sme v\\xE1m e-mail pre obnovenie hesla, heslo obnov\\xEDte kliknut\\xEDm na odkaz v e-maile.\",\"message_email_changed\":\"Va\\u0161a e-mailov\\xE1 adresa bola aktualizovan\\xE1!\",\"message_verfication_error\":\"Pri overovan\\xED v\\xE1\\u0161ho \\xFA\\u010Dtu do\\u0161lo k chybe. Pros\\xEDm, sk\\xFAste to znova alebo kontaktujte spr\\xE1vcu.\",\"message_signup_disabled\":\"Registr\\xE1cia pre verejnos\\u0165 s\\xFA zak\\xE1zan\\xE9. Kontaktujte spr\\xE1vcu a po\\u017Eiadajte o pozv\\xE1nku.\",\"form_name_placeholder\":\"Meno\",\"form_email_label\":\"Zadajte svoj e-mail\",\"form_name_label\":\"Zadajte svoje meno\",\"form_email_placeholder\":\"E-mail\",\"form_password_label\":\"Zadajte svoje heslo\",\"form_password_placeholder\":\"Heslo\",\"coded_by\":\"Vytvoren\\xE9 Netlify\",\"continue_with\":\"Pokra\\u010Dova\\u0165 cez\",\"No user found with this email\":\"Nebol n\\xE1jden\\xFD \\u017Eiadny u\\u017E\\xEDvate\\u013E s t\\xFDmto e-mailom\",\"Invalid Password\":\"Neplatn\\xE9 heslo\",\"Email not confirmed\":\"E-mail nebol potvrden\\xFD\",\"User not found\":\"Pou\\u017E\\xEDvate\\u013E nebol n\\xE1jden\\xFD\"}');\n  }, function(e, n, t) {\n    \"use strict\";\n    function r(e2) {\n      return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(e3) {\n        return typeof e3;\n      } : function(e3) {\n        return e3 && \"function\" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? \"symbol\" : typeof e3;\n      })(e2);\n    }\n    Object.defineProperty(n, \"__esModule\", { value: true }), n.default = void 0;\n    var o, i = t(0);\n    function M(e2, n2) {\n      if (!(e2 instanceof n2))\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function a(e2, n2) {\n      for (var t2 = 0; t2 < n2.length; t2++) {\n        var r2 = n2[t2];\n        r2.enumerable = r2.enumerable || false, r2.configurable = true, \"value\" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);\n      }\n    }\n    function u(e2, n2) {\n      return (u = Object.setPrototypeOf || function(e3, n3) {\n        return e3.__proto__ = n3, e3;\n      })(e2, n2);\n    }\n    function s(e2) {\n      var n2 = function() {\n        if (\"undefined\" == typeof Reflect || !Reflect.construct)\n          return false;\n        if (Reflect.construct.sham)\n          return false;\n        if (\"function\" == typeof Proxy)\n          return true;\n        try {\n          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {\n          })), true;\n        } catch (e3) {\n          return false;\n        }\n      }();\n      return function() {\n        var t2, r2 = l(e2);\n        if (n2) {\n          var o2 = l(this).constructor;\n          t2 = Reflect.construct(r2, arguments, o2);\n        } else\n          t2 = r2.apply(this, arguments);\n        return c(this, t2);\n      };\n    }\n    function c(e2, n2) {\n      return !n2 || \"object\" !== r(n2) && \"function\" != typeof n2 ? function(e3) {\n        if (void 0 === e3)\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return e3;\n      }(e2) : n2;\n    }\n    function l(e2) {\n      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {\n        return e3.__proto__ || Object.getPrototypeOf(e3);\n      })(e2);\n    }\n    var N = (0, t(2).connect)([\"store\"])(o = function(e2) {\n      !function(e3, n3) {\n        if (\"function\" != typeof n3 && null !== n3)\n          throw new TypeError(\"Super expression must either be null or a function\");\n        e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && u(e3, n3);\n      }(c2, e2);\n      var n2, t2, r2, o2 = s(c2);\n      function c2() {\n        var e3;\n        M(this, c2);\n        for (var n3 = arguments.length, t3 = new Array(n3), r3 = 0; r3 < n3; r3++)\n          t3[r3] = arguments[r3];\n        return (e3 = o2.call.apply(o2, [this].concat(t3))).handleSignup = function(n4) {\n          n4.preventDefault(), e3.props.store.openModal(\"signup\");\n        }, e3.handleLogin = function(n4) {\n          n4.preventDefault(), e3.props.store.openModal(\"login\");\n        }, e3.handleLogout = function(n4) {\n          n4.preventDefault(), e3.props.store.openModal(\"user\");\n        }, e3.handleButton = function(n4) {\n          n4.preventDefault(), e3.props.store.openModal(e3.props.store.user ? \"user\" : \"login\");\n        }, e3;\n      }\n      return n2 = c2, (t2 = [{ key: \"render\", value: function() {\n        var e3 = this.props.store, n3 = e3.user, t3 = e3.translate;\n        return \"button\" === this.props.mode ? (0, i.h)(\"a\", { className: \"netlify-identity-button\", href: \"#\", onClick: this.handleButton }, this.props.text || t3(n3 ? \"log_out\" : \"log_in\")) : n3 ? (0, i.h)(\"ul\", { className: \"netlify-identity-menu\" }, (0, i.h)(\"li\", { className: \"netlify-identity-item netlify-identity-user-details\" }, t3(\"logged_in_as\"), \" \", (0, i.h)(\"span\", { className: \"netlify-identity-user\" }, n3.user_metadata.name || n3.email)), (0, i.h)(\"li\", { className: \"netlify-identity-item\" }, (0, i.h)(\"a\", { className: \"netlify-identity-logout\", href: \"#\", onClick: this.handleLogout }, t3(\"log_out\")))) : (0, i.h)(\"ul\", { className: \"netlify-identity-menu\" }, (0, i.h)(\"li\", { className: \"netlify-identity-item\" }, (0, i.h)(\"a\", { className: \"netlify-identity-signup\", href: \"#\", onClick: this.handleSignup }, t3(\"sign_up\"))), (0, i.h)(\"li\", { className: \"netlify-identity-item\" }, (0, i.h)(\"a\", { className: \"netlify-identity-login\", href: \"#\", onClick: this.handleLogin }, t3(\"log_in\"))));\n      } }]) && a(n2.prototype, t2), r2 && a(n2, r2), c2;\n    }(i.Component)) || o;\n    n.default = N;\n  }, function(e, n, t) {\n    \"use strict\";\n    t.r(n);\n    var r = t(7), o = t.n(r)()(true);\n    o.push([e.i, '::-webkit-input-placeholder {\\n  /* Chrome/Opera/Safari */\\n  color: #a3a9ac;\\n  font-weight: 500;\\n}\\n\\n::-moz-placeholder {\\n  /* Firefox 19+ */\\n  color: #a3a9ac;\\n  font-weight: 500;\\n}\\n\\n:-ms-input-placeholder {\\n  /* IE 10+ */\\n  color: #a3a9ac;\\n  font-weight: 500;\\n}\\n\\n:-moz-placeholder {\\n  /* Firefox 18- */\\n  color: #a3a9ac;\\n  font-weight: 500;\\n}\\n\\n.modalContainer {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  min-height: 100%;\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  -webkit-box-sizing: border-box;\\n          box-sizing: border-box;\\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica,\\n    Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\\n  font-size: 14px;\\n  line-height: 1.5;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column;\\n  -webkit-box-align: center;\\n      -ms-flex-align: center;\\n          align-items: center;\\n  z-index: 99999;\\n}\\n\\n.modalContainer::before {\\n  content: \"\";\\n  display: block;\\n  position: fixed;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n  background-color: #fff;\\n  z-index: -1;\\n}\\n\\n.modalDialog {\\n  -webkit-box-flex: 1;\\n      -ms-flex-positive: 1;\\n          flex-grow: 1;\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  -webkit-box-orient: vertical;\\n  -webkit-box-direction: normal;\\n      -ms-flex-direction: column;\\n          flex-direction: column;\\n  width: 100%;\\n}\\n\\n.modalContent {\\n  position: relative;\\n  padding: 32px;\\n  opacity: 0;\\n  -webkit-transform: translateY(10px) scale(1);\\n          transform: translateY(10px) scale(1);\\n  background: #fff;\\n}\\n\\n[aria-hidden=\"false\"] .modalContent {\\n    -webkit-animation: bouncyEntrance 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);\\n            animation: bouncyEntrance 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);\\n    -webkit-animation-fill-mode: forwards;\\n            animation-fill-mode: forwards;\\n  }\\n\\n@-webkit-keyframes bouncyEntrance {\\n  0% {\\n    opacity: 0;\\n    -webkit-transform: translateY(10px) scale(0.9);\\n            transform: translateY(10px) scale(0.9);\\n  }\\n\\n  100% {\\n    opacity: 1;\\n    -webkit-transform: translateY(0) scale(1);\\n            transform: translateY(0) scale(1);\\n  }\\n}\\n\\n@keyframes bouncyEntrance {\\n  0% {\\n    opacity: 0;\\n    -webkit-transform: translateY(10px) scale(0.9);\\n            transform: translateY(10px) scale(0.9);\\n  }\\n\\n  100% {\\n    opacity: 1;\\n    -webkit-transform: translateY(0) scale(1);\\n            transform: translateY(0) scale(1);\\n  }\\n}\\n\\n@media (min-width: 480px) {\\n  .modalContainer::before {\\n    background-color: rgb(14, 30, 37);\\n    -webkit-animation: fadeIn 0.1s ease-in;\\n            animation: fadeIn 0.1s ease-in;\\n    -webkit-animation-fill-mode: forwards;\\n            animation-fill-mode: forwards;\\n  }\\n\\n  .modalDialog {\\n    max-width: 364px;\\n    -webkit-box-pack: center;\\n        -ms-flex-pack: center;\\n            justify-content: center;\\n  }\\n\\n  .modalContent {\\n    background: #fff;\\n    -webkit-box-shadow: 0 4px 12px 0 rgba(0, 0, 0, .07),\\n      0 12px 32px 0 rgba(14, 30, 37, .1);\\n            box-shadow: 0 4px 12px 0 rgba(0, 0, 0, .07),\\n      0 12px 32px 0 rgba(14, 30, 37, .1);\\n    border-radius: 8px;\\n    margin-top: 32px;\\n  }\\n}\\n\\n@-webkit-keyframes fadeIn {\\n  0% {\\n    opacity: 0;\\n  }\\n\\n  100% {\\n    opacity: 0.67;\\n  }\\n}\\n\\n@keyframes fadeIn {\\n  0% {\\n    opacity: 0;\\n  }\\n\\n  100% {\\n    opacity: 0.67;\\n  }\\n}\\n\\n.flashMessage {\\n  text-align: center;\\n  color: rgb(14, 30, 37);\\n  font-weight: 500;\\n  font-size: 14px;\\n  background-color: #f2f3f3;\\n  padding: 6px;\\n  border-radius: 4px;\\n  opacity: 0.7;\\n  -webkit-transition: opacity 0.2s linear;\\n  transition: opacity 0.2s linear;\\n}\\n\\n.flashMessage:hover,\\n.flashMessage:focus {\\n  opacity: 1;\\n}\\n\\n.error {\\n  color: #fa3946;\\n  background-color: #fceef0;\\n  opacity: 1;\\n}\\n\\n.error span::before {\\n  content: \"\";\\n  display: inline-block;\\n  position: relative;\\n  top: 3px;\\n  margin-right: 4px;\\n  width: 16px;\\n  height: 16px;\\n  background: no-repeat center center;\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICA8cGF0aCBmaWxsPSIjRkEzOTQ2IiBkPSJNOCwxLjMzMzMzMzMzIEMxMS42NzYsMS4zMzMzMzMzMyAxNC42NjY2NjY3LDQuMzI0IDE0LjY2NjY2NjcsOCBDMTQuNjY2NjY2NywxMS42NzYgMTEuNjc2LDE0LjY2NjY2NjcgOCwxNC42NjY2NjY3IEM0LjMyNCwxNC42NjY2NjY3IDEuMzMzMzMzMzMsMTEuNjc2IDEuMzMzMzMzMzMsOCBDMS4zMzMzMzMzMyw0LjMyNCA0LjMyNCwxLjMzMzMzMzMzIDgsMS4zMzMzMzMzMyBaIE04LDAgQzMuNTgyLDAgMCwzLjU4MiAwLDggQzAsMTIuNDE4IDMuNTgyLDE2IDgsMTYgQzEyLjQxOCwxNiAxNiwxMi40MTggMTYsOCBDMTYsMy41ODIgMTIuNDE4LDAgOCwwIFogTTcuMTI2NjY2NjcsNS4wMTczMzMzMyBDNy4wNjA2NjY2Nyw0LjQ3OTMzMzMzIDcuNDc4NjY2NjcsNCA4LjAyNTMzMzMzLDQgQzguNTM5MzMzMzMsNCA4Ljk0MzMzMzMzLDQuNDUwNjY2NjcgOC44Nzg2NjY2Nyw0Ljk2NzMzMzMzIEw4LjM3NCw5LjAwMjY2NjY3IEM4LjM1MDY2NjY3LDkuMTkxMzMzMzMgOC4xOSw5LjMzMzMzMzMzIDgsOS4zMzMzMzMzMyBDNy44MSw5LjMzMzMzMzMzIDcuNjQ5MzMzMzMsOS4xOTEzMzMzMyA3LjYyNTMzMzMzLDkuMDAyNjY2NjcgTDcuMTI2NjY2NjcsNS4wMTczMzMzMyBMNy4xMjY2NjY2Nyw1LjAxNzMzMzMzIFogTTgsMTIuMTY2NjY2NyBDNy41NCwxMi4xNjY2NjY3IDcuMTY2NjY2NjcsMTEuNzkzMzMzMyA3LjE2NjY2NjY3LDExLjMzMzMzMzMgQzcuMTY2NjY2NjcsMTAuODczMzMzMyA3LjU0LDEwLjUgOCwxMC41IEM4LjQ2LDEwLjUgOC44MzMzMzMzMywxMC44NzMzMzMzIDguODMzMzMzMzMsMTEuMzMzMzMzMyBDOC44MzMzMzMzMywxMS43OTMzMzMzIDguNDYsMTIuMTY2NjY2NyA4LDEyLjE2NjY2NjcgWiIvPgo8L3N2Zz4K);\\n}\\n\\n.success {\\n}\\n\\n.disabled {\\n  opacity: 0.38;\\n  pointer-events: none;\\n}\\n\\n.infoText {\\n  text-align: center;\\n  margin: 32px 0;\\n}\\n\\n.infoTextEmail {\\n  font-size: 16px;\\n  font-weight: 500;\\n}\\n\\n.saving {\\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAMAAACeYYN3AAAAxlBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////DTx3aAAAAQnRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEGgjKRfAAACk0lEQVR4AYXQDXP5WhAG8CUhiSQqSv4RRRMVL1Fa1VZf3PL9v9Tde9wc9M8+P8/M7s6czJiHgNIvVCJO6YiAMlAiWckASiQrm4bJMZTDrmbBIEC9qpgVjp6n4B+oyEwCzKrMQBVaQIlkpmXZln1dhQB+49gOh5dLexlV6MhsAqyazEQVugCqsOK5nsQmwPWZ53ucvyczSGb4l9T9OsdnLgFOXVZFFd4AqEKrIasR4AdBI2hw1GR6VzMwSWY2A60ZNDl6KnUC3KbMRhXeAqhCpyXzCAjarNVucdqXVEhWaRfCdsj5vQcE1EOZQ7Jy+EcUlklWi2Q3BLQ6nagTcTra2Y0qrHZirRN3OOezTUAjvq4bd7suqpDfSGJUoXcnCwiIerIqqlC96vf6HD1ZsUcE3PYH/QGnrx3uYnqoQn4l6aMK/XtZi4BuIrNIZqVJkiapkhx37Y6AcDgcpsNU44Nz3OuoQn4jSVGFNw+ykID+SGaTzM5G2YiTFVM73AMConE2zjhj7XAXs4EqHE/4d12GKgwmsoiAZCpzSObMptPZdHZVSkCc5/ksnym8cPRUmiQzpvNcmedzTl4o7qlBsuZc1iVg9ChDFdYWshEBveV/FssFZ/l7Z7eowsfl0/JJ4UXj43A/ogpbT7IeAZNnWQ1VuJJNCBi8HKxeVhw9tRaq8JkfrV/WHDULxb1CFbbX7HX9yllfck9A/ipzSea+yeYEJO+yEFX4tim8b94VXjj/zzdU4Z/NmY/NB+fkTglYfMg8knmfsiUBD1+yCFX4+X309f3FOds/UYVR8fH2e6vwovExIuB5K/NJ5v8jWxGQ/chiVOF2d+pn98M5zt3WJFm83+/2O4UXjprabkzAWn+o56k9qvBfX4hMaM+SxOMAAAAASUVORK5CYII=);\\n  background-repeat: repeat-x;\\n  background-size: contain;\\n  background-origin: border-box;\\n  background-position: 0% 0%;\\n  -webkit-animation: loading 20s linear infinite;\\n          animation: loading 20s linear infinite;\\n  pointer-events: none;\\n}\\n\\n.saving::after {\\n  content: \"\\u2026\";\\n}\\n\\n@-webkit-keyframes loading {\\n  0% {\\n    background-position: 0% 0%;\\n  }\\n\\n  100% {\\n    background-position: 700% 0%;\\n  }\\n}\\n\\n@keyframes loading {\\n  0% {\\n    background-position: 0% 0%;\\n  }\\n\\n  100% {\\n    background-position: 700% 0%;\\n  }\\n}\\n\\n.btn {\\n  display: block;\\n  position: relative;\\n  width: 100%;\\n  height: auto;\\n  margin: 14px 0 0;\\n  padding: 6px;\\n  outline: 0;\\n  cursor: pointer;\\n  border: 2px solid rgb(14, 30, 37);\\n  border-radius: 4px;\\n  background-color: #2d3b41;\\n  color: #fff;\\n  -webkit-transition: background-color 0.2s ease;\\n  transition: background-color 0.2s ease;\\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica,\\n    Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\\n  font-size: 14px;\\n  font-weight: 500;\\n  line-height: 24px;\\n  text-align: center;\\n  text-decoration: none;\\n  white-space: nowrap;\\n}\\n\\n.btn:hover,\\n.btn:focus {\\n  background-color: rgb(14, 30, 37);\\n  text-decoration: none;\\n}\\n\\n.btnClose {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  margin: 0;\\n  padding: 0;\\n  border: 0;\\n  width: 24px;\\n  height: 24px;\\n  border-radius: 50%;\\n  margin: 6px;\\n  background: #fff;\\n  color: #a3a9ac;\\n}\\n\\n.btnClose::before {\\n  content: \"\\xD7\";\\n  font-size: 25px;\\n  line-height: 9px;\\n}\\n\\n.btnClose:hover,\\n.btnClose:focus {\\n  background: #e9ebeb;\\n  color: rgb(14, 30, 37);\\n}\\n\\n.header {\\n  display: -webkit-box;\\n  display: -ms-flexbox;\\n  display: flex;\\n  margin-top: -8px;\\n  margin-bottom: 32px;\\n}\\n\\n.btnHeader {\\n  font-size: 16px;\\n  line-height: 24px;\\n  background: #fff;\\n  color: #a3a9ac;\\n  border: 0;\\n  border-bottom: 2px solid #e9ebeb;\\n  border-radius: 4px 4px 0 0;\\n  margin: 0;\\n}\\n\\n.btnHeader:focus,\\n.btnHeader.active {\\n  background: #fff;\\n  color: rgb(14, 30, 37);\\n  border-color: rgb(14, 30, 37);\\n  font-weight: 700;\\n}\\n\\n.btnHeader:not(:only-child):hover {\\n  background-color: #e9ebeb;\\n  color: rgb(14, 30, 37);\\n}\\n\\n.btnHeader:only-child {\\n  cursor: auto;\\n}\\n\\n.btnLink {\\n  display: block;\\n  position: relative;\\n  width: auto;\\n  height: auto;\\n  margin: 14px auto 0;\\n  padding: 6px;\\n  padding-bottom: 0;\\n  outline: 0;\\n  cursor: pointer;\\n  color: rgb(14, 30, 37);\\n  border: none;\\n  border-bottom: 2px solid #e9ebeb;\\n  border-radius: 0;\\n  background-color: inherit;\\n  -webkit-transition: border-color 0.2s ease;\\n  transition: border-color 0.2s ease;\\n  font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica,\\n    Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\\n  font-size: 14px;\\n  font-weight: 500;\\n  line-height: 24px;\\n  text-align: center;\\n  white-space: nowrap;\\n}\\n\\n.btnLink:hover,\\n.btnLink:focus {\\n  background-color: inherit;\\n  border-color: #a3a9ac;\\n}\\n\\n.form {\\n}\\n\\n.formGroup {\\n  position: relative;\\n  margin-top: 14px;\\n}\\n\\n.formControl {\\n  -webkit-box-sizing: border-box;\\n          box-sizing: border-box;\\n  display: block;\\n  width: 100%;\\n  height: 40px;\\n  margin: 0;\\n  padding: 6px 12px 6px 34px;\\n  border: 2px solid #e9ebeb;\\n  border-radius: 4px;\\n  background: #fff;\\n  color: rgb(14, 30, 37);\\n  -webkit-box-shadow: none;\\n          box-shadow: none;\\n  font-size: 16px;\\n  font-weight: 500;\\n  line-height: 24px;\\n  -webkit-transition: -webkit-box-shadow ease-in-out 0.15s;\\n  transition: -webkit-box-shadow ease-in-out 0.15s;\\n  transition: box-shadow ease-in-out 0.15s;\\n  transition: box-shadow ease-in-out 0.15s, -webkit-box-shadow ease-in-out 0.15s;\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n}\\n\\n.inputFieldIcon {\\n  position: absolute;\\n  top: 12px;\\n  left: 12px;\\n  display: inline-block;\\n  width: 16px;\\n  height: 16px;\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  pointer-events: none;\\n}\\n\\n.inputFieldName {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSIxNCIgdmlld0JveD0iMCAwIDE0IDE0Ij4gIDxwYXRoIGZpbGw9IiNBM0E5QUMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTgsNyBDNi4zNDMxNDU3NSw3IDUsNS42NTY4NTQyNSA1LDQgQzUsMi4zNDMxNDU3NSA2LjM0MzE0NTc1LDEgOCwxIEM5LjY1Njg1NDI1LDEgMTEsMi4zNDMxNDU3NSAxMSw0IEMxMSw1LjY1Njg1NDI1IDkuNjU2ODU0MjUsNyA4LDcgWiBNOCwxNSBMMS41LDE1IEMxLjUsMTEuMTM0MDA2OCA0LjQxMDE0OTEzLDggOCw4IEMxMS41ODk4NTA5LDggMTQuNSwxMS4xMzQwMDY4IDE0LjUsMTUgTDgsMTUgWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEgLTEpIi8+PC9zdmc+);\\n}\\n\\n.inputFieldEmail {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxMSIgdmlld0JveD0iMCAwIDE2IDExIj4gIDxwYXRoIGZpbGw9IiNBM0E5QUMiIGQ9Ik0xLjE3MDczMTcxLDMgQzAuNTIyMTQ2MzQxLDMgMy45MDI0NTk4N2UtMDgsMy41NDUxMTA4MSAzLjkwMjQ1OTg3ZS0wOCw0LjIyMjIyMTU0IEwzLjkwMjQ1OTg3ZS0wOCwxMi43Nzc3Nzg1IEMzLjkwMjQ1OTg3ZS0wOCwxMy40NTQ4ODkyIDAuNTIyMTQ2MzQxLDE0IDEuMTcwNzMxNzEsMTQgTDE0LjgyOTI2ODMsMTQgQzE1LjQ3Nzg1MzcsMTQgMTYsMTMuNDU0ODg5MiAxNiwxMi43Nzc3Nzg1IEwxNiw0LjIyMjIyMTU0IEMxNiwzLjU0NTExMDgxIDE1LjQ3Nzg1MzcsMyAxNC44MjkyNjgzLDMgTDEuMTcwNzMxNzEsMyBaIE0yLjMzNzQyMTE5LDUuMDAxODY1NjYgQzIuNDU3NTExNzUsNC45ODk1NTIxNCAyLjU2MDcxNDU3LDUuMDM5MzM5OCAyLjYzNjM1OTg1LDUuMTE3Mjg0MzcgTDcuNDgyNjA2MTcsMTAuMTEzMjU0NSBDNy43ODQ0ODgyMiwxMC40MjQ3NDU1IDguMjAzMjc4MjksMTAuNDI0NzY2IDguNTA1ODk2MTksMTAuMTEzMjU0NSBMMTMuMzYzNjQwMiw1LjExNzI4NDM3IEMxMy41MDUxMjU1LDQuOTcxMjA0OTkgMTMuNzUyOTc3OSw0Ljk4MTg5NzIzIDEzLjg4MzkyMjIsNS4xMzk3MzYwMiBDMTQuMDE0ODY2NSw1LjI5NzU3NDgxIDE0LjAwNTI4MjEsNS41NzQwNzQ4OCAxMy44NjM3OTY3LDUuNzIwMTU0MjYgTDExLjExNTg2MDYsOC41NDg0MTE1MiBMMTMuODU4MDU3MSwxMS4yNjc2NDY5IEMxNC4wMjE3ODM1LDExLjQwMzE5ODIgMTQuMDQ4OTM2MywxMS43MDE0OTMyIDEzLjkxMjk4ODIsMTEuODcwOTg4OCBDMTMuNzc3MDQwMSwxMi4wNDA1MDQ5IDEzLjUwODI4OTcsMTIuMDQzNDE5MSAxMy4zNjkzOTgyLDExLjg3Njk0MDQgTDEwLjU3NTQ3MTUsOS4xMDYzOTg2MiBMOS4wMDYwNTI3NSwxMC43MTYxMjQ0IEM4LjQzNDk0MTk1LDExLjMwNDAzMzQgNy41NTMzMDI4NiwxMS4zMDUxNjIxIDYuOTgyNDY4LDEwLjcxNjEyNDQgTDUuNDI0NTI4NSw5LjEwNjM5ODYyIEwyLjYzMDYwMTgzLDExLjg3Njk0MDQgQzIuNDkxNzEwMzMsMTIuMDQzNDM5NyAyLjIyMjk1OTg4LDEyLjA0MDUyNTUgMi4wODcwMTE3OCwxMS44NzA5ODg4IEMxLjk1MTA2MzY3LDExLjcwMTQ5MzIgMS45NzgyMTY1LDExLjQwMzE5ODIgMi4xNDE5NDI5LDExLjI2NzY0NjkgTDQuODg0MTM5MzksOC41NDg0MTE1MiBMMi4xMzYyMDMyOCw1LjcyMDE1NDI2IEMyLjAyODcxNDE0LDUuNjE2MjI4MTYgMS45ODM1NTE0MSw1LjQzODk1NDUzIDIuMDI1OTkxNSw1LjI4NzQ5ODI1IEMyLjA2ODQxMzE5LDUuMTM2MDYyNDkgMi4xOTYwMjc4MSw1LjAxOTAyMjQ5IDIuMzM3NDIxMTksNS4wMDE4NjU2NiBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIC0zKSIvPjwvc3ZnPg==);\\n}\\n\\n.inputFieldPassword {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxNCIgdmlld0JveD0iMCAwIDEyIDE0Ij4gIDxwYXRoIGZpbGw9IiNBM0E5QUMiIGQ9Ik0yLjQ0NTkxMDQ1LDMuNjQzMDg0MjcgQzIuNDQ1OTEwMzgsMi42NzY2MjEzNyAyLjgxODk3NTQ2LDEuNzQ5NzYzOTMgMy40ODI5OTUxOCwxLjA2NjUxMDUyIEM0LjE0NzAxNDksMC4zODMyNTcxMTEgNS4wNDc1NjY0MywtMC4wMDAzOTMwNDg2MTggNS45ODY0NDEwNSwzLjAyMTc0MDY5ZS0wNyBMNi4xMTc1MTg0NywzLjAyMTc0MDY5ZS0wNyBDOC4wNjkyOTIwNSwwLjAwMjQ1Mjc4Mzg0IDkuNjUwNzAwMTMsMS42MzA5OTI4MyA5LjY1MjI4NzQyLDMuNjQwMTE4NzkgTDkuNjUyMjg3NDIsNC42NzgwMzQ0NSBDOS4xMzk1MDEwNSw0LjcwMzI0MDk4IDguNjM2Nzk3NTYsNC43NDYyNDAzNCA4LjEzMTIxMzI1LDQuODAxMTAxNiBMOC4xMzEyMTMyNSwzLjY0MzA4NDI3IEM4LjEzMTIxMzI1LDIuNDk2NjM0MjkgNy4yMjgzNjE2LDEuNTY3MjUyOTUgNi4xMTQ2Mzc2NCwxLjU2NzI1Mjk1IEw1Ljk4MzU2MDIzLDEuNTY3MjUyOTUgQzQuODY5ODM2MjgsMS41NjcyNTI5NSAzLjk2Njk4NDYyLDIuNDk2NjM0MjkgMy45NjY5ODQ2MiwzLjY0MzA4NDI3IEwzLjk2Njk4NDYyLDMuOTYwMzg5OTEgQzMuOTY3NTc5ODgsNC4zNTY0OTE4MiAzLjY3NzAzNTY1LDQuNjg4ODc1OTUgMy4yOTQzMTI2Miw0LjcyOTkzMDI0IEwzLjI3ODQ2ODEsNC43Mjk5MzAyNCBDMy4wNjYyNDA5Miw0Ljc1MzUwMjk2IDIuODU0MjgyODcsNC42ODMxMDg3IDIuNjk1NDU2MTMsNC41MzYzMDM3NiBDMi41MzY2Mjk0LDQuMzg5NDk4ODIgMi40NDU5MDUzMyw0LjE4MDEyMTMzIDIuNDQ1OTEwNDUsMy45NjAzODk5MSBMMi40NDU5MTA0NSwzLjY0MzA4NDI3IFogTTExLjQxNjY2Niw3LjExNTY1MzUyIEwxMS40MTY2NjYsMTIuNjkwNzQzMyBDMTEuNDE3MDQwOCwxMy4wODMxMTQzIDExLjE0NTkyMDMsMTMuNDIwMTM3MSAxMC43NzEzNjE4LDEzLjQ5MjkwMzkgTDEwLjI5MDI2NDQsMTMuNTg2MzE2MyBDOC44NzYwNzU2NCwxMy44NjE1OTU5IDcuNDM5OTcxMzMsMTQuMDAwMDkzNyA2LjAwMDcyMDA1LDEzLjk5OTk5OTggQzQuNTYwOTg3NTgsMTQuMDAwMTg2MiAzLjEyNDM5Njg0LDEzLjg2MTY4OCAxLjcwOTczNTI0LDEzLjU4NjMxNjMgTDEuMjI4NjM3OTIsMTMuNDkyOTAzOSBDMC44NTQwNzk0MDcsMTMuNDIwMTM3MSAwLjU4Mjk1ODg2NywxMy4wODMxMTQzIDAuNTgzMzMzNzIyLDEyLjY5MDc0MzMgTDAuNTgzMzMzNzIyLDcuMTE1NjUzNTIgQzAuNTgyOTU4ODY3LDYuNzIzMjgyNTYgMC44NTQwNzk0MDcsNi4zODYyNTk4MSAxLjIyODYzNzkyLDYuMzEzNDkyOTkgTDEuMjk5MjE4MDYsNi4zMDAxNDgzNiBDNC40MDU5OTg0Nyw1LjY5NTEyMTY3IDcuNTk1NDQxNjIsNS42OTUxMjE2NyAxMC43MDIyMjIsNi4zMDAxNDgzNiBMMTAuNzcyODAyMiw2LjMxMzQ5Mjk5IEMxMS4xNDY3ODgsNi4zODY4ODY0NSAxMS40MTcxNzE2LDYuNzIzNzQ1MTYgMTEuNDE2NjY2LDcuMTE1NjUzNTIgWiIvPjwvc3ZnPg==);\\n}\\n\\n.inputFieldUrl {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSIxNCIgdmlld0JveD0iMCAwIDE0IDE0Ij4gIDxwYXRoIGZpbGw9IiNBM0E5QUMiIGQ9Ik0xMCw1IEMxMCwzLjg5NTQzMDUgOS4xMDQ1Njk1LDMgOCwzIEM2Ljg5NTQzMDUsMyA2LDMuODk1NDMwNSA2LDUgTTQsMTAgTDQsMTEgTDYsMTEgTDYsMTAgQzYsOS40NDc3MTUyNSA1LjU1MjI4NDc1LDkgNSw5IEM0LjQ0NzcxNTI1LDkgNCw5LjQ0NzcxNTI1IDQsMTAgWiBNMTIsMTAgQzEyLDkuNDQ3NzE1MjUgMTEuNTUyMjg0Nyw5IDExLDkgQzEwLjQ0NzcxNTMsOSAxMCw5LjQ0NzcxNTI1IDEwLDEwIEwxMCwxMSBMMTIsMTEgTDEyLDEwIFogTTYsNiBMNiw1IEw0LDUgTDQsNiBDNCw2LjU1MjI4NDc1IDQuNDQ3NzE1MjUsNyA1LDcgQzUuNTUyMjg0NzUsNyA2LDYuNTUyMjg0NzUgNiw2IFogTTEwLDYgQzEwLDYuNTUyMjg0NzUgMTAuNDQ3NzE1Myw3IDExLDcgQzExLjU1MjI4NDcsNyAxMiw2LjU1MjI4NDc1IDEyLDYgTDEyLDUgTDEwLDUgTDEwLDYgWiBNNCw1IEM0LDIuNzkwODYxIDUuNzkwODYxLDEgOCwxIEMxMC4yMDkxMzksMSAxMiwyLjc5MDg2MSAxMiw1IEw0LDUgWiBNNCwxMSBMMTIsMTEgQzEyLDEzLjIwOTEzOSAxMC4yMDkxMzksMTUgOCwxNSBDNS43OTA4NjEsMTUgNCwxMy4yMDkxMzkgNCwxMSBaIE0xMCwxMSBMNiwxMSBDNiwxMi4xMDQ1Njk1IDYuODk1NDMwNSwxMyA4LDEzIEM5LjEwNDU2OTUsMTMgMTAsMTIuMTA0NTY5NSAxMCwxMSBaIE04LDExIEM3LjQ0NzcxNTI1LDExIDcsMTAuNTUyMjg0NyA3LDEwIEw3LDYgQzcsNS40NDc3MTUyNSA3LjQ0NzcxNTI1LDUgOCw1IEM4LjU1MjI4NDc1LDUgOSw1LjQ0NzcxNTI1IDksNiBMOSwxMCBDOSwxMC41NTIyODQ3IDguNTUyMjg0NzUsMTEgOCwxMSBaIiB0cmFuc2Zvcm09InJvdGF0ZSg0NSA4LjcwNyA2LjI5MykiLz48L3N2Zz4=);\\n}\\n\\n.formLabel {\\n}\\n\\n.hr {\\n  border: 0;\\n  border-top: 2px solid #e9ebeb;\\n  margin: 32px 0 -1px;\\n  text-align: center;\\n  overflow: visible;\\n}\\n\\n.hr::before {\\n  content: \"or\";\\n  position: relative;\\n  display: inline-block;\\n  font-size: 12px;\\n  font-weight: 800;\\n  line-height: 1;\\n  text-transform: uppercase;\\n  background-color: #fff;\\n  color: rgb(14, 30, 37);\\n  padding: 4px;\\n  top: -11px;\\n}\\n\\n.btnProvider {\\n  padding-left: 40px;\\n  padding-right: 40px;\\n}\\n\\n.btnProvider::before {\\n  content: \"\";\\n  position: absolute;\\n  display: inline-block;\\n  vertical-align: middle;\\n  width: 32px;\\n  height: 40px;\\n  background-repeat: no-repeat;\\n  background-position: left center;\\n  top: -2px;\\n  left: 14px;\\n}\\n\\n.providerGoogle {\\n  background-color: #4285f4;\\n  border-color: #366dc7;\\n}\\n\\n.providerGoogle:hover,\\n.providerGoogle:focus {\\n  background-color: #366dc7;\\n}\\n\\n.providerGitHub {\\n  background-color: #333;\\n  border-color: #000;\\n}\\n\\n.providerGitHub:hover,\\n.providerGitHub:focus {\\n  background-color: #000;\\n}\\n\\n.providerGitLab {\\n  background-color: #e24329;\\n  border-color: #b03320;\\n}\\n\\n.providerGitLab:hover,\\n.providerGitLab:focus {\\n  background-color: #b03320;\\n}\\n\\n.providerBitbucket {\\n  background-color: #205081;\\n  border-color: #14314f;\\n}\\n\\n.providerBitbucket:hover,\\n.providerBitbucket:focus {\\n  background-color: #14314f;\\n}\\n\\n.providerGoogle:before {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMyIgaGVpZ2h0PSIxMiIgdmlld0JveD0iMCAwIDEzIDEyIj4gIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEuNDg4IC0yKSI+ICAgIDxyZWN0IHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIvPiAgICA8cGF0aCBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik0wLjY1MjczNDM3NSwzLjI5NTI4MjQ0IEMwLjIzNzk4NDM3NSw0LjEwNTgzMjA2IDIuODQyMTcwOTRlLTE0LDUuMDE2MDQ1OCAyLjg0MjE3MDk0ZS0xNCw1Ljk3OTM4OTMxIEMyLjg0MjE3MDk0ZS0xNCw2Ljk0MjczMjgyIDAuMjM3OTg0Mzc1LDcuODUyOTAwNzYgMC42NTI3MzQzNzUsOC42NjM0NTAzOCBDMS42NTkwNDY4NywxMC42MTY3MDIzIDMuNzI2MDkzNzUsMTEuOTU4Nzc4NiA2LjExOTUzMTI1LDExLjk1ODc3ODYgQzcuNzcxNzgxMjUsMTEuOTU4Nzc4NiA5LjE1ODg1OTM3LDExLjQyNzI1MTkgMTAuMTcyMDE1NiwxMC41MTA0NDI3IEMxMS4zMjc5MDYyLDkuNDY3MzU4NzggMTEuOTk0MjgxMiw3LjkzMjY0MTIyIDExLjk5NDI4MTIsNi4xMTIyNTk1NCBDMTEuOTk0MjgxMiw1LjYyMDYyNTk1IDExLjk1MzQ1MzEsNS4yNjE4NjI2IDExLjg2NTA5MzcsNC44ODk4MTY3OSBMNi4xMTk1MzEyNSw0Ljg4OTgxNjc5IEw2LjExOTUzMTI1LDcuMTA4ODA5MTYgTDkuNDkyMDQ2ODcsNy4xMDg4MDkxNiBDOS40MjQwNzgxMiw3LjY2MDI1OTU0IDkuMDU2OTA2MjUsOC40OTA3MzI4MiA4LjI0MDk1MzEyLDkuMDQ4Nzc4NjMgQzcuNzI0MjAzMTIsOS40MDA5MDA3NiA3LjAzMDY0MDYyLDkuNjQ2NzE3NTYgNi4xMTk1MzEyNSw5LjY0NjcxNzU2IEM0LjUwMTI2NTYyLDkuNjQ2NzE3NTYgMy4xMjc3ODEyNSw4LjYwMzY3OTM5IDIuNjM4MTcxODcsNy4xNjE5ODQ3MyBMMi42Mjg3MTIwNSw3LjE2Mjc2OTU5IEMyLjUwNTM0MTU4LDYuNzk3Mjk0NjggMi40MzQyMTg3NSw2LjM4MTEyMjg1IDIuNDM0MjE4NzUsNS45NzkzODkzMSBDMi40MzQyMTg3NSw1LjU2NzQ1MDM4IDIuNTA4OTg0MzgsNS4xNjg4Mzk2OSAyLjYzMTM3NSw0Ljc5Njc5Mzg5IEMzLjEyNzc4MTI1LDMuMzU1MDk5MjQgNC41MDEyNjU2MiwyLjMxMjAxNTI3IDYuMTE5NTMxMjUsMi4zMTIwMTUyNyBDNy4yNjg2MjUsMi4zMTIwMTUyNyA4LjA0Mzc1LDIuNzk3MDA3NjMgOC40ODU3MzQzNywzLjIwMjMwNTM0IEwxMC4yMTI3OTY5LDEuNTU0NjQxMjIgQzkuMTUyMTA5MzcsMC41OTEyOTc3MSA3Ljc3MTc4MTI1LDguODgxNzg0MmUtMTYgNi4xMTk1MzEyNSw4Ljg4MTc4NDJlLTE2IEMzLjcyNjA5Mzc1LDguODgxNzg0MmUtMTYgMS42NTkwNDY4NywxLjM0MjAzMDUzIDAuNjUyNzM0Mzc1LDMuMjk1MjgyNDQgTDAuNjUyNzM0Mzc1LDMuMjk1MjgyNDQgWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiAyKSIvPiAgPC9nPjwvc3ZnPg==);\\n}\\n\\n.providerGitHub:before {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4gIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+ICAgIDxyZWN0IHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIvPiAgICA8cGF0aCBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik04LjAwMDA2NjI1LDAgQzMuNTgyMzMwNzksMCAwLDMuNjcyMzE1ODUgMCw4LjIwMjUzNzczIEMwLDExLjgyNjYzMzggMi4yOTIyNjI0OCwxNC45MDEyOTUgNS40NzA5MzM1NiwxNS45ODU5MDIzIEM1Ljg3MDc1MTM5LDE2LjA2MTgzMTUgNi4wMTc1MzY3NSwxNS44MDc5NjQyIDYuMDE3NTM2NzUsMTUuNTkxMzE0NCBDNi4wMTc1MzY3NSwxNS4zOTU3MTgzIDYuMDEwMTE3OTksMTQuNzQ5NTcyMiA2LjAwNjY3MzU2LDE0LjA2NDE3MTEgQzMuNzgxMDQ3NDEsMTQuNTYwMzYwMiAzLjMxMTQxMzc5LDEzLjA5NjM3ODEgMy4zMTE0MTM3OSwxMy4wOTYzNzgxIEMyLjk0NzQ5NzQsMTIuMTQ4MjgwNiAyLjQyMzE1MDUsMTEuODk2MTc5IDIuNDIzMTUwNSwxMS44OTYxNzkgQzEuNjk3MzA0OTEsMTEuMzg3MDg2IDIuNDc3ODYzNzksMTEuMzk3NTQ0OSAyLjQ3Nzg2Mzc5LDExLjM5NzU0NDkgQzMuMjgxMjA4ODcsMTEuNDU1NDA4NyAzLjcwNDIxMDMxLDEyLjI0MjgxODcgMy43MDQyMTAzMSwxMi4yNDI4MTg3IEM0LjQxNzczNTQ3LDEzLjQ5NjgwNjcgNS41NzU3MjM0NiwxMy4xMzQyNzQ4IDYuMDMyMjQxNzgsMTIuOTI0Njg4MiBDNi4xMDQwNDQ3MiwxMi4zOTQ1NDE0IDYuMzExMzcyNDQsMTIuMDMyNjg4NyA2LjU0MDE2MTQ0LDExLjgyNzg1NjIgQzQuNzYzMjM3NDQsMTEuNjIwNDQyOCAyLjg5NTMwMTE5LDEwLjkxNzExMjEgMi44OTUzMDExOSw3Ljc3NDEyNzk5IEMyLjg5NTMwMTE5LDYuODc4NTk2ODggMy4yMDc4MTYxOCw2LjE0Njg3NzU3IDMuNzE5NTc3NzMsNS41NzI0NDk5OSBDMy42MzY1MTQxNyw1LjM2NTg1MTY2IDMuMzYyNjgyNjgsNC41MzE1ODAxNyAzLjc5NzA3NzIxLDMuNDAxNzQxMzMgQzMuNzk3MDc3MjEsMy40MDE3NDEzMyA0LjQ2ODg3MTg4LDMuMTgxMjg4MjcgNS45OTc2NjUwNyw0LjI0MjUzMjY3IEM2LjYzNTgxMDQ0LDQuMDYwNzkxMzQgNy4zMjAxOTA0NCwzLjk2OTY0OTAyIDguMDAwMDY2MjUsMy45NjY1MjQ5MiBDOC42Nzk5NDIwNiwzLjk2OTY0OTAyIDkuMzY0ODUyLDQuMDYwNzkxMzQgMTAuMDA0MTg5Niw0LjI0MjUzMjY3IEMxMS41MzExMjgxLDMuMTgxMjg4MjcgMTIuMjAxOTk1NCwzLjQwMTc0MTMzIDEyLjIwMTk5NTQsMy40MDE3NDEzMyBDMTIuNjM3NDQ5OCw0LjUzMTU4MDE3IDEyLjM2MzQ4NTgsNS4zNjU4NTE2NiAxMi4yODA0MjIzLDUuNTcyNDQ5OTkgQzEyLjc5MzM3NjEsNi4xNDY4Nzc1NyAxMy4xMDM3NzE0LDYuODc4NTk2ODggMTMuMTAzNzcxNCw3Ljc3NDEyNzk5IEMxMy4xMDM3NzE0LDEwLjkyNDU4MjggMTEuMjMyMjU4MywxMS42MTgyNjk2IDkuNDUwODMwMDYsMTEuODIxMzM2MyBDOS43Mzc3NzY4NywxMi4wNzU4ODI5IDkuOTkzNDU4ODcsMTIuNTc1MDYwMiA5Ljk5MzQ1ODg3LDEzLjM0MDMyOTggQzkuOTkzNDU4ODcsMTQuNDM3ODQxMSA5Ljk4NDE4NTUsMTUuMzIxMTQ3MyA5Ljk4NDE4NTUsMTUuNTkxMzE0NCBDOS45ODQxODU1LDE1LjgwOTU5NDIgMTAuMTI4MTg4NywxNi4wNjUzNjMxIDEwLjUzMzcwMzEsMTUuOTg0ODE1NiBDMTMuNzEwNjUyLDE0Ljg5ODk4NTggMTYsMTEuODI1NDExMyAxNiw4LjIwMjUzNzczIEMxNiwzLjY3MjMxNTg1IDEyLjQxODE5OTIsMCA4LjAwMDA2NjI1LDAgWiBNMi45OTYyODQ5NiwxMS42ODQ2ODgyIEMyLjk3ODY2NTQxLDExLjcyNTQzNzMgMi45MTYxMzU5MSwxMS43Mzc2NjIxIDIuODU5MTcwNDgsMTEuNzA5NjgxIEMyLjgwMTE0NTIyLDExLjY4MjkyMjMgMi43Njg1NTU3MSwxMS42MjczNjc2IDIuNzg3MzY3NTUsMTEuNTg2NDgyNyBDMi44MDQ1ODk2NSwxMS41NDQ1MTEgMi44NjcyNTE2MiwxMS41MzI4Mjk1IDIuOTI1MTQ0MzksMTEuNTYwOTQ2NSBDMi45ODMzMDIxNCwxMS41ODc3MDUxIDMuMDE2NDIxNTcsMTEuNjQzODAzMSAyLjk5NjI4NDk2LDExLjY4NDY4ODIgWiBNMy4zODk3OTkzMiwxMi4wNDQ3MDI0IEMzLjM1MTY0NTc0LDEyLjA4MDk2OTEgMy4yNzcwNjA3NywxMi4wNjQxMjYxIDMuMjI2NDU0MjYsMTIuMDA2ODA1NyBDMy4xNzQxMjU1NSwxMS45NDk2MjEgMy4xNjQzMjIyMSwxMS44NzMxNDg0IDMuMjAzMDA1NywxMS44MzYzMzgyIEMzLjI0MjM1MTU5LDExLjgwMDA3MTUgMy4zMTQ2ODQ0NSwxMS44MTcwNTAzIDMuMzY3MTQ1NjQsMTEuODc0MjM1IEMzLjQxOTQ3NDMyLDExLjkzMjA5ODggMy40Mjk2NzUxMiwxMi4wMDgwMjgxIDMuMzg5Nzk5MzIsMTIuMDQ0NzAyNCBaIE0zLjY1OTc2NTA4LDEyLjUwNTMyODMgQzMuNjEwNzQ4MzMsMTIuNTQwMjM2OCAzLjUzMDU5OTI5LDEyLjUwNzUwMTUgMy40ODEwNTI2MSwxMi40MzQ1NjA2IEMzLjQzMjAzNTgzLDEyLjM2MTYxOTUgMy40MzIwMzU4MywxMi4yNzQxNDQ2IDMuNDgyMTEyNDQsMTIuMjM5MTAwMyBDMy41MzE3OTE1NywxMi4yMDQwNTYgMy42MTA3NDgzMywxMi4yMzU1Njg4IDMuNjYwOTU3MzgsMTIuMzA3OTY2NSBDMy43MDk4NDE2OCwxMi4zODIxMjk5IDMuNzA5ODQxNjgsMTIuNDY5NjA0OCAzLjY1OTc2NTA4LDEyLjUwNTMyODMgWiBNNC4xMTYzMzQ5NSwxMy4wMzg3OTgxIEM0LjA3MjQ4NDgyLDEzLjA4ODM3NjQgMy45NzkwODgwMiwxMy4wNzUwNjUgMy45MTA3Mjk0OCwxMy4wMDc0MjE0IEMzLjg0MDc4MTI0LDEyLjk0MTI3MTggMy44MjEzMDcwMSwxMi44NDc0MTI5IDMuODY1Mjg5NjMsMTIuNzk3ODM0NyBDMy45MDk2Njk2NiwxMi43NDgxMjA3IDQuMDAzNTk2MzksMTIuNzYyMTExMyA0LjA3MjQ4NDgyLDEyLjgyOTIxMTYgQzQuMTQxOTAzMTYsMTIuODk1MjI1MyA0LjE2MzA5OTYsMTIuOTg5NzYzNCA0LjExNjMzNDk1LDEzLjAzODc5ODEgWiBNNC43MDY0MDcxOSwxMy4yMTg4OTE2IEM0LjY4NzA2NTQ2LDEzLjI4MzEzOTUgNC41OTcxMTMwNiwxMy4zMTIzNDMgNC41MDY0OTgyNywxMy4yODUwNDExIEM0LjQxNjAxNTk3LDEzLjI1NjkyNDIgNC4zNTY3OTg0MiwxMy4xODE2NzQxIDQuMzc1MDgwMzYsMTMuMTE2NzQ3IEM0LjM5Mzg5MjE5LDEzLjA1MjA5MTcgNC40ODQyNDIwMSwxMy4wMjE2NjU2IDQuNTc1NTE5MTgsMTMuMDUwODY5MiBDNC42NjU4NjkwMSwxMy4wNzg4NTAzIDQuNzI1MjE5MDUsMTMuMTUzNTU3MSA0LjcwNjQwNzE5LDEzLjIxODg5MTYgWiBNNS4zNzc5MzQxOSwxMy4yOTUyODI1IEM1LjM4MDE4NjI5LDEzLjM2MjkyNjEgNS4zMDMzNDkxOSwxMy40MTkwMjQxIDUuMjA4MjMwMTgsMTMuNDIwMjQ2NyBDNS4xMTI1ODEyNSwxMy40MjI0MiA1LjAzNTIxNDI1LDEzLjM2NzY4MDMgNS4wMzQxNTQ0MiwxMy4zMDExMjMyIEM1LjAzNDE1NDQyLDEzLjIzMjgwMDUgNS4xMDkyNjkzLDEzLjE3NzI0NTggNS4yMDQ5MTgyMywxMy4xNzU2MTU4IEM1LjMwMDAzNzI2LDEzLjE3MzcxNDIgNS4zNzc5MzQxOSwxMy4yMjgwNDY0IDUuMzc3OTM0MTksMTMuMjk1MjgyNSBaIE02LjAzNzYzNDE5LDEzLjI2OTM1NDggQzYuMDQ5MDI3MjksMTMuMzM1MzY4NSA1Ljk4MjkyMDg4LDEzLjQwMzE0NzkgNS44ODg0NjQyNSwxMy40MjEyMTM0IEM1Ljc5NTU5NzM2LDEzLjQzODU5OTcgNS43MDk2MTkyOSwxMy4zOTc4NTA1IDUuNjk3ODI4NzcsMTMuMzMyMzgwMiBDNS42ODYzMDMyMiwxMy4yNjQ3MzY1IDUuNzUzNjAxOTEsMTMuMTk2OTU3MSA1Ljg0NjMzNjMzLDEzLjE3OTQzNSBDNS45NDA5MjU0NCwxMy4xNjI1OTIgNi4wMjU1Nzg3MiwxMy4yMDIyNTQ1IDYuMDM3NjM0MTksMTMuMjY5MzU0OCBaIi8+ICA8L2c+PC9zdmc+);\\n}\\n\\n.providerGitLab:before {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSIxMyIgdmlld0JveD0iMCAwIDE0IDEzIj4gIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEgLTIpIj4gICAgPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+ICAgIDxwYXRoIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0ibm9uemVybyIgZD0iTTcuMDA0MDkzMzYsMTIuOTQ5MjQzMyBMNC40MjgwOTMzMyw0Ljk5NzI4MjU0IEw5LjU4MDA5MzM2LDQuOTk3MjgyNTQgTDcuMDA0MDkzMzYsMTIuOTQ5MjQzMyBaIE03LjAwNDA5MzM2LDEyLjk0OTIzIEwwLjgxNzg5MzMzMyw0Ljk5NzI2OTE3IEw0LjQyODA5MzMzLDQuOTk3MjY5MTcgTDcuMDA0MDkzMzYsMTIuOTQ5MjMgWiBNMC44MTc4OTk5OTksNC45OTcyODkyMyBMNy4wMDQwOTk5OCwxMi45NDkyNSBMMC4yMjg4MzMzMzMsOC4wMTE4ODA4IEMwLjA0MTksNy44NzU2NzE1MiAtMC4wMzYzLDcuNjM0MjEyNyAwLjAzNTEsNy40MTM4MTcxMiBMMC44MTc4OTk5OTksNC45OTcyODkyMyBaIE0wLjgxNzg5OTk5OSw0Ljk5NzI5NTkxIEwyLjM2OTM2NjY3LDAuMjA3OTA0NzE0IEMyLjQ0OTE2NjY3LC0wLjAzODUwMjM1ODggMi43OTY3NjY2NywtMC4wMzg1NjkyMjY1IDIuODc2NTY2NjcsMC4yMDc5MDQ3MTQgTDQuNDI4MSw0Ljk5NzI5NTkxIEwwLjgxNzg5OTk5OSw0Ljk5NzI5NTkxIFogTTcuMDA0MDkzMzYsMTIuOTQ5MjMgTDkuNTgwMDkzMzYsNC45OTcyNjkxNyBMMTMuMTkwMjkzMyw0Ljk5NzI2OTE3IEw3LjAwNDA5MzM2LDEyLjk0OTIzIFogTTEzLjE5MDI5MzMsNC45OTcyODkyMyBMMTMuOTczMDkzMyw3LjQxMzgxNzEyIEMxNC4wNDQ0OTMzLDcuNjM0MjEyNyAxMy45NjYyOTM0LDcuODc1NjcxNTIgMTMuNzc5MzYsOC4wMTE4ODA4IEw3LjAwNDA5MzM2LDEyLjk0OTI1IEwxMy4xOTAyOTMzLDQuOTk3Mjg5MjMgWiBNMTMuMTkwMjkzMyw0Ljk5NzI5NTkxIEw5LjU4MDA5MzM2LDQuOTk3Mjk1OTEgTDExLjEzMTYyNjcsMC4yMDc5MDQ3MTQgQzExLjIxMTQyNjcsLTAuMDM4NTY5MjI2NSAxMS41NTkwMjY3LC0wLjAzODUwMjM1ODggMTEuNjM4ODI2NywwLjIwNzkwNDcxNCBMMTMuMTkwMjkzMyw0Ljk5NzI5NTkxIFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEgMikiLz4gIDwvZz48L3N2Zz4=);\\n}\\n\\n.providerBitbucket:before {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE0IDE2Ij4gIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEpIj4gICAgPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+ICAgIDxnIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0ibm9uemVybyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMSkiPiAgICAgIDxwYXRoIGQ9Ik03LDIuNDk4OTQxODdlLTA3IEw3LDIuNDk4OTQxODdlLTA3IEMzLjE1NzIxMjI5LDIuNDk4OTQxODdlLTA3IDAuMDAwNjM2NTM1NDM1LDEuMDIwODQ0MjQgMC4wMDA2MzY1MzU0MzUsMi4zMTM5MTM1OSBDMC4wMDA2MzY1MzU0MzUsMi42NTQxOTUxMyAwLjgyNDA5MTAyMyw3LjQ4NjE5MiAxLjE2NzE5NzE3LDkuMzkxNzY3NTkgQzEuMzA0NDM5MzcsMTAuMjc2NDk5OSAzLjU2ODkzOTUzLDExLjUwMTUxMyA3LDExLjUwMTUxMyBMNywxMS41MDE1MTMgQzEwLjQzMTA2MDIsMTEuNTAxNTEzIDEyLjYyNjkzODYsMTAuMjc2NDk5OSAxMi44MzI4MDMyLDkuMzkxNzY3NTkgQzEzLjE3NTkwODYsNy40ODYxOTIgMTMuOTk5MzYzMiwyLjY1NDE5NTEzIDEzLjk5OTM2MzIsMi4zMTM5MTM1OSBDMTMuOTMwNzQyMSwxLjAyMDg0NDI0IDEwLjg0Mjc4NzQsMi40OTg5NDE4N2UtMDcgNywyLjQ5ODk0MTg3ZS0wNyBMNywyLjQ5ODk0MTg3ZS0wNyBaIE03LDkuOTM2MjE4MzEgQzUuNzY0ODE4MjgsOS45MzYyMTgzMSA0LjgwNDEyMTI2LDguOTgzNDI5ODYgNC44MDQxMjEyNiw3Ljc1ODQxNjcxIEM0LjgwNDEyMTI2LDYuNTMzNDAzNTUgNS43NjQ4MTgyOCw1LjU4MDYxNTk3IDcsNS41ODA2MTU5NyBDOC4yMzUxODExMiw1LjU4MDYxNTk3IDkuMTk1ODc4NCw2LjUzMzQwMzU1IDkuMTk1ODc4NCw3Ljc1ODQxNjcxIEM5LjE5NTg3ODQsOC45MTUzNzM3MiA4LjIzNTE4MTEyLDkuOTM2MjE4MzEgNyw5LjkzNjIxODMxIEw3LDkuOTM2MjE4MzEgWiBNNywyLjk5NDQ3NjY3IEM0LjUyOTYzNjIyLDIuOTk0NDc2NjcgMi41Mzk2MjExLDIuNTg2MTM4OTUgMi41Mzk2MjExLDIuMDQxNjg4ODYgQzIuNTM5NjIxMSwxLjQ5NzIzODE1IDQuNTI5NjM2MjIsMS4wODg5MDA0MyA3LDEuMDg4OTAwNDMgQzkuNDcwMzYyODQsMS4wODg5MDA0MyAxMS40NjAzNzg2LDEuNDk3MjM4MTUgMTEuNDYwMzc4NiwyLjA0MTY4ODg2IEMxMS40NjAzNzg2LDIuNTg2MTM4OTUgOS40NzAzNjI4NCwyLjk5NDQ3NjY3IDcsMi45OTQ0NzY2NyBMNywyLjk5NDQ3NjY3IFoiLz4gICAgICA8cGF0aCBkPSJNMTIuMDY0NTA5NiwxMS4yMjkyODc2IEMxMS45MjcyNjY3LDExLjIyOTI4NzYgMTEuODU4NjQ1NywxMS4yOTczNDM4IDExLjg1ODY0NTcsMTEuMjk3MzQzOCBDMTEuODU4NjQ1NywxMS4yOTczNDM4IDEwLjE0MzExNTYsMTIuNjU4NDcgNy4wNTUxNjA5MywxMi42NTg0NyBDMy45NjcyMDY4NywxMi42NTg0NyAyLjI1MTY3NjE2LDExLjI5NzM0MzggMi4yNTE2NzYxNiwxMS4yOTczNDM4IEMyLjI1MTY3NjE2LDExLjI5NzM0MzggMi4xMTQ0MzM5NSwxMS4yMjkyODc2IDIuMDQ1ODEyODUsMTEuMjI5Mjg3NiBDMS45MDg1NzAwMiwxMS4yMjkyODc2IDEuNzcxMzI3ODEsMTEuMjk3MzQzOCAxLjc3MTMyNzgxLDExLjUwMTUxMyBMMS43NzEzMjc4MSwxMS41Njk1NjkyIEMyLjA0NTgxMjg1LDEyLjk5ODc1MTYgMi4yNTE2NzYxNiwxNC4wMTk1OTU2IDIuMjUxNjc2MTYsMTQuMTU1NzA3OSBDMi40NTc1NDAwOSwxNS4xNzY1NTI1IDQuNTE2MTc2MzIsMTUuOTkzMjI4IDYuOTg2NTM5ODIsMTUuOTkzMjI4IEw2Ljk4NjUzOTgyLDE1Ljk5MzIyOCBDOS40NTY5MDMzMSwxNS45OTMyMjggMTEuNTE1NTM5NSwxNS4xNzY1NTI1IDExLjcyMTQwMzUsMTQuMTU1NzA3OSBDMTEuNzIxNDAzNSwxNC4wMTk1OTU2IDExLjkyNzI2NjcsMTIuOTk4NzUxNiAxMi4yMDE3NTE4LDExLjU2OTU2OTIgTDEyLjIwMTc1MTgsMTEuNTAxNTEzIEMxMi4yNzAzNzI5LDExLjM2NTQgMTIuMjAxNzUxOCwxMS4yMjkyODc2IDEyLjA2NDUwOTYsMTEuMjI5Mjg3NiBMMTIuMDY0NTA5NiwxMS4yMjkyODc2IFoiLz4gICAgICA8ZWxsaXBzZSBjeD0iNyIgY3k9IjcuNjkiIHJ4PSIxLjA5OCIgcnk9IjEuMDg5Ii8+ICAgIDwvZz4gIDwvZz48L3N2Zz4=);\\n}\\n\\n.callOut {\\n  display: block;\\n  padding: 32px;\\n  font-size: 14px;\\n  font-weight: 500;\\n  text-decoration: none;\\n  color: #a3a9ac;\\n  text-align: center;\\n}\\n\\n.callOut:after {\\n  content: \" \\u2665\";\\n  -webkit-transition: color 4s ease;\\n  transition: color 4s ease;\\n}\\n\\n.callOut:hover:after {\\n  color: red;\\n}\\n\\n.callOut .netlifyLogo {\\n  display: block;\\n  margin: auto;\\n  width: 32px;\\n  height: 32px;\\n  margin-bottom: 8px;\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIj4gIDxkZWZzPiAgICA8cmFkaWFsR3JhZGllbnQgaWQ9ImEiIGN5PSIwJSIgcj0iMTAwJSIgZng9IjUwJSIgZnk9IjAlIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDAgMSAtMS4xNTE4NSAwIC41IC0uNSkiPiAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiMyMEM2QjciIG9mZnNldD0iMCUiLz4gICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjNEQ5QUJGIiBvZmZzZXQ9IjEwMCUiLz4gICAgPC9yYWRpYWxHcmFkaWVudD4gIDwvZGVmcz4gIDxwYXRoIGZpbGw9InVybCgjYSkiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTIyLjk4MDYyMywxMS42MjYyMzc3IEMyMi44NzE3MTA3LDExLjUwNTEzMDYgMjIuNzM1NTcwNCwxMS4zOTc0Nzk4IDIyLjU3MjIwMjEsMTEuMzE2NzQxOCBDMjIuNTU4NTg4MSwxMS4zMTY3NDE4IDIyLjU0NDk3NCwxMS4yODk4MjkxIDIyLjUzMTM2LDExLjI3NjM3MjcgTDIzLjE3MTIxOTQsNy4zNjA1NzY2MSBDMjMuMTcxMjE5NCw3LjMzMzY2MzkyIDIzLjE4NDgzMzQsNy4zMjAyMDc1OCAyMy4xOTg0NDc1LDcuMzIwMjA3NTggTDIzLjIxMjA2MTUsNy4zMjAyMDc1OCBDMjMuMjEyMDYxNSw3LjMyMDIwNzU4IDIzLjIyNTY3NTUsNy4zMjAyMDc1OCAyMy4yMzkyODk2LDcuMzMzNjYzOTIgTDI2LjE2NjMwNiwxMC4yMjY3Nzc5IEMyNi4xNzk5MiwxMC4yNDAyMzQzIDI2LjE3OTkyLDEwLjI1MzY5MDYgMjYuMTc5OTIsMTAuMjY3MTQ2OSBDMjYuMTc5OTIsMTAuMjgwNjAzMyAyNi4xNjYzMDYsMTAuMjk0MDU5NiAyNi4xNTI2OTE5LDEwLjMwNzUxNiBMMjMuMDIxNDY1MSwxMS42Mzk2OTQgTDIzLjAwNzg1MSwxMS42Mzk2OTQgQzIyLjk5NDIzNywxMS42Mzk2OTQgMjIuOTk0MjM3LDExLjYzOTY5NCAyMi45ODA2MjMsMTEuNjI2MjM3NyBaIE0xNi4zNTA1NzM2LDkuNDU5NzM4MSBDMTYuMzIzMzQ1Myw5LjE5MDYxMjc0IDE2LjIyODA0NjMsOC45MjE0ODczOCAxNi4wNzgyOTA2LDguNjkyNzMwODMgQzE2LjA2NDY3NjUsOC42NzkyNzQ1NiAxNi4wNjQ2NzY1LDguNjUyMzYyMDIgMTYuMDc4MjkwNiw4LjYyNTQ0OTQ5IEwxOS4zNTkzMDEsMy41Mzg5ODAyMiBDMTkuMzU5MzAxLDMuNTI1NTIzOTUgMTkuMzcyOTE1MSwzLjUxMjA2NzY4IDE5LjM4NjUyOTMsMy41MTIwNjc2OCBDMTkuNDAwMTQzNCwzLjUxMjA2NzY4IDE5LjQwMDE0MzQsMy41MTIwNjc2OCAxOS40MTM3NTc2LDMuNTI1NTIzOTUgTDIyLjMyNzE4NTgsNi40MTg2MjE1NSBDMjIuMzQwOCw2LjQzMjA3NzgyIDIyLjM0MDgsNi40NDU1MzQwOSAyMi4zNDA4LDYuNDU4OTkwMzUgTDIxLjU3ODQwNzYsMTEuMTgyMTQwNCBDMjEuNTc4NDA3NiwxMS4yMDkwNTI5IDIxLjU2NDc5MzQsMTEuMjIyNTA5MiAyMS41NTExNzkzLDExLjIyMjUwOTIgQzIxLjM3NDE5NTMsMTEuMjc2MzM0MyAyMS4yMTA4MjU1LDExLjM1NzA3MTkgMjEuMDc0Njg0LDExLjQ2NDcyMiBDMjEuMDc0Njg0LDExLjQ3ODE3ODMgMjEuMDYxMDY5OCwxMS40NzgxNzgzIDIxLjAzMzg0MTUsMTEuNDc4MTc4MyBMMTYuMzc3ODAxOSw5LjUwMDEwNjkgQzE2LjM2NDE4NzgsOS40ODY2NTA2MyAxNi4zNTA1NzM2LDkuNDczMTk0MzcgMTYuMzUwNTczNiw5LjQ1OTczODEgWiBNMjYuOTgzMTkwNywxMS4wMjA3NjY5IEwzMS45Nzk1Nzg4LDE1Ljk3MjY2NCBDMzIuMDA2ODA3MSwxNS45ODYxMjAyIDMyLjAwNjgwNzEsMTYuMDI2NDg4OSAzMS45Nzk1Nzg4LDE2LjAyNjQ4ODkgTDMxLjk1MjM1MDUsMTYuMDUzNDAxNCBDMzEuOTUyMzUwNSwxNi4wNjY4NTc3IDMxLjkzODczNjQsMTYuMDY2ODU3NyAzMS45MTE1MDgxLDE2LjA2Njg1NzcgTDIzLjU1MjQyODMsMTIuNTI3ODY2IEMyMy41Mzg4MTQxLDEyLjUyNzg2NiAyMy41MjUyLDEyLjUwMDk1MzUgMjMuNTI1MiwxMi40ODc0OTczIEMyMy41MjUyLDEyLjQ3NDA0MSAyMy41Mzg4MTQxLDEyLjQ2MDU4NDggMjMuNTUyNDI4MywxMi40NDcxMjg2IEwyNi45NTU5NjI0LDExLjAwNzMxMDcgQzI2Ljk1NTk2MjQsMTEuMDA3MzEwNyAyNi45Njk1NzY1LDExLjAwNzMxMDcgMjYuOTgzMTkwNywxMS4wMjA3NjY5IFogTTIzLjEzMDQzNjMsMTMuMzg5MDg4MSBMMzEuMTQ5MTg1OCwxNi43ODAwNzYxIEMzMS4xNjI4LDE2Ljc5MzUzMjQgMzEuMTYyOCwxNi44MDY5ODg3IDMxLjE2MjgsMTYuODIwNDQ1IEMzMS4xNjI4LDE2LjgzMzkwMTMgMzEuMTYyOCwxNi44NDczNTc2IDMxLjE0OTE4NTgsMTYuODYwODEzOSBMMjYuNzEwOTY0NSwyMS4yNjEwMjQ1IEMyNi43MTA5NjQ1LDIxLjI3NDQ4MDggMjYuNjk3MzUwMywyMS4yNzQ0ODA4IDI2LjY3MDEyMiwyMS4yNzQ0ODA4IEwyMS44MjM0NzU0LDIwLjI2NTI1ODIgQzIxLjc5NjI0NywyMC4yNjUyNTgyIDIxLjc4MjYzMjksMjAuMjUxODAxOSAyMS43ODI2MzI5LDIwLjIyNDg4OTMgQzIxLjc0MTc5MDMsMTkuODQ4MTEyOCAyMS41NjQ4MDYsMTkuNTExNzA1MyAyMS4yNjUyOTQyLDE5LjI4Mjk0ODEgQzIxLjI1MTY4LDE5LjI2OTQ5MTggMjEuMjUxNjgsMTkuMjU2MDM1NSAyMS4yNTE2OCwxOS4yNDI1NzkyIEwyMi4xMDkzNzMxLDEzLjk4MTE2NTMgQzIyLjEwOTM3MzEsMTMuOTU0MjUyNyAyMi4xMzY2MDE0LDEzLjk0MDc5NjQgMjIuMTUwMjE1NiwxMy45NDA3OTY0IEMyMi41MzE0MTI1LDEzLjg4Njk3MTIgMjIuODU4MTUyNywxMy42OTg1ODMgMjMuMDc1OTc5NiwxMy40MDI1NDQ0IEMyMy4wODk1OTM3LDEzLjM4OTA4ODEgMjMuMTAzMjA3OSwxMy4zODkwODgxIDIzLjEzMDQzNjMsMTMuMzg5MDg4MSBaIE0xNi4xNDYzNzksMTAuNDI4Njg1OSBMMjAuNTMwMTMxNywxMi4yODU2NTMyIEMyMC41NDM3NDU5LDEyLjI5OTEwOTUgMjAuNTU3MzYsMTIuMzEyNTY1OCAyMC41NTczNiwxMi4zMzk0NzgzIEMyMC41NDM3NDU5LDEyLjQwNjc1OTggMjAuNTMwMTMxNywxMi40ODc0OTc1IDIwLjUzMDEzMTcsMTIuNTY4MjM1MiBMMjAuNTMwMTMxNywxMi42MzU1MTY2IEwyMC41MzAxMzE3LDEyLjY4OTM0MTcgQzIwLjUzMDEzMTcsMTIuNzAyNzk4IDIwLjUxNjUxNzYsMTIuNzE2MjU0MyAyMC41MDI5MDM0LDEyLjcyOTcxMDYgQzIwLjUwMjkwMzQsMTIuNzI5NzEwNiAxMC44Nzc3MDcyLDE2LjgzMzg3NzUgMTAuODY0MDkzLDE2LjgzMzg3NzUgQzEwLjg1MDQ3ODksMTYuODMzODc3NSAxMC44MzY4NjQ3LDE2LjgzMzg3NzUgMTAuODIzMjUwNiwxNi44MjA0MjEyIEMxMC44MDk2MzY1LDE2LjgwNjk2NDkgMTAuODA5NjM2NSwxNi43ODAwNTI0IDEwLjgyMzI1MDYsMTYuNzY2NTk2MSBMMTQuNDMwOTk3NCwxMS4xODIyMzc4IEMxNC40NDQ2MTE2LDExLjE2ODc4MTUgMTQuNDU4MjI1NywxMS4xNTUzMjUzIDE0LjQ4NTQ1NCwxMS4xNTUzMjUzIEMxNC41ODA3NTMsMTEuMTY4NzgxNSAxNC42NjI0Mzc4LDExLjE4MjIzNzggMTQuNzQ0MTIyNiwxMS4xODIyMzc4IEMxNS4yODg2ODgyLDExLjE4MjIzNzggMTUuNzkyNDExMywxMC45MTMxMTIxIDE2LjA5MTkyMjQsMTAuNDU1NTk4NCBDMTYuMTA1NTM2NSwxMC40NDIxNDIyIDE2LjExOTE1MDcsMTAuNDI4Njg1OSAxNi4xNDYzNzksMTAuNDI4Njg1OSBaIE0yMS41NTExNDI5LDIxLjE4MDI0MzMgTDI1LjgxMjM3MTcsMjIuMDU0OTA1MyBDMjUuODI1OTg1OSwyMi4wNTQ5MDUzIDI1LjgzOTYsMjIuMDY4MzYxNiAyNS44Mzk2LDIyLjEwODczMDcgQzI1LjgzOTYsMjIuMTIyMTg3IDI1LjgzOTYsMjIuMTM1NjQzMyAyNS44MjU5ODU5LDIyLjE0OTA5OTcgTDE5LjkxNzQ0NDksMjguMDAyNjA3MiBDMTkuOTE3NDQ0OSwyOC4wMTYwNjM2IDE5LjkwMzgzMDcsMjguMDE2MDYzNiAxOS44OTAyMTY2LDI4LjAxNjA2MzYgTDE5Ljg2Mjk4ODMsMjguMDE2MDYzNiBDMTkuODQ5Mzc0MSwyOC4wMDI2MDcyIDE5LjgzNTc2LDI3Ljk4OTE1MDkgMTkuODM1NzYsMjcuOTYyMjM4MiBMMjAuODU2ODIxMiwyMS42OTE1ODQxIEMyMC44NTY4MjEyLDIxLjY3ODEyNzggMjAuODcwNDM1NCwyMS42NTEyMTUxIDIwLjg4NDA0OTUsMjEuNjUxMjE1MSBDMjEuMTI5MTA0MiwyMS41NTcwMjA4IDIxLjMzMzMxNjUsMjEuMzk1NTQ0NyAyMS40OTY2ODYzLDIxLjE5MzY5OTYgQzIxLjUxMDMwMDQsMjEuMTkzNjk5NiAyMS41MjM5MTQ2LDIxLjE4MDI0MzMgMjEuNTUxMTQyOSwyMS4xODAyNDMzIFogTTE5LjA0NjE2NzksMjAuNjgyNDAzIEMxOS4xNTUwODE0LDIxLjA5OTU0ODcgMTkuNDU0NTkzMywyMS40NjI4NjkyIDE5Ljg2MzAxODcsMjEuNjI0MzQ0OSBDMTkuODkwMjQ3MSwyMS42Mzc4MDEyIDE5Ljg5MDI0NzEsMjEuNjY0NzEzOSAxOS44NjMwMTg3LDIxLjY2NDcxMzkgQzE5Ljg2MzAxODcsMjEuNjY0NzEzOSAxOC42MjQxMjgzLDI5LjIxMzcwNTQgMTguNjI0MTI4MywyOS4yMjcxNjE3IEwxOC4xODg0NzQ2LDI5LjY1Nzc2MzcgQzE4LjE4ODQ3NDYsMjkuNjcxMjIwMSAxOC4xNzQ4NjA0LDI5LjY3MTIyMDEgMTguMTYxMjQ2MiwyOS42NzEyMjAxIEMxOC4xNDc2MzIsMjkuNjcxMjIwMSAxOC4xNDc2MzIsMjkuNjcxMjIwMSAxOC4xMzQwMTc4LDI5LjY1Nzc2MzcgTDEwLjk0NTczMDYsMTkuMjY5NDkwMSBDMTAuOTMyMTE2NSwxOS4yNTYwMzM4IDEwLjkzMjExNjUsMTkuMjI5MTIxMiAxMC45NDU3MzA2LDE5LjIxNTY2NDkgQzEwLjk4NjU3MzIsMTkuMTYxODM5NiAxMS4wMTM4MDE1LDE5LjEwODAxNDQgMTEuMDU0NjQ0MSwxOS4wNDA3MzI4IEMxMS4wNjgyNTgzLDE5LjAyNzI3NjUgMTEuMDgxODcyNCwxOS4wMTM4MjAyIDExLjEwOTEwMDgsMTkuMDEzODIwMiBMMTkuMDA1MzI1NCwyMC42NDIwMzQxIEMxOS4wMzI1NTM3LDIwLjY1NTQ5MDQgMTkuMDQ2MTY3OSwyMC42Njg5NDY3IDE5LjA0NjE2NzksMjAuNjgyNDAzIFogTTExLjMxMzM2NDcsMTguMDk4NzI4NiBDMTEuMjg2MTM2NSwxOC4wOTg3Mjg2IDExLjI3MjUyMjQsMTguMDg1MjcyNCAxMS4yNzI1MjI0LDE4LjA1ODM1OTggQzExLjI3MjUyMjQsMTcuOTUwNzA5NiAxMS4yNDUyOTQxLDE3Ljg1NjUxNTcgMTEuMjMxNjgsMTcuNzQ4ODY1NCBDMTEuMjMxNjgsMTcuNzIxOTUyOSAxMS4yMzE2OCwxNy43MDg0OTY2IDExLjI1ODkwODIsMTcuNjk1MDQwMyBDMTEuMjU4OTA4MiwxNy42OTUwNDAzIDIwLjkzODU0NTksMTMuNTYzOTYzNSAyMC45NTIxNiwxMy41NjM5NjM1IEMyMC45NTIxNiwxMy41NjM5NjM1IDIwLjk2NTc3NDEsMTMuNTYzOTYzNSAyMC45NzkzODgyLDEzLjU3NzQxOTcgQzIxLjA0NzQ1ODgsMTMuNjQ0NzAxMSAyMS4xMDE5MTUzLDEzLjY4NTA2OTkgMjEuMTU2MzcxOCwxMy43MjU0Mzg4IEMyMS4xODM2LDEzLjcyNTQzODggMjEuMTgzNiwxMy43NTIzNTEzIDIxLjE4MzYsMTMuNzY1ODA3NiBMMjAuMzM5NTI0NywxOC45NDY0NzQxIEMyMC4zMzk1MjQ3LDE4Ljk3MzM4NjYgMjAuMzI1OTEwNiwxOC45ODY4NDI5IDIwLjI5ODY4MjQsMTguOTg2ODQyOSBDMTkuODM1ODAyNCwxOS4wMTM3NTU0IDE5LjQyNzM3ODgsMTkuMjgyODgxIDE5LjE5NTkzODgsMTkuNjg2NTY5MyBDMTkuMTgyMzI0NywxOS43MDAwMjU1IDE5LjE2ODcxMDYsMTkuNzEzNDgxOCAxOS4xNDE0ODI0LDE5LjcxMzQ4MTggTDExLjMxMzM2NDcsMTguMDk4NzI4NiBaIE03Ljg2ODk3NzU4LDE5LjE4ODcyOTEgQzcuOTA5ODIwMywxOS4yNTYwMTExIDcuOTUwNjYzMDMsMTkuMzA5ODM2NyA3Ljk5MTUwNTc2LDE5LjM2MzY2MjMgQzguMDA1MTIsMTkuMzc3MTE4NyA4LjAwNTEyLDE5LjM5MDU3NTEgOC4wMDUxMiwxOS4zOTA1NzUxIEw2LjEzOTk2ODc5LDIyLjI4MzcwMDcgQzYuMTI2MzU0NTUsMjIuMjk3MTU3MSA2LjExMjc0MDMsMjIuMzEwNjEzNSA2LjA5OTEyNjA2LDIyLjMxMDYxMzUgQzYuMDk5MTI2MDYsMjIuMzEwNjEzNSA2LjA4NTUxMTgyLDIyLjMxMDYxMzUgNi4wNzE4OTc1OCwyMi4yOTcxNTcxIEw0LjQyNDU3NDI0LDIwLjY2ODkzMjkgQzQuNDEwOTYsMjAuNjU1NDc2NSA0LjQxMDk2LDIwLjY0MjAyMDEgNC40MTA5NiwyMC42Mjg1NjM3IEM0LjQxMDk2LDIwLjYxNTEwNzMgNC40MjQ1NzQyNCwyMC42MDE2NTA5IDQuNDM4MTg4NDgsMjAuNjAxNjUwOSBMNy44MTQ1MjA2MSwxOS4xNjE4MTYzIEw3LjgyODEzNDg1LDE5LjE2MTgxNjMgQzcuODQxNzQ5MDksMTkuMTYxODE2MyA3Ljg1NTM2MzMzLDE5LjE3NTI3MjcgNy44Njg5Nzc1OCwxOS4xODg3MjkxIFogTTEwLjE4MzMxOTEsMTkuODYxNTU3OSBDMTAuMTk2OTMzMiwxOS44NjE1NTc5IDEwLjIxMDU0NzMsMTkuODc1MDE0MiAxMC4yMjQxNjE0LDE5Ljg4ODQ3MDYgTDE3LjQzOTYyOTQsMzAuMzU3NDg3OCBDMTcuNDUzMjQzNSwzMC4zNzA5NDQxIDE3LjQ1MzI0MzUsMzAuMzk3ODU2NyAxNy40Mzk2Mjk0LDMwLjQxMTMxMzEgTDE1Ljg2MDM5NDksMzEuOTg1NzAyNSBDMTUuODYwMzk0OSwzMS45OTkxNTg5IDE1Ljg0Njc4MDgsMzEuOTk5MTU4OSAxNS44MDU5Mzg2LDMxLjk4NTcwMjUgTDYuNzkzNDEwNTcsMjMuMDY0MTYyMiBDNi43Nzk3OTY0OCwyMy4wNTA3MDU4IDYuNzc5Nzk2NDgsMjMuMDIzNzkzMiA2LjgwNzAyNDY2LDIyLjk5Njg4MDYgTDguNzY3NDUzNzEsMTkuOTU1NzUyMiBDOC43ODEwNjc4LDE5Ljk0MjI5NTggOC43OTQ2ODE4OSwxOS45Mjg4Mzk1IDguODIxOTEwMDcsMTkuOTI4ODM5NSBDOS4wMjYxMjE0MywxOS45OTYxMjExIDkuMjE2NzE4NywyMC4wMjMwMzM4IDkuNDIwOTMwMDYsMjAuMDIzMDMzOCBDOS42Nzk1OTc3OCwyMC4wMjMwMzM4IDkuOTI0NjUxNDEsMTkuOTY5MjA4NSAxMC4xODMzMTkxLDE5Ljg2MTU1NzkgWiBNOC45OTg5MTg1NiwxNi40MDMyMzIyIEM4Ljk4NTMwNDM5LDE2LjQwMzIzMjIgOC45NzE2OTAyMiwxNi4zODk3NzU5IDguOTU4MDc2MDQsMTYuMzc2MzE5NiBMNS4wOTE2NTA2MywxMC43MzgxMzg4IEM1LjA3ODAzNjQ2LDEwLjcyNDY4MjUgNS4wNzgwMzY0NiwxMC42OTc3NyA1LjA5MTY1MDYzLDEwLjY4NDMxMzcgTDguNTYzMjY1LDcuMjM5NTA2MzMgQzguNTYzMjY1LDcuMjI2MDUwMDYgOC41NzY4NzkxNyw3LjIyNjA1MDA2IDguNjA0MTA3NTIsNy4yMjYwNTAwNiBDOC42MDQxMDc1Miw3LjIzOTUwNjMzIDEyLjcwMTk3MzksOC45NjE5MTAwMiAxMy4xNjQ4NTU4LDkuMTYzNzU0MiBDMTMuMTc4NDcsOS4xNzcyMTA0OCAxMy4xOTIwODQyLDkuMTkwNjY2NzYgMTMuMTkyMDg0Miw5LjIxNzU3OTMyIEMxMy4xNjQ4NTU4LDkuMzM4Njg1ODMgMTMuMTUxMjQxNiw5LjQ1OTc5MjM0IDEzLjE1MTI0MTYsOS41ODA4OTg4NCBDMTMuMTUxMjQxNiw5Ljk5ODA0MzQ5IDEzLjMxNDYxMTcsMTAuMzg4Mjc1NiAxMy42MDA1MDk0LDEwLjY4NDMxMzcgQzEzLjYxNDEyMzUsMTAuNjk3NzcgMTMuNjE0MTIzNSwxMC43MjQ2ODI1IDEzLjYwMDUwOTQsMTAuNzM4MTM4OCBMOS45NTE5MTA3NCwxNi4zODk3NzU5IEM5LjkzODI5NjU3LDE2LjQwMzIzMjIgOS45MjQ2ODIzOSwxNi40MTY2ODg1IDkuODk3NDU0MDUsMTYuNDE2Njg4NSBDOS43NDc2OTgxMywxNi4zNzYzMTk2IDkuNTg0MzI4MDQsMTYuMzQ5NDA3MSA5LjQzNDU3MjEzLDE2LjM0OTQwNzEgQzkuMjk4NDMwMzksMTYuMzQ5NDA3MSA5LjE0ODY3NDQ4LDE2LjM3NjMxOTYgOC45OTg5MTg1NiwxNi40MDMyMzIyIFogTTEzLjY2ODYwMTksOC4zNTY0MjAzNCBDMTMuNDkxNjE4Niw4LjI3NTY4MTk4IDkuMzUyOTMzMjQsNi41MjYzNTA4MyA5LjM1MjkzMzI0LDYuNTI2MzUwODMgQzkuMzM5MzE5MTQsNi41MTI4OTQ0NCA5LjMyNTcwNTA1LDYuNTEyODk0NDQgOS4zMzkzMTkxNCw2LjQ4NTk4MTY1IEM5LjMzOTMxOTE0LDYuNDcyNTI1MjYgOS4zMzkzMTkxNCw2LjQ1OTA2ODg2IDkuMzUyOTMzMjQsNi40NDU2MTI0NyBMMTUuODMzMjQzMiwwLjAxMzQ1NjM5MzUgQzE1LjgzMzI0MzIsMCAxNS44NDY4NTczLDAgMTUuODYwNDcxNCwwIEMxNS44NzQwODU1LDAgMTUuODc0MDg1NSwwIDE1Ljg4NzY5OTYsMC4wMTM0NTYzOTM1IEwxOC42Nzg1ODk0LDIuNzcyMDE3MDUgQzE4LjY5MjIwMzUsMi43ODU0NzM0NSAxOC42OTIyMDM1LDIuODEyMzg2MjMgMTguNjc4NTg5NCwyLjgyNTg0MjYzIEwxNS4zMTU5MDc2LDguMDMzNDY2OSBDMTUuMzAyMjkzNSw4LjA0NjkyMzI5IDE1LjI4ODY3OTQsOC4wNjAzNzk2OSAxNS4yNjE0NTEyLDguMDYwMzc5NjkgQzE1LjA4NDQ2NzksOC4wMDY1NTQxMSAxNC45MDc0ODQ3LDcuOTc5NjQxMzMgMTQuNzMwNTAxNCw3Ljk3OTY0MTMzIEMxNC4zNjI5MjA4LDcuOTc5NjQxMzMgMTMuOTk1MzQwMiw4LjExNDIwNTI2IDEzLjcwOTQ0NDIsOC4zNDI5NjM5NSBDMTMuNjk1ODMwMSw4LjM1NjQyMDM0IDEzLjY5NTgzMDEsOC4zNTY0MjAzNCAxMy42Njg2MDE5LDguMzU2NDIwMzQgWiBNNy43ODcyODk5NSwxNy4zMzE3NTExIEM3Ljc3MzY3NTgxLDE3LjM0NTIwNzQgNy43NjAwNjE2NywxNy4zNTg2NjM3IDcuNzQ2NDQ3NTIsMTcuMzU4NjYzNyBMMC4wNDA4NDI0Mjk4LDE1Ljc0MzkwOCBDMC4wMTM2MTQxNDMzLDE1Ljc0MzkwOCAwLDE1LjczMDQ1MTcgMCwxNS43MTY5OTU0IEMwLDE1LjcwMzUzOTEgMCwxNS42OTAwODI4IDAuMDEzNjE0MTQzMywxNS42NzY2MjY1IEw0LjMxNTY4MzQyLDExLjQyNDQzNjMgQzQuMzE1NjgzNDIsMTEuNDEwOTgwMSA0LjMyOTI5NzU2LDExLjQxMDk4MDEgNC4zNDI5MTE3MSwxMS40MTA5ODAxIEM0LjM3MDEzOTk5LDExLjQyNDQzNjMgNC4zNzAxMzk5OSwxMS40MjQ0MzYzIDQuMzgzNzU0MTMsMTEuNDM3ODkyNiBDNC4zODM3NTQxMywxMS40NTEzNDg5IDguMDczMTg2OTYsMTYuNzgwMDQyOSA4LjExNDAyOTM5LDE2LjgzMzg2ODEgQzguMTI3NjQzNTQsMTYuODQ3MzI0NCA4LjEyNzY0MzU0LDE2Ljg3NDIzNyA4LjExNDAyOTM5LDE2Ljg4NzY5MzMgQzcuOTkxNTAyMSwxNy4wMjIyNTYzIDcuODY4OTc0ODEsMTcuMTcwMjc1NSA3Ljc4NzI4OTk1LDE3LjMzMTc1MTEgWiBNNy4zNTE1NTc4MywxOC4yNDY3NDY0IEM3LjM3ODc4NTk0LDE4LjI0Njc0NjQgNy4zOTI0LDE4LjI2MDIwMjcgNy4zOTI0LDE4LjI4NzExNTEgQzcuMzkyNCwxOC4zMDA1NzEzIDcuMzc4Nzg1OTQsMTguMzE0MDI3NSA3LjM1MTU1NzgzLDE4LjM0MDkzOTkgTDMuNjM0OTIsMTkuOTE1MzE2NSBDMy42MzQ5MiwxOS45MTUzMTY1IDMuNjIxMzA1OTQsMTkuOTE1MzE2NSAzLjYwNzY5MTg4LDE5LjkwMTg2MDMgTDAuNjI2MjEzMTg1LDE2Ljk0MTQ5NDEgQzAuNjEyNTk5MTI3LDE2LjkyODAzNzggMC41OTg5ODUwNjksMTYuOTAxMTI1NCAwLjYxMjU5OTEyNywxNi44ODc2NjkyIEMwLjYyNjIxMzE4NSwxNi44NzQyMTMgMC42Mzk4MjcyNDMsMTYuODYwNzU2OCAwLjY2NzA1NTM1OSwxNi44NjA3NTY4IEw3LjM1MTU1NzgzLDE4LjI0Njc0NjQgWiIvPjwvc3ZnPg==);\\n}\\n\\n.visuallyHidden {\\n  border: 0;\\n  clip: rect(0 0 0 0);\\n  height: 1px;\\n  margin: -1px;\\n  overflow: hidden;\\n  padding: 0;\\n  position: absolute;\\n  width: 1px;\\n  white-space: nowrap;\\n}\\n\\n.subheader {\\n  margin-top: 2em;\\n  border-top: 1px solid rgb(14, 30, 37);\\n}\\n\\n.subheader h3 {\\n    padding-top: 1em;\\n    text-align: center;\\n  }\\n', \"\", { version: 3, sources: [\"webpack://components/modal.css\"], names: [], mappings: \"AAiBA;EACE,wBAAwB;EACxB,cAA0B;EAC1B,gBAAgB;AAClB;;AACA;EACE,gBAAgB;EAChB,cAA0B;EAC1B,gBAAgB;AAClB;;AACA;EACE,WAAW;EACX,cAA0B;EAC1B,gBAAgB;AAClB;;AACA;EACE,gBAAgB;EAChB,cAA0B;EAC1B,gBAAgB;AAClB;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,OAAO;EACP,WAAW;EACX,gBAAgB;EAChB,kBAAkB;EAClB,gBAAgB;EAChB,8BAAsB;UAAtB,sBAAsB;EACtB;+EAA8B;EAC9B,eAAe;EACf,gBAAgB;EAChB,oBAAa;EAAb,oBAAa;EAAb,aAAa;EACb,4BAAsB;EAAtB,6BAAsB;MAAtB,0BAAsB;UAAtB,sBAAsB;EACtB,yBAAmB;MAAnB,sBAAmB;UAAnB,mBAAmB;EACnB,cAAc;AAChB;;AAEA;EACE,WAAW;EACX,cAAc;EACd,eAAe;EACf,MAAM;EACN,SAAS;EACT,OAAO;EACP,QAAQ;EACR,sBAAsB;EACtB,WAAW;AACb;;AAEA;EACE,mBAAY;MAAZ,oBAAY;UAAZ,YAAY;EACZ,oBAAa;EAAb,oBAAa;EAAb,aAAa;EACb,4BAAsB;EAAtB,6BAAsB;MAAtB,0BAAsB;UAAtB,sBAAsB;EACtB,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,aAA2B;EAC3B,UAAU;EACV,4CAAoC;UAApC,oCAAoC;EACpC,gBAAgB;AAMlB;;AAJE;IACE,2EAAmE;YAAnE,mEAAmE;IACnE,qCAA6B;YAA7B,6BAA6B;EAC/B;;AAGF;EACE;IACE,UAAU;IACV,8CAAsC;YAAtC,sCAAsC;EACxC;;EAEA;IACE,UAAU;IACV,yCAAiC;YAAjC,iCAAiC;EACnC;AACF;;AAVA;EACE;IACE,UAAU;IACV,8CAAsC;YAAtC,sCAAsC;EACxC;;EAEA;IACE,UAAU;IACV,yCAAiC;YAAjC,iCAAiC;EACnC;AACF;;AAEA;EACE;IACE,iCAAkC;IAClC,sCAA8B;YAA9B,8BAA8B;IAC9B,qCAA6B;YAA7B,6BAA6B;EAC/B;;EAEA;IACE,gBAAgB;IAChB,wBAAuB;QAAvB,qBAAuB;YAAvB,uBAAuB;EACzB;;EAEA;IACE,gBAAgB;IAChB;wCACqC;YADrC;wCACqC;IACrC,kBAAkB;IAClB,gBAA8B;EAChC;AACF;;AAEA;EACE;IACE,UAAU;EACZ;;EAEA;IACE,aAAa;EACf;AACF;;AARA;EACE;IACE,UAAU;EACZ;;EAEA;IACE,aAAa;EACf;AACF;;AAEA;EACE,kBAAkB;EAClB,sBAAuB;EACvB,gBAAgB;EAChB,eAAe;EACf,yBAAyB;EACzB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ,uCAA+B;EAA/B,+BAA+B;AACjC;;AAEA;;EAEE,UAAU;AACZ;;AAEA;EACE,cAAwB;EACxB,yBAAyB;EACzB,UAAU;AACZ;;AAEA;EACE,WAAW;EACX,qBAAqB;EACrB,kBAAkB;EAClB,QAAQ;EACR,iBAAiB;EACjB,WAAW;EACX,YAAY;EACZ,mCAAmC;EACnC,yzCAAyzC;AAC3zC;;AAEA;AACA;;AAEA;EACE,aAAa;EACb,oBAAoB;AACtB;;AAEA;EACE,kBAAkB;EAClB,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,y2CAAy2C;EACz2C,2BAA2B;EAC3B,wBAAwB;EACxB,6BAA6B;EAC7B,0BAA0B;EAC1B,8CAAsC;UAAtC,sCAAsC;EACtC,oBAAoB;AACtB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE;IACE,0BAA0B;EAC5B;;EAEA;IACE,4BAA4B;EAC9B;AACF;;AARA;EACE;IACE,0BAA0B;EAC5B;;EAEA;IACE,4BAA4B;EAC9B;AACF;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,gBAAgB;EAChB,YAAY;EACZ,UAAU;EACV,eAAe;EACf,iCAAkC;EAClC,kBAAkB;EAClB,yBAAyB;EACzB,WAAW;EACX,8CAAsC;EAAtC,sCAAsC;EACtC;+EAA8B;EAC9B,eAAe;EACf,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,qBAAqB;EACrB,mBAAmB;AACrB;;AAEA;;EAEE,iCAAkC;EAClC,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;EAClB,MAAM;EACN,QAAQ;EACR,SAAS;EACT,UAAU;EACV,SAAS;EACT,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,WAAW;EACX,gBAAgB;EAChB,cAA0B;AAC5B;;AAEA;EACE,YAAY;EACZ,eAAe;EACf,gBAAgB;AAClB;;AAEA;;EAEE,mBAAmB;EACnB,sBAAuB;AACzB;;AAEA;EACE,oBAAa;EAAb,oBAAa;EAAb,aAAa;EACb,gBAAgB;EAChB,mBAAiC;AACnC;;AAEA;EACE,eAAe;EACf,iBAAiB;EACjB,gBAAgB;EAChB,cAA0B;EAC1B,SAAS;EACT,gCAAgC;EAChC,0BAA0B;EAC1B,SAAS;AACX;;AAEA;;EAEE,gBAAgB;EAChB,sBAAuB;EACvB,6BAA8B;EAC9B,gBAAgB;AAClB;;AAEA;EACE,yBAAyB;EACzB,sBAAuB;AACzB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,cAAc;EACd,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,mBAAmB;EACnB,YAAY;EACZ,iBAAiB;EACjB,UAAU;EACV,eAAe;EACf,sBAAuB;EACvB,YAAY;EACZ,gCAAgC;EAChC,gBAAgB;EAChB,yBAAyB;EACzB,0CAAkC;EAAlC,kCAAkC;EAClC;+EAA8B;EAC9B,eAAe;EACf,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,mBAAmB;AACrB;;AAEA;;EAEE,yBAAyB;EACzB,qBAAiC;AACnC;;AAEA;AACA;;AAEA;EACE,kBAAkB;EAClB,gBAAgB;AAClB;;AAEA;EACE,8BAAsB;UAAtB,sBAAsB;EACtB,cAAc;EACd,WAAW;EACX,YAAY;EACZ,SAAS;EACT,0BAA0B;EAC1B,yBAAyB;EACzB,kBAAkB;EAClB,gBAAgB;EAChB,sBAAuB;EACvB,wBAAgB;UAAhB,gBAAgB;EAChB,eAAe;EACf,gBAAgB;EAChB,iBAAiB;EACjB,wDAAwC;EAAxC,gDAAwC;EAAxC,wCAAwC;EAAxC,8EAAwC;EACxC,wBAAwB;EACxB,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,UAAU;EACV,qBAAqB;EACrB,WAAW;EACX,YAAY;EACZ,4BAA4B;EAC5B,2BAA2B;EAC3B,oBAAoB;AACtB;;AAEA;EACE,6jBAA6jB;AAC/jB;;AAEA;EACE,65DAA65D;AAC/5D;;AAEA;EACE,qkEAAqkE;AACvkE;;AAEA;EACE,yyCAAyyC;AAC3yC;;AAEA;AACA;;AAEA;EACE,SAAS;EACT,6BAA6B;EAC7B,mBAAiC;EACjC,kBAAkB;EAClB,iBAAiB;AACnB;;AAEA;EACE,aAAa;EACb,kBAAkB;EAClB,qBAAqB;EACrB,eAAe;EACf,gBAAgB;EAChB,cAAc;EACd,yBAAyB;EACzB,sBAAsB;EACtB,sBAAuB;EACvB,YAAY;EACZ,UAAU;AACZ;;AAEA;EACE,kBAAkB;EAClB,mBAAmB;AACrB;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,qBAAqB;EACrB,sBAAsB;EACtB,WAAW;EACX,YAAY;EACZ,4BAA4B;EAC5B,gCAAgC;EAChC,SAAS;EACT,UAAU;AACZ;;AAEA;EACE,yBAA4C;EAC5C,qBAA2C;AAC7C;;AAEA;;EAEE,yBAA+C;AACjD;;AAEA;EACE,sBAA4C;EAC5C,kBAA2C;AAC7C;;AAEA;;EAEE,sBAA+C;AACjD;;AAEA;EACE,yBAA4C;EAC5C,qBAA2C;AAC7C;;AAEA;;EAEE,yBAA+C;AACjD;;AAEA;EACE,yBAA+C;EAC/C,qBAA8C;AAChD;;AAEA;;EAEE,yBAAkD;AACpD;;AAEA;EACE,i9DAAi9D;AACn9D;;AAEA;EACE,ikKAAikK;AACnkK;;AAEA;EACE,imDAAimD;AACnmD;;AAEA;EACE,y2FAAy2F;AAC32F;;AAEA;EACE,cAAc;EACd,aAA2B;EAC3B,eAAe;EACf,gBAAgB;EAChB,qBAAqB;EACrB,cAA0B;EAC1B,kBAAkB;AACpB;;AAEA;EACE,aAAa;EACb,iCAAyB;EAAzB,yBAAyB;AAC3B;;AAEA;EACE,UAAU;AACZ;;AAEA;EACE,cAAc;EACd,YAAY;EACZ,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,qlYAAqlY;AACvlY;;AAEA;EACE,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;EACZ,gBAAgB;EAChB,UAAU;EACV,kBAAkB;EAClB,UAAU;EACV,mBAAmB;AACrB;;AAEA;EACE,eAAe;EACf,qCAAqC;AAMvC;;AAJE;IACE,gBAAgB;IAChB,kBAAkB;EACpB\", sourcesContent: [':root {\\n  --baseColor: rgb(14, 30, 37);\\n  --subduedColor: #a3a9ac;\\n  --errorColor: #fa3946;\\n  --providerColorGoogle: #4285f4;\\n  --providerAltColorGoogle: #366dc7;\\n  --providerColorGitHub: #333;\\n  --providerAltColorGitHub: #000;\\n  --providerColorGitLab: #e24329;\\n  --providerAltColorGitLab: #b03320;\\n  --providerColorBitbucket: #205081;\\n  --providerAltColorBitbucket: #14314f;\\n  --fontFamily: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica,\\n    Arial, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\";\\n  --basePadding: 32px;\\n}\\n\\n::-webkit-input-placeholder {\\n  /* Chrome/Opera/Safari */\\n  color: var(--subduedColor);\\n  font-weight: 500;\\n}\\n::-moz-placeholder {\\n  /* Firefox 19+ */\\n  color: var(--subduedColor);\\n  font-weight: 500;\\n}\\n:-ms-input-placeholder {\\n  /* IE 10+ */\\n  color: var(--subduedColor);\\n  font-weight: 500;\\n}\\n:-moz-placeholder {\\n  /* Firefox 18- */\\n  color: var(--subduedColor);\\n  font-weight: 500;\\n}\\n\\n.modalContainer {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  min-height: 100%;\\n  overflow-x: hidden;\\n  overflow-y: auto;\\n  box-sizing: border-box;\\n  font-family: var(--fontFamily);\\n  font-size: 14px;\\n  line-height: 1.5;\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  z-index: 99999;\\n}\\n\\n.modalContainer::before {\\n  content: \"\";\\n  display: block;\\n  position: fixed;\\n  top: 0;\\n  bottom: 0;\\n  left: 0;\\n  right: 0;\\n  background-color: #fff;\\n  z-index: -1;\\n}\\n\\n.modalDialog {\\n  flex-grow: 1;\\n  display: flex;\\n  flex-direction: column;\\n  width: 100%;\\n}\\n\\n.modalContent {\\n  position: relative;\\n  padding: var(--basePadding);\\n  opacity: 0;\\n  transform: translateY(10px) scale(1);\\n  background: #fff;\\n\\n  [aria-hidden=\"false\"] & {\\n    animation: bouncyEntrance 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);\\n    animation-fill-mode: forwards;\\n  }\\n}\\n\\n@keyframes bouncyEntrance {\\n  0% {\\n    opacity: 0;\\n    transform: translateY(10px) scale(0.9);\\n  }\\n\\n  100% {\\n    opacity: 1;\\n    transform: translateY(0) scale(1);\\n  }\\n}\\n\\n@media (min-width: 480px) {\\n  .modalContainer::before {\\n    background-color: var(--baseColor);\\n    animation: fadeIn 0.1s ease-in;\\n    animation-fill-mode: forwards;\\n  }\\n\\n  .modalDialog {\\n    max-width: 364px;\\n    justify-content: center;\\n  }\\n\\n  .modalContent {\\n    background: #fff;\\n    box-shadow: 0 4px 12px 0 rgba(0, 0, 0, 0.07),\\n      0 12px 32px 0 rgba(14, 30, 37, 0.1);\\n    border-radius: 8px;\\n    margin-top: var(--basePadding);\\n  }\\n}\\n\\n@keyframes fadeIn {\\n  0% {\\n    opacity: 0;\\n  }\\n\\n  100% {\\n    opacity: 0.67;\\n  }\\n}\\n\\n.flashMessage {\\n  text-align: center;\\n  color: var(--baseColor);\\n  font-weight: 500;\\n  font-size: 14px;\\n  background-color: #f2f3f3;\\n  padding: 6px;\\n  border-radius: 4px;\\n  opacity: 0.7;\\n  transition: opacity 0.2s linear;\\n}\\n\\n.flashMessage:hover,\\n.flashMessage:focus {\\n  opacity: 1;\\n}\\n\\n.error {\\n  color: var(--errorColor);\\n  background-color: #fceef0;\\n  opacity: 1;\\n}\\n\\n.error span::before {\\n  content: \"\";\\n  display: inline-block;\\n  position: relative;\\n  top: 3px;\\n  margin-right: 4px;\\n  width: 16px;\\n  height: 16px;\\n  background: no-repeat center center;\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4KICA8cGF0aCBmaWxsPSIjRkEzOTQ2IiBkPSJNOCwxLjMzMzMzMzMzIEMxMS42NzYsMS4zMzMzMzMzMyAxNC42NjY2NjY3LDQuMzI0IDE0LjY2NjY2NjcsOCBDMTQuNjY2NjY2NywxMS42NzYgMTEuNjc2LDE0LjY2NjY2NjcgOCwxNC42NjY2NjY3IEM0LjMyNCwxNC42NjY2NjY3IDEuMzMzMzMzMzMsMTEuNjc2IDEuMzMzMzMzMzMsOCBDMS4zMzMzMzMzMyw0LjMyNCA0LjMyNCwxLjMzMzMzMzMzIDgsMS4zMzMzMzMzMyBaIE04LDAgQzMuNTgyLDAgMCwzLjU4MiAwLDggQzAsMTIuNDE4IDMuNTgyLDE2IDgsMTYgQzEyLjQxOCwxNiAxNiwxMi40MTggMTYsOCBDMTYsMy41ODIgMTIuNDE4LDAgOCwwIFogTTcuMTI2NjY2NjcsNS4wMTczMzMzMyBDNy4wNjA2NjY2Nyw0LjQ3OTMzMzMzIDcuNDc4NjY2NjcsNCA4LjAyNTMzMzMzLDQgQzguNTM5MzMzMzMsNCA4Ljk0MzMzMzMzLDQuNDUwNjY2NjcgOC44Nzg2NjY2Nyw0Ljk2NzMzMzMzIEw4LjM3NCw5LjAwMjY2NjY3IEM4LjM1MDY2NjY3LDkuMTkxMzMzMzMgOC4xOSw5LjMzMzMzMzMzIDgsOS4zMzMzMzMzMyBDNy44MSw5LjMzMzMzMzMzIDcuNjQ5MzMzMzMsOS4xOTEzMzMzMyA3LjYyNTMzMzMzLDkuMDAyNjY2NjcgTDcuMTI2NjY2NjcsNS4wMTczMzMzMyBMNy4xMjY2NjY2Nyw1LjAxNzMzMzMzIFogTTgsMTIuMTY2NjY2NyBDNy41NCwxMi4xNjY2NjY3IDcuMTY2NjY2NjcsMTEuNzkzMzMzMyA3LjE2NjY2NjY3LDExLjMzMzMzMzMgQzcuMTY2NjY2NjcsMTAuODczMzMzMyA3LjU0LDEwLjUgOCwxMC41IEM4LjQ2LDEwLjUgOC44MzMzMzMzMywxMC44NzMzMzMzIDguODMzMzMzMzMsMTEuMzMzMzMzMyBDOC44MzMzMzMzMywxMS43OTMzMzMzIDguNDYsMTIuMTY2NjY2NyA4LDEyLjE2NjY2NjcgWiIvPgo8L3N2Zz4K);\\n}\\n\\n.success {\\n}\\n\\n.disabled {\\n  opacity: 0.38;\\n  pointer-events: none;\\n}\\n\\n.infoText {\\n  text-align: center;\\n  margin: 32px 0;\\n}\\n\\n.infoTextEmail {\\n  font-size: 16px;\\n  font-weight: 500;\\n}\\n\\n.saving {\\n  background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABQCAMAAACeYYN3AAAAxlBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////DTx3aAAAAQnRSTlMAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEGgjKRfAAACk0lEQVR4AYXQDXP5WhAG8CUhiSQqSv4RRRMVL1Fa1VZf3PL9v9Tde9wc9M8+P8/M7s6czJiHgNIvVCJO6YiAMlAiWckASiQrm4bJMZTDrmbBIEC9qpgVjp6n4B+oyEwCzKrMQBVaQIlkpmXZln1dhQB+49gOh5dLexlV6MhsAqyazEQVugCqsOK5nsQmwPWZ53ucvyczSGb4l9T9OsdnLgFOXVZFFd4AqEKrIasR4AdBI2hw1GR6VzMwSWY2A60ZNDl6KnUC3KbMRhXeAqhCpyXzCAjarNVucdqXVEhWaRfCdsj5vQcE1EOZQ7Jy+EcUlklWi2Q3BLQ6nagTcTra2Y0qrHZirRN3OOezTUAjvq4bd7suqpDfSGJUoXcnCwiIerIqqlC96vf6HD1ZsUcE3PYH/QGnrx3uYnqoQn4l6aMK/XtZi4BuIrNIZqVJkiapkhx37Y6AcDgcpsNU44Nz3OuoQn4jSVGFNw+ykID+SGaTzM5G2YiTFVM73AMConE2zjhj7XAXs4EqHE/4d12GKgwmsoiAZCpzSObMptPZdHZVSkCc5/ksnym8cPRUmiQzpvNcmedzTl4o7qlBsuZc1iVg9ChDFdYWshEBveV/FssFZ/l7Z7eowsfl0/JJ4UXj43A/ogpbT7IeAZNnWQ1VuJJNCBi8HKxeVhw9tRaq8JkfrV/WHDULxb1CFbbX7HX9yllfck9A/ipzSea+yeYEJO+yEFX4tim8b94VXjj/zzdU4Z/NmY/NB+fkTglYfMg8knmfsiUBD1+yCFX4+X309f3FOds/UYVR8fH2e6vwovExIuB5K/NJ5v8jWxGQ/chiVOF2d+pn98M5zt3WJFm83+/2O4UXjprabkzAWn+o56k9qvBfX4hMaM+SxOMAAAAASUVORK5CYII=);\\n  background-repeat: repeat-x;\\n  background-size: contain;\\n  background-origin: border-box;\\n  background-position: 0% 0%;\\n  animation: loading 20s linear infinite;\\n  pointer-events: none;\\n}\\n\\n.saving::after {\\n  content: \"\\u2026\";\\n}\\n\\n@keyframes loading {\\n  0% {\\n    background-position: 0% 0%;\\n  }\\n\\n  100% {\\n    background-position: 700% 0%;\\n  }\\n}\\n\\n.btn {\\n  display: block;\\n  position: relative;\\n  width: 100%;\\n  height: auto;\\n  margin: 14px 0 0;\\n  padding: 6px;\\n  outline: 0;\\n  cursor: pointer;\\n  border: 2px solid var(--baseColor);\\n  border-radius: 4px;\\n  background-color: #2d3b41;\\n  color: #fff;\\n  transition: background-color 0.2s ease;\\n  font-family: var(--fontFamily);\\n  font-size: 14px;\\n  font-weight: 500;\\n  line-height: 24px;\\n  text-align: center;\\n  text-decoration: none;\\n  white-space: nowrap;\\n}\\n\\n.btn:hover,\\n.btn:focus {\\n  background-color: var(--baseColor);\\n  text-decoration: none;\\n}\\n\\n.btnClose {\\n  position: absolute;\\n  top: 0;\\n  right: 0;\\n  margin: 0;\\n  padding: 0;\\n  border: 0;\\n  width: 24px;\\n  height: 24px;\\n  border-radius: 50%;\\n  margin: 6px;\\n  background: #fff;\\n  color: var(--subduedColor);\\n}\\n\\n.btnClose::before {\\n  content: \"\\xD7\";\\n  font-size: 25px;\\n  line-height: 9px;\\n}\\n\\n.btnClose:hover,\\n.btnClose:focus {\\n  background: #e9ebeb;\\n  color: var(--baseColor);\\n}\\n\\n.header {\\n  display: flex;\\n  margin-top: -8px;\\n  margin-bottom: var(--basePadding);\\n}\\n\\n.btnHeader {\\n  font-size: 16px;\\n  line-height: 24px;\\n  background: #fff;\\n  color: var(--subduedColor);\\n  border: 0;\\n  border-bottom: 2px solid #e9ebeb;\\n  border-radius: 4px 4px 0 0;\\n  margin: 0;\\n}\\n\\n.btnHeader:focus,\\n.btnHeader.active {\\n  background: #fff;\\n  color: var(--baseColor);\\n  border-color: var(--baseColor);\\n  font-weight: 700;\\n}\\n\\n.btnHeader:not(:only-child):hover {\\n  background-color: #e9ebeb;\\n  color: var(--baseColor);\\n}\\n\\n.btnHeader:only-child {\\n  cursor: auto;\\n}\\n\\n.btnLink {\\n  display: block;\\n  position: relative;\\n  width: auto;\\n  height: auto;\\n  margin: 14px auto 0;\\n  padding: 6px;\\n  padding-bottom: 0;\\n  outline: 0;\\n  cursor: pointer;\\n  color: var(--baseColor);\\n  border: none;\\n  border-bottom: 2px solid #e9ebeb;\\n  border-radius: 0;\\n  background-color: inherit;\\n  transition: border-color 0.2s ease;\\n  font-family: var(--fontFamily);\\n  font-size: 14px;\\n  font-weight: 500;\\n  line-height: 24px;\\n  text-align: center;\\n  white-space: nowrap;\\n}\\n\\n.btnLink:hover,\\n.btnLink:focus {\\n  background-color: inherit;\\n  border-color: var(--subduedColor);\\n}\\n\\n.form {\\n}\\n\\n.formGroup {\\n  position: relative;\\n  margin-top: 14px;\\n}\\n\\n.formControl {\\n  box-sizing: border-box;\\n  display: block;\\n  width: 100%;\\n  height: 40px;\\n  margin: 0;\\n  padding: 6px 12px 6px 34px;\\n  border: 2px solid #e9ebeb;\\n  border-radius: 4px;\\n  background: #fff;\\n  color: var(--baseColor);\\n  box-shadow: none;\\n  font-size: 16px;\\n  font-weight: 500;\\n  line-height: 24px;\\n  transition: box-shadow ease-in-out 0.15s;\\n  -webkit-appearance: none;\\n  -moz-appearance: none;\\n}\\n\\n.inputFieldIcon {\\n  position: absolute;\\n  top: 12px;\\n  left: 12px;\\n  display: inline-block;\\n  width: 16px;\\n  height: 16px;\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  pointer-events: none;\\n}\\n\\n.inputFieldName {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSIxNCIgdmlld0JveD0iMCAwIDE0IDE0Ij4gIDxwYXRoIGZpbGw9IiNBM0E5QUMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTgsNyBDNi4zNDMxNDU3NSw3IDUsNS42NTY4NTQyNSA1LDQgQzUsMi4zNDMxNDU3NSA2LjM0MzE0NTc1LDEgOCwxIEM5LjY1Njg1NDI1LDEgMTEsMi4zNDMxNDU3NSAxMSw0IEMxMSw1LjY1Njg1NDI1IDkuNjU2ODU0MjUsNyA4LDcgWiBNOCwxNSBMMS41LDE1IEMxLjUsMTEuMTM0MDA2OCA0LjQxMDE0OTEzLDggOCw4IEMxMS41ODk4NTA5LDggMTQuNSwxMS4xMzQwMDY4IDE0LjUsMTUgTDgsMTUgWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEgLTEpIi8+PC9zdmc+);\\n}\\n\\n.inputFieldEmail {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxMSIgdmlld0JveD0iMCAwIDE2IDExIj4gIDxwYXRoIGZpbGw9IiNBM0E5QUMiIGQ9Ik0xLjE3MDczMTcxLDMgQzAuNTIyMTQ2MzQxLDMgMy45MDI0NTk4N2UtMDgsMy41NDUxMTA4MSAzLjkwMjQ1OTg3ZS0wOCw0LjIyMjIyMTU0IEwzLjkwMjQ1OTg3ZS0wOCwxMi43Nzc3Nzg1IEMzLjkwMjQ1OTg3ZS0wOCwxMy40NTQ4ODkyIDAuNTIyMTQ2MzQxLDE0IDEuMTcwNzMxNzEsMTQgTDE0LjgyOTI2ODMsMTQgQzE1LjQ3Nzg1MzcsMTQgMTYsMTMuNDU0ODg5MiAxNiwxMi43Nzc3Nzg1IEwxNiw0LjIyMjIyMTU0IEMxNiwzLjU0NTExMDgxIDE1LjQ3Nzg1MzcsMyAxNC44MjkyNjgzLDMgTDEuMTcwNzMxNzEsMyBaIE0yLjMzNzQyMTE5LDUuMDAxODY1NjYgQzIuNDU3NTExNzUsNC45ODk1NTIxNCAyLjU2MDcxNDU3LDUuMDM5MzM5OCAyLjYzNjM1OTg1LDUuMTE3Mjg0MzcgTDcuNDgyNjA2MTcsMTAuMTEzMjU0NSBDNy43ODQ0ODgyMiwxMC40MjQ3NDU1IDguMjAzMjc4MjksMTAuNDI0NzY2IDguNTA1ODk2MTksMTAuMTEzMjU0NSBMMTMuMzYzNjQwMiw1LjExNzI4NDM3IEMxMy41MDUxMjU1LDQuOTcxMjA0OTkgMTMuNzUyOTc3OSw0Ljk4MTg5NzIzIDEzLjg4MzkyMjIsNS4xMzk3MzYwMiBDMTQuMDE0ODY2NSw1LjI5NzU3NDgxIDE0LjAwNTI4MjEsNS41NzQwNzQ4OCAxMy44NjM3OTY3LDUuNzIwMTU0MjYgTDExLjExNTg2MDYsOC41NDg0MTE1MiBMMTMuODU4MDU3MSwxMS4yNjc2NDY5IEMxNC4wMjE3ODM1LDExLjQwMzE5ODIgMTQuMDQ4OTM2MywxMS43MDE0OTMyIDEzLjkxMjk4ODIsMTEuODcwOTg4OCBDMTMuNzc3MDQwMSwxMi4wNDA1MDQ5IDEzLjUwODI4OTcsMTIuMDQzNDE5MSAxMy4zNjkzOTgyLDExLjg3Njk0MDQgTDEwLjU3NTQ3MTUsOS4xMDYzOTg2MiBMOS4wMDYwNTI3NSwxMC43MTYxMjQ0IEM4LjQzNDk0MTk1LDExLjMwNDAzMzQgNy41NTMzMDI4NiwxMS4zMDUxNjIxIDYuOTgyNDY4LDEwLjcxNjEyNDQgTDUuNDI0NTI4NSw5LjEwNjM5ODYyIEwyLjYzMDYwMTgzLDExLjg3Njk0MDQgQzIuNDkxNzEwMzMsMTIuMDQzNDM5NyAyLjIyMjk1OTg4LDEyLjA0MDUyNTUgMi4wODcwMTE3OCwxMS44NzA5ODg4IEMxLjk1MTA2MzY3LDExLjcwMTQ5MzIgMS45NzgyMTY1LDExLjQwMzE5ODIgMi4xNDE5NDI5LDExLjI2NzY0NjkgTDQuODg0MTM5MzksOC41NDg0MTE1MiBMMi4xMzYyMDMyOCw1LjcyMDE1NDI2IEMyLjAyODcxNDE0LDUuNjE2MjI4MTYgMS45ODM1NTE0MSw1LjQzODk1NDUzIDIuMDI1OTkxNSw1LjI4NzQ5ODI1IEMyLjA2ODQxMzE5LDUuMTM2MDYyNDkgMi4xOTYwMjc4MSw1LjAxOTAyMjQ5IDIuMzM3NDIxMTksNS4wMDE4NjU2NiBaIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIC0zKSIvPjwvc3ZnPg==);\\n}\\n\\n.inputFieldPassword {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxNCIgdmlld0JveD0iMCAwIDEyIDE0Ij4gIDxwYXRoIGZpbGw9IiNBM0E5QUMiIGQ9Ik0yLjQ0NTkxMDQ1LDMuNjQzMDg0MjcgQzIuNDQ1OTEwMzgsMi42NzY2MjEzNyAyLjgxODk3NTQ2LDEuNzQ5NzYzOTMgMy40ODI5OTUxOCwxLjA2NjUxMDUyIEM0LjE0NzAxNDksMC4zODMyNTcxMTEgNS4wNDc1NjY0MywtMC4wMDAzOTMwNDg2MTggNS45ODY0NDEwNSwzLjAyMTc0MDY5ZS0wNyBMNi4xMTc1MTg0NywzLjAyMTc0MDY5ZS0wNyBDOC4wNjkyOTIwNSwwLjAwMjQ1Mjc4Mzg0IDkuNjUwNzAwMTMsMS42MzA5OTI4MyA5LjY1MjI4NzQyLDMuNjQwMTE4NzkgTDkuNjUyMjg3NDIsNC42NzgwMzQ0NSBDOS4xMzk1MDEwNSw0LjcwMzI0MDk4IDguNjM2Nzk3NTYsNC43NDYyNDAzNCA4LjEzMTIxMzI1LDQuODAxMTAxNiBMOC4xMzEyMTMyNSwzLjY0MzA4NDI3IEM4LjEzMTIxMzI1LDIuNDk2NjM0MjkgNy4yMjgzNjE2LDEuNTY3MjUyOTUgNi4xMTQ2Mzc2NCwxLjU2NzI1Mjk1IEw1Ljk4MzU2MDIzLDEuNTY3MjUyOTUgQzQuODY5ODM2MjgsMS41NjcyNTI5NSAzLjk2Njk4NDYyLDIuNDk2NjM0MjkgMy45NjY5ODQ2MiwzLjY0MzA4NDI3IEwzLjk2Njk4NDYyLDMuOTYwMzg5OTEgQzMuOTY3NTc5ODgsNC4zNTY0OTE4MiAzLjY3NzAzNTY1LDQuNjg4ODc1OTUgMy4yOTQzMTI2Miw0LjcyOTkzMDI0IEwzLjI3ODQ2ODEsNC43Mjk5MzAyNCBDMy4wNjYyNDA5Miw0Ljc1MzUwMjk2IDIuODU0MjgyODcsNC42ODMxMDg3IDIuNjk1NDU2MTMsNC41MzYzMDM3NiBDMi41MzY2Mjk0LDQuMzg5NDk4ODIgMi40NDU5MDUzMyw0LjE4MDEyMTMzIDIuNDQ1OTEwNDUsMy45NjAzODk5MSBMMi40NDU5MTA0NSwzLjY0MzA4NDI3IFogTTExLjQxNjY2Niw3LjExNTY1MzUyIEwxMS40MTY2NjYsMTIuNjkwNzQzMyBDMTEuNDE3MDQwOCwxMy4wODMxMTQzIDExLjE0NTkyMDMsMTMuNDIwMTM3MSAxMC43NzEzNjE4LDEzLjQ5MjkwMzkgTDEwLjI5MDI2NDQsMTMuNTg2MzE2MyBDOC44NzYwNzU2NCwxMy44NjE1OTU5IDcuNDM5OTcxMzMsMTQuMDAwMDkzNyA2LjAwMDcyMDA1LDEzLjk5OTk5OTggQzQuNTYwOTg3NTgsMTQuMDAwMTg2MiAzLjEyNDM5Njg0LDEzLjg2MTY4OCAxLjcwOTczNTI0LDEzLjU4NjMxNjMgTDEuMjI4NjM3OTIsMTMuNDkyOTAzOSBDMC44NTQwNzk0MDcsMTMuNDIwMTM3MSAwLjU4Mjk1ODg2NywxMy4wODMxMTQzIDAuNTgzMzMzNzIyLDEyLjY5MDc0MzMgTDAuNTgzMzMzNzIyLDcuMTE1NjUzNTIgQzAuNTgyOTU4ODY3LDYuNzIzMjgyNTYgMC44NTQwNzk0MDcsNi4zODYyNTk4MSAxLjIyODYzNzkyLDYuMzEzNDkyOTkgTDEuMjk5MjE4MDYsNi4zMDAxNDgzNiBDNC40MDU5OTg0Nyw1LjY5NTEyMTY3IDcuNTk1NDQxNjIsNS42OTUxMjE2NyAxMC43MDIyMjIsNi4zMDAxNDgzNiBMMTAuNzcyODAyMiw2LjMxMzQ5Mjk5IEMxMS4xNDY3ODgsNi4zODY4ODY0NSAxMS40MTcxNzE2LDYuNzIzNzQ1MTYgMTEuNDE2NjY2LDcuMTE1NjUzNTIgWiIvPjwvc3ZnPg==);\\n}\\n\\n.inputFieldUrl {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSIxNCIgdmlld0JveD0iMCAwIDE0IDE0Ij4gIDxwYXRoIGZpbGw9IiNBM0E5QUMiIGQ9Ik0xMCw1IEMxMCwzLjg5NTQzMDUgOS4xMDQ1Njk1LDMgOCwzIEM2Ljg5NTQzMDUsMyA2LDMuODk1NDMwNSA2LDUgTTQsMTAgTDQsMTEgTDYsMTEgTDYsMTAgQzYsOS40NDc3MTUyNSA1LjU1MjI4NDc1LDkgNSw5IEM0LjQ0NzcxNTI1LDkgNCw5LjQ0NzcxNTI1IDQsMTAgWiBNMTIsMTAgQzEyLDkuNDQ3NzE1MjUgMTEuNTUyMjg0Nyw5IDExLDkgQzEwLjQ0NzcxNTMsOSAxMCw5LjQ0NzcxNTI1IDEwLDEwIEwxMCwxMSBMMTIsMTEgTDEyLDEwIFogTTYsNiBMNiw1IEw0LDUgTDQsNiBDNCw2LjU1MjI4NDc1IDQuNDQ3NzE1MjUsNyA1LDcgQzUuNTUyMjg0NzUsNyA2LDYuNTUyMjg0NzUgNiw2IFogTTEwLDYgQzEwLDYuNTUyMjg0NzUgMTAuNDQ3NzE1Myw3IDExLDcgQzExLjU1MjI4NDcsNyAxMiw2LjU1MjI4NDc1IDEyLDYgTDEyLDUgTDEwLDUgTDEwLDYgWiBNNCw1IEM0LDIuNzkwODYxIDUuNzkwODYxLDEgOCwxIEMxMC4yMDkxMzksMSAxMiwyLjc5MDg2MSAxMiw1IEw0LDUgWiBNNCwxMSBMMTIsMTEgQzEyLDEzLjIwOTEzOSAxMC4yMDkxMzksMTUgOCwxNSBDNS43OTA4NjEsMTUgNCwxMy4yMDkxMzkgNCwxMSBaIE0xMCwxMSBMNiwxMSBDNiwxMi4xMDQ1Njk1IDYuODk1NDMwNSwxMyA4LDEzIEM5LjEwNDU2OTUsMTMgMTAsMTIuMTA0NTY5NSAxMCwxMSBaIE04LDExIEM3LjQ0NzcxNTI1LDExIDcsMTAuNTUyMjg0NyA3LDEwIEw3LDYgQzcsNS40NDc3MTUyNSA3LjQ0NzcxNTI1LDUgOCw1IEM4LjU1MjI4NDc1LDUgOSw1LjQ0NzcxNTI1IDksNiBMOSwxMCBDOSwxMC41NTIyODQ3IDguNTUyMjg0NzUsMTEgOCwxMSBaIiB0cmFuc2Zvcm09InJvdGF0ZSg0NSA4LjcwNyA2LjI5MykiLz48L3N2Zz4=);\\n}\\n\\n.formLabel {\\n}\\n\\n.hr {\\n  border: 0;\\n  border-top: 2px solid #e9ebeb;\\n  margin: var(--basePadding) 0 -1px;\\n  text-align: center;\\n  overflow: visible;\\n}\\n\\n.hr::before {\\n  content: \"or\";\\n  position: relative;\\n  display: inline-block;\\n  font-size: 12px;\\n  font-weight: 800;\\n  line-height: 1;\\n  text-transform: uppercase;\\n  background-color: #fff;\\n  color: var(--baseColor);\\n  padding: 4px;\\n  top: -11px;\\n}\\n\\n.btnProvider {\\n  padding-left: 40px;\\n  padding-right: 40px;\\n}\\n\\n.btnProvider::before {\\n  content: \"\";\\n  position: absolute;\\n  display: inline-block;\\n  vertical-align: middle;\\n  width: 32px;\\n  height: 40px;\\n  background-repeat: no-repeat;\\n  background-position: left center;\\n  top: -2px;\\n  left: 14px;\\n}\\n\\n.providerGoogle {\\n  background-color: var(--providerColorGoogle);\\n  border-color: var(--providerAltColorGoogle);\\n}\\n\\n.providerGoogle:hover,\\n.providerGoogle:focus {\\n  background-color: var(--providerAltColorGoogle);\\n}\\n\\n.providerGitHub {\\n  background-color: var(--providerColorGitHub);\\n  border-color: var(--providerAltColorGitHub);\\n}\\n\\n.providerGitHub:hover,\\n.providerGitHub:focus {\\n  background-color: var(--providerAltColorGitHub);\\n}\\n\\n.providerGitLab {\\n  background-color: var(--providerColorGitLab);\\n  border-color: var(--providerAltColorGitLab);\\n}\\n\\n.providerGitLab:hover,\\n.providerGitLab:focus {\\n  background-color: var(--providerAltColorGitLab);\\n}\\n\\n.providerBitbucket {\\n  background-color: var(--providerColorBitbucket);\\n  border-color: var(--providerAltColorBitbucket);\\n}\\n\\n.providerBitbucket:hover,\\n.providerBitbucket:focus {\\n  background-color: var(--providerAltColorBitbucket);\\n}\\n\\n.providerGoogle:before {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMyIgaGVpZ2h0PSIxMiIgdmlld0JveD0iMCAwIDEzIDEyIj4gIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEuNDg4IC0yKSI+ICAgIDxyZWN0IHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIvPiAgICA8cGF0aCBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik0wLjY1MjczNDM3NSwzLjI5NTI4MjQ0IEMwLjIzNzk4NDM3NSw0LjEwNTgzMjA2IDIuODQyMTcwOTRlLTE0LDUuMDE2MDQ1OCAyLjg0MjE3MDk0ZS0xNCw1Ljk3OTM4OTMxIEMyLjg0MjE3MDk0ZS0xNCw2Ljk0MjczMjgyIDAuMjM3OTg0Mzc1LDcuODUyOTAwNzYgMC42NTI3MzQzNzUsOC42NjM0NTAzOCBDMS42NTkwNDY4NywxMC42MTY3MDIzIDMuNzI2MDkzNzUsMTEuOTU4Nzc4NiA2LjExOTUzMTI1LDExLjk1ODc3ODYgQzcuNzcxNzgxMjUsMTEuOTU4Nzc4NiA5LjE1ODg1OTM3LDExLjQyNzI1MTkgMTAuMTcyMDE1NiwxMC41MTA0NDI3IEMxMS4zMjc5MDYyLDkuNDY3MzU4NzggMTEuOTk0MjgxMiw3LjkzMjY0MTIyIDExLjk5NDI4MTIsNi4xMTIyNTk1NCBDMTEuOTk0MjgxMiw1LjYyMDYyNTk1IDExLjk1MzQ1MzEsNS4yNjE4NjI2IDExLjg2NTA5MzcsNC44ODk4MTY3OSBMNi4xMTk1MzEyNSw0Ljg4OTgxNjc5IEw2LjExOTUzMTI1LDcuMTA4ODA5MTYgTDkuNDkyMDQ2ODcsNy4xMDg4MDkxNiBDOS40MjQwNzgxMiw3LjY2MDI1OTU0IDkuMDU2OTA2MjUsOC40OTA3MzI4MiA4LjI0MDk1MzEyLDkuMDQ4Nzc4NjMgQzcuNzI0MjAzMTIsOS40MDA5MDA3NiA3LjAzMDY0MDYyLDkuNjQ2NzE3NTYgNi4xMTk1MzEyNSw5LjY0NjcxNzU2IEM0LjUwMTI2NTYyLDkuNjQ2NzE3NTYgMy4xMjc3ODEyNSw4LjYwMzY3OTM5IDIuNjM4MTcxODcsNy4xNjE5ODQ3MyBMMi42Mjg3MTIwNSw3LjE2Mjc2OTU5IEMyLjUwNTM0MTU4LDYuNzk3Mjk0NjggMi40MzQyMTg3NSw2LjM4MTEyMjg1IDIuNDM0MjE4NzUsNS45NzkzODkzMSBDMi40MzQyMTg3NSw1LjU2NzQ1MDM4IDIuNTA4OTg0MzgsNS4xNjg4Mzk2OSAyLjYzMTM3NSw0Ljc5Njc5Mzg5IEMzLjEyNzc4MTI1LDMuMzU1MDk5MjQgNC41MDEyNjU2MiwyLjMxMjAxNTI3IDYuMTE5NTMxMjUsMi4zMTIwMTUyNyBDNy4yNjg2MjUsMi4zMTIwMTUyNyA4LjA0Mzc1LDIuNzk3MDA3NjMgOC40ODU3MzQzNywzLjIwMjMwNTM0IEwxMC4yMTI3OTY5LDEuNTU0NjQxMjIgQzkuMTUyMTA5MzcsMC41OTEyOTc3MSA3Ljc3MTc4MTI1LDguODgxNzg0MmUtMTYgNi4xMTk1MzEyNSw4Ljg4MTc4NDJlLTE2IEMzLjcyNjA5Mzc1LDguODgxNzg0MmUtMTYgMS42NTkwNDY4NywxLjM0MjAzMDUzIDAuNjUyNzM0Mzc1LDMuMjk1MjgyNDQgTDAuNjUyNzM0Mzc1LDMuMjk1MjgyNDQgWiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMiAyKSIvPiAgPC9nPjwvc3ZnPg==);\\n}\\n\\n.providerGitHub:before {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij4gIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+ICAgIDxyZWN0IHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIvPiAgICA8cGF0aCBmaWxsPSIjRkZGRkZGIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik04LjAwMDA2NjI1LDAgQzMuNTgyMzMwNzksMCAwLDMuNjcyMzE1ODUgMCw4LjIwMjUzNzczIEMwLDExLjgyNjYzMzggMi4yOTIyNjI0OCwxNC45MDEyOTUgNS40NzA5MzM1NiwxNS45ODU5MDIzIEM1Ljg3MDc1MTM5LDE2LjA2MTgzMTUgNi4wMTc1MzY3NSwxNS44MDc5NjQyIDYuMDE3NTM2NzUsMTUuNTkxMzE0NCBDNi4wMTc1MzY3NSwxNS4zOTU3MTgzIDYuMDEwMTE3OTksMTQuNzQ5NTcyMiA2LjAwNjY3MzU2LDE0LjA2NDE3MTEgQzMuNzgxMDQ3NDEsMTQuNTYwMzYwMiAzLjMxMTQxMzc5LDEzLjA5NjM3ODEgMy4zMTE0MTM3OSwxMy4wOTYzNzgxIEMyLjk0NzQ5NzQsMTIuMTQ4MjgwNiAyLjQyMzE1MDUsMTEuODk2MTc5IDIuNDIzMTUwNSwxMS44OTYxNzkgQzEuNjk3MzA0OTEsMTEuMzg3MDg2IDIuNDc3ODYzNzksMTEuMzk3NTQ0OSAyLjQ3Nzg2Mzc5LDExLjM5NzU0NDkgQzMuMjgxMjA4ODcsMTEuNDU1NDA4NyAzLjcwNDIxMDMxLDEyLjI0MjgxODcgMy43MDQyMTAzMSwxMi4yNDI4MTg3IEM0LjQxNzczNTQ3LDEzLjQ5NjgwNjcgNS41NzU3MjM0NiwxMy4xMzQyNzQ4IDYuMDMyMjQxNzgsMTIuOTI0Njg4MiBDNi4xMDQwNDQ3MiwxMi4zOTQ1NDE0IDYuMzExMzcyNDQsMTIuMDMyNjg4NyA2LjU0MDE2MTQ0LDExLjgyNzg1NjIgQzQuNzYzMjM3NDQsMTEuNjIwNDQyOCAyLjg5NTMwMTE5LDEwLjkxNzExMjEgMi44OTUzMDExOSw3Ljc3NDEyNzk5IEMyLjg5NTMwMTE5LDYuODc4NTk2ODggMy4yMDc4MTYxOCw2LjE0Njg3NzU3IDMuNzE5NTc3NzMsNS41NzI0NDk5OSBDMy42MzY1MTQxNyw1LjM2NTg1MTY2IDMuMzYyNjgyNjgsNC41MzE1ODAxNyAzLjc5NzA3NzIxLDMuNDAxNzQxMzMgQzMuNzk3MDc3MjEsMy40MDE3NDEzMyA0LjQ2ODg3MTg4LDMuMTgxMjg4MjcgNS45OTc2NjUwNyw0LjI0MjUzMjY3IEM2LjYzNTgxMDQ0LDQuMDYwNzkxMzQgNy4zMjAxOTA0NCwzLjk2OTY0OTAyIDguMDAwMDY2MjUsMy45NjY1MjQ5MiBDOC42Nzk5NDIwNiwzLjk2OTY0OTAyIDkuMzY0ODUyLDQuMDYwNzkxMzQgMTAuMDA0MTg5Niw0LjI0MjUzMjY3IEMxMS41MzExMjgxLDMuMTgxMjg4MjcgMTIuMjAxOTk1NCwzLjQwMTc0MTMzIDEyLjIwMTk5NTQsMy40MDE3NDEzMyBDMTIuNjM3NDQ5OCw0LjUzMTU4MDE3IDEyLjM2MzQ4NTgsNS4zNjU4NTE2NiAxMi4yODA0MjIzLDUuNTcyNDQ5OTkgQzEyLjc5MzM3NjEsNi4xNDY4Nzc1NyAxMy4xMDM3NzE0LDYuODc4NTk2ODggMTMuMTAzNzcxNCw3Ljc3NDEyNzk5IEMxMy4xMDM3NzE0LDEwLjkyNDU4MjggMTEuMjMyMjU4MywxMS42MTgyNjk2IDkuNDUwODMwMDYsMTEuODIxMzM2MyBDOS43Mzc3NzY4NywxMi4wNzU4ODI5IDkuOTkzNDU4ODcsMTIuNTc1MDYwMiA5Ljk5MzQ1ODg3LDEzLjM0MDMyOTggQzkuOTkzNDU4ODcsMTQuNDM3ODQxMSA5Ljk4NDE4NTUsMTUuMzIxMTQ3MyA5Ljk4NDE4NTUsMTUuNTkxMzE0NCBDOS45ODQxODU1LDE1LjgwOTU5NDIgMTAuMTI4MTg4NywxNi4wNjUzNjMxIDEwLjUzMzcwMzEsMTUuOTg0ODE1NiBDMTMuNzEwNjUyLDE0Ljg5ODk4NTggMTYsMTEuODI1NDExMyAxNiw4LjIwMjUzNzczIEMxNiwzLjY3MjMxNTg1IDEyLjQxODE5OTIsMCA4LjAwMDA2NjI1LDAgWiBNMi45OTYyODQ5NiwxMS42ODQ2ODgyIEMyLjk3ODY2NTQxLDExLjcyNTQzNzMgMi45MTYxMzU5MSwxMS43Mzc2NjIxIDIuODU5MTcwNDgsMTEuNzA5NjgxIEMyLjgwMTE0NTIyLDExLjY4MjkyMjMgMi43Njg1NTU3MSwxMS42MjczNjc2IDIuNzg3MzY3NTUsMTEuNTg2NDgyNyBDMi44MDQ1ODk2NSwxMS41NDQ1MTEgMi44NjcyNTE2MiwxMS41MzI4Mjk1IDIuOTI1MTQ0MzksMTEuNTYwOTQ2NSBDMi45ODMzMDIxNCwxMS41ODc3MDUxIDMuMDE2NDIxNTcsMTEuNjQzODAzMSAyLjk5NjI4NDk2LDExLjY4NDY4ODIgWiBNMy4zODk3OTkzMiwxMi4wNDQ3MDI0IEMzLjM1MTY0NTc0LDEyLjA4MDk2OTEgMy4yNzcwNjA3NywxMi4wNjQxMjYxIDMuMjI2NDU0MjYsMTIuMDA2ODA1NyBDMy4xNzQxMjU1NSwxMS45NDk2MjEgMy4xNjQzMjIyMSwxMS44NzMxNDg0IDMuMjAzMDA1NywxMS44MzYzMzgyIEMzLjI0MjM1MTU5LDExLjgwMDA3MTUgMy4zMTQ2ODQ0NSwxMS44MTcwNTAzIDMuMzY3MTQ1NjQsMTEuODc0MjM1IEMzLjQxOTQ3NDMyLDExLjkzMjA5ODggMy40Mjk2NzUxMiwxMi4wMDgwMjgxIDMuMzg5Nzk5MzIsMTIuMDQ0NzAyNCBaIE0zLjY1OTc2NTA4LDEyLjUwNTMyODMgQzMuNjEwNzQ4MzMsMTIuNTQwMjM2OCAzLjUzMDU5OTI5LDEyLjUwNzUwMTUgMy40ODEwNTI2MSwxMi40MzQ1NjA2IEMzLjQzMjAzNTgzLDEyLjM2MTYxOTUgMy40MzIwMzU4MywxMi4yNzQxNDQ2IDMuNDgyMTEyNDQsMTIuMjM5MTAwMyBDMy41MzE3OTE1NywxMi4yMDQwNTYgMy42MTA3NDgzMywxMi4yMzU1Njg4IDMuNjYwOTU3MzgsMTIuMzA3OTY2NSBDMy43MDk4NDE2OCwxMi4zODIxMjk5IDMuNzA5ODQxNjgsMTIuNDY5NjA0OCAzLjY1OTc2NTA4LDEyLjUwNTMyODMgWiBNNC4xMTYzMzQ5NSwxMy4wMzg3OTgxIEM0LjA3MjQ4NDgyLDEzLjA4ODM3NjQgMy45NzkwODgwMiwxMy4wNzUwNjUgMy45MTA3Mjk0OCwxMy4wMDc0MjE0IEMzLjg0MDc4MTI0LDEyLjk0MTI3MTggMy44MjEzMDcwMSwxMi44NDc0MTI5IDMuODY1Mjg5NjMsMTIuNzk3ODM0NyBDMy45MDk2Njk2NiwxMi43NDgxMjA3IDQuMDAzNTk2MzksMTIuNzYyMTExMyA0LjA3MjQ4NDgyLDEyLjgyOTIxMTYgQzQuMTQxOTAzMTYsMTIuODk1MjI1MyA0LjE2MzA5OTYsMTIuOTg5NzYzNCA0LjExNjMzNDk1LDEzLjAzODc5ODEgWiBNNC43MDY0MDcxOSwxMy4yMTg4OTE2IEM0LjY4NzA2NTQ2LDEzLjI4MzEzOTUgNC41OTcxMTMwNiwxMy4zMTIzNDMgNC41MDY0OTgyNywxMy4yODUwNDExIEM0LjQxNjAxNTk3LDEzLjI1NjkyNDIgNC4zNTY3OTg0MiwxMy4xODE2NzQxIDQuMzc1MDgwMzYsMTMuMTE2NzQ3IEM0LjM5Mzg5MjE5LDEzLjA1MjA5MTcgNC40ODQyNDIwMSwxMy4wMjE2NjU2IDQuNTc1NTE5MTgsMTMuMDUwODY5MiBDNC42NjU4NjkwMSwxMy4wNzg4NTAzIDQuNzI1MjE5MDUsMTMuMTUzNTU3MSA0LjcwNjQwNzE5LDEzLjIxODg5MTYgWiBNNS4zNzc5MzQxOSwxMy4yOTUyODI1IEM1LjM4MDE4NjI5LDEzLjM2MjkyNjEgNS4zMDMzNDkxOSwxMy40MTkwMjQxIDUuMjA4MjMwMTgsMTMuNDIwMjQ2NyBDNS4xMTI1ODEyNSwxMy40MjI0MiA1LjAzNTIxNDI1LDEzLjM2NzY4MDMgNS4wMzQxNTQ0MiwxMy4zMDExMjMyIEM1LjAzNDE1NDQyLDEzLjIzMjgwMDUgNS4xMDkyNjkzLDEzLjE3NzI0NTggNS4yMDQ5MTgyMywxMy4xNzU2MTU4IEM1LjMwMDAzNzI2LDEzLjE3MzcxNDIgNS4zNzc5MzQxOSwxMy4yMjgwNDY0IDUuMzc3OTM0MTksMTMuMjk1MjgyNSBaIE02LjAzNzYzNDE5LDEzLjI2OTM1NDggQzYuMDQ5MDI3MjksMTMuMzM1MzY4NSA1Ljk4MjkyMDg4LDEzLjQwMzE0NzkgNS44ODg0NjQyNSwxMy40MjEyMTM0IEM1Ljc5NTU5NzM2LDEzLjQzODU5OTcgNS43MDk2MTkyOSwxMy4zOTc4NTA1IDUuNjk3ODI4NzcsMTMuMzMyMzgwMiBDNS42ODYzMDMyMiwxMy4yNjQ3MzY1IDUuNzUzNjAxOTEsMTMuMTk2OTU3MSA1Ljg0NjMzNjMzLDEzLjE3OTQzNSBDNS45NDA5MjU0NCwxMy4xNjI1OTIgNi4wMjU1Nzg3MiwxMy4yMDIyNTQ1IDYuMDM3NjM0MTksMTMuMjY5MzU0OCBaIi8+ICA8L2c+PC9zdmc+);\\n}\\n\\n.providerGitLab:before {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSIxMyIgdmlld0JveD0iMCAwIDE0IDEzIj4gIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEgLTIpIj4gICAgPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+ICAgIDxwYXRoIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0ibm9uemVybyIgZD0iTTcuMDA0MDkzMzYsMTIuOTQ5MjQzMyBMNC40MjgwOTMzMyw0Ljk5NzI4MjU0IEw5LjU4MDA5MzM2LDQuOTk3MjgyNTQgTDcuMDA0MDkzMzYsMTIuOTQ5MjQzMyBaIE03LjAwNDA5MzM2LDEyLjk0OTIzIEwwLjgxNzg5MzMzMyw0Ljk5NzI2OTE3IEw0LjQyODA5MzMzLDQuOTk3MjY5MTcgTDcuMDA0MDkzMzYsMTIuOTQ5MjMgWiBNMC44MTc4OTk5OTksNC45OTcyODkyMyBMNy4wMDQwOTk5OCwxMi45NDkyNSBMMC4yMjg4MzMzMzMsOC4wMTE4ODA4IEMwLjA0MTksNy44NzU2NzE1MiAtMC4wMzYzLDcuNjM0MjEyNyAwLjAzNTEsNy40MTM4MTcxMiBMMC44MTc4OTk5OTksNC45OTcyODkyMyBaIE0wLjgxNzg5OTk5OSw0Ljk5NzI5NTkxIEwyLjM2OTM2NjY3LDAuMjA3OTA0NzE0IEMyLjQ0OTE2NjY3LC0wLjAzODUwMjM1ODggMi43OTY3NjY2NywtMC4wMzg1NjkyMjY1IDIuODc2NTY2NjcsMC4yMDc5MDQ3MTQgTDQuNDI4MSw0Ljk5NzI5NTkxIEwwLjgxNzg5OTk5OSw0Ljk5NzI5NTkxIFogTTcuMDA0MDkzMzYsMTIuOTQ5MjMgTDkuNTgwMDkzMzYsNC45OTcyNjkxNyBMMTMuMTkwMjkzMyw0Ljk5NzI2OTE3IEw3LjAwNDA5MzM2LDEyLjk0OTIzIFogTTEzLjE5MDI5MzMsNC45OTcyODkyMyBMMTMuOTczMDkzMyw3LjQxMzgxNzEyIEMxNC4wNDQ0OTMzLDcuNjM0MjEyNyAxMy45NjYyOTM0LDcuODc1NjcxNTIgMTMuNzc5MzYsOC4wMTE4ODA4IEw3LjAwNDA5MzM2LDEyLjk0OTI1IEwxMy4xOTAyOTMzLDQuOTk3Mjg5MjMgWiBNMTMuMTkwMjkzMyw0Ljk5NzI5NTkxIEw5LjU4MDA5MzM2LDQuOTk3Mjk1OTEgTDExLjEzMTYyNjcsMC4yMDc5MDQ3MTQgQzExLjIxMTQyNjcsLTAuMDM4NTY5MjI2NSAxMS41NTkwMjY3LC0wLjAzODUwMjM1ODggMTEuNjM4ODI2NywwLjIwNzkwNDcxNCBMMTMuMTkwMjkzMyw0Ljk5NzI5NTkxIFoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEgMikiLz4gIDwvZz48L3N2Zz4=);\\n}\\n\\n.providerBitbucket:before {\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNCIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE0IDE2Ij4gIDxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTEpIj4gICAgPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2Ii8+ICAgIDxnIGZpbGw9IiNGRkZGRkYiIGZpbGwtcnVsZT0ibm9uemVybyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMSkiPiAgICAgIDxwYXRoIGQ9Ik03LDIuNDk4OTQxODdlLTA3IEw3LDIuNDk4OTQxODdlLTA3IEMzLjE1NzIxMjI5LDIuNDk4OTQxODdlLTA3IDAuMDAwNjM2NTM1NDM1LDEuMDIwODQ0MjQgMC4wMDA2MzY1MzU0MzUsMi4zMTM5MTM1OSBDMC4wMDA2MzY1MzU0MzUsMi42NTQxOTUxMyAwLjgyNDA5MTAyMyw3LjQ4NjE5MiAxLjE2NzE5NzE3LDkuMzkxNzY3NTkgQzEuMzA0NDM5MzcsMTAuMjc2NDk5OSAzLjU2ODkzOTUzLDExLjUwMTUxMyA3LDExLjUwMTUxMyBMNywxMS41MDE1MTMgQzEwLjQzMTA2MDIsMTEuNTAxNTEzIDEyLjYyNjkzODYsMTAuMjc2NDk5OSAxMi44MzI4MDMyLDkuMzkxNzY3NTkgQzEzLjE3NTkwODYsNy40ODYxOTIgMTMuOTk5MzYzMiwyLjY1NDE5NTEzIDEzLjk5OTM2MzIsMi4zMTM5MTM1OSBDMTMuOTMwNzQyMSwxLjAyMDg0NDI0IDEwLjg0Mjc4NzQsMi40OTg5NDE4N2UtMDcgNywyLjQ5ODk0MTg3ZS0wNyBMNywyLjQ5ODk0MTg3ZS0wNyBaIE03LDkuOTM2MjE4MzEgQzUuNzY0ODE4MjgsOS45MzYyMTgzMSA0LjgwNDEyMTI2LDguOTgzNDI5ODYgNC44MDQxMjEyNiw3Ljc1ODQxNjcxIEM0LjgwNDEyMTI2LDYuNTMzNDAzNTUgNS43NjQ4MTgyOCw1LjU4MDYxNTk3IDcsNS41ODA2MTU5NyBDOC4yMzUxODExMiw1LjU4MDYxNTk3IDkuMTk1ODc4NCw2LjUzMzQwMzU1IDkuMTk1ODc4NCw3Ljc1ODQxNjcxIEM5LjE5NTg3ODQsOC45MTUzNzM3MiA4LjIzNTE4MTEyLDkuOTM2MjE4MzEgNyw5LjkzNjIxODMxIEw3LDkuOTM2MjE4MzEgWiBNNywyLjk5NDQ3NjY3IEM0LjUyOTYzNjIyLDIuOTk0NDc2NjcgMi41Mzk2MjExLDIuNTg2MTM4OTUgMi41Mzk2MjExLDIuMDQxNjg4ODYgQzIuNTM5NjIxMSwxLjQ5NzIzODE1IDQuNTI5NjM2MjIsMS4wODg5MDA0MyA3LDEuMDg4OTAwNDMgQzkuNDcwMzYyODQsMS4wODg5MDA0MyAxMS40NjAzNzg2LDEuNDk3MjM4MTUgMTEuNDYwMzc4NiwyLjA0MTY4ODg2IEMxMS40NjAzNzg2LDIuNTg2MTM4OTUgOS40NzAzNjI4NCwyLjk5NDQ3NjY3IDcsMi45OTQ0NzY2NyBMNywyLjk5NDQ3NjY3IFoiLz4gICAgICA8cGF0aCBkPSJNMTIuMDY0NTA5NiwxMS4yMjkyODc2IEMxMS45MjcyNjY3LDExLjIyOTI4NzYgMTEuODU4NjQ1NywxMS4yOTczNDM4IDExLjg1ODY0NTcsMTEuMjk3MzQzOCBDMTEuODU4NjQ1NywxMS4yOTczNDM4IDEwLjE0MzExNTYsMTIuNjU4NDcgNy4wNTUxNjA5MywxMi42NTg0NyBDMy45NjcyMDY4NywxMi42NTg0NyAyLjI1MTY3NjE2LDExLjI5NzM0MzggMi4yNTE2NzYxNiwxMS4yOTczNDM4IEMyLjI1MTY3NjE2LDExLjI5NzM0MzggMi4xMTQ0MzM5NSwxMS4yMjkyODc2IDIuMDQ1ODEyODUsMTEuMjI5Mjg3NiBDMS45MDg1NzAwMiwxMS4yMjkyODc2IDEuNzcxMzI3ODEsMTEuMjk3MzQzOCAxLjc3MTMyNzgxLDExLjUwMTUxMyBMMS43NzEzMjc4MSwxMS41Njk1NjkyIEMyLjA0NTgxMjg1LDEyLjk5ODc1MTYgMi4yNTE2NzYxNiwxNC4wMTk1OTU2IDIuMjUxNjc2MTYsMTQuMTU1NzA3OSBDMi40NTc1NDAwOSwxNS4xNzY1NTI1IDQuNTE2MTc2MzIsMTUuOTkzMjI4IDYuOTg2NTM5ODIsMTUuOTkzMjI4IEw2Ljk4NjUzOTgyLDE1Ljk5MzIyOCBDOS40NTY5MDMzMSwxNS45OTMyMjggMTEuNTE1NTM5NSwxNS4xNzY1NTI1IDExLjcyMTQwMzUsMTQuMTU1NzA3OSBDMTEuNzIxNDAzNSwxNC4wMTk1OTU2IDExLjkyNzI2NjcsMTIuOTk4NzUxNiAxMi4yMDE3NTE4LDExLjU2OTU2OTIgTDEyLjIwMTc1MTgsMTEuNTAxNTEzIEMxMi4yNzAzNzI5LDExLjM2NTQgMTIuMjAxNzUxOCwxMS4yMjkyODc2IDEyLjA2NDUwOTYsMTEuMjI5Mjg3NiBMMTIuMDY0NTA5NiwxMS4yMjkyODc2IFoiLz4gICAgICA8ZWxsaXBzZSBjeD0iNyIgY3k9IjcuNjkiIHJ4PSIxLjA5OCIgcnk9IjEuMDg5Ii8+ICAgIDwvZz4gIDwvZz48L3N2Zz4=);\\n}\\n\\n.callOut {\\n  display: block;\\n  padding: var(--basePadding);\\n  font-size: 14px;\\n  font-weight: 500;\\n  text-decoration: none;\\n  color: var(--subduedColor);\\n  text-align: center;\\n}\\n\\n.callOut:after {\\n  content: \" \\u2665\";\\n  transition: color 4s ease;\\n}\\n\\n.callOut:hover:after {\\n  color: red;\\n}\\n\\n.callOut .netlifyLogo {\\n  display: block;\\n  margin: auto;\\n  width: 32px;\\n  height: 32px;\\n  margin-bottom: 8px;\\n  background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIj4gIDxkZWZzPiAgICA8cmFkaWFsR3JhZGllbnQgaWQ9ImEiIGN5PSIwJSIgcj0iMTAwJSIgZng9IjUwJSIgZnk9IjAlIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDAgMSAtMS4xNTE4NSAwIC41IC0uNSkiPiAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiMyMEM2QjciIG9mZnNldD0iMCUiLz4gICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjNEQ5QUJGIiBvZmZzZXQ9IjEwMCUiLz4gICAgPC9yYWRpYWxHcmFkaWVudD4gIDwvZGVmcz4gIDxwYXRoIGZpbGw9InVybCgjYSkiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTIyLjk4MDYyMywxMS42MjYyMzc3IEMyMi44NzE3MTA3LDExLjUwNTEzMDYgMjIuNzM1NTcwNCwxMS4zOTc0Nzk4IDIyLjU3MjIwMjEsMTEuMzE2NzQxOCBDMjIuNTU4NTg4MSwxMS4zMTY3NDE4IDIyLjU0NDk3NCwxMS4yODk4MjkxIDIyLjUzMTM2LDExLjI3NjM3MjcgTDIzLjE3MTIxOTQsNy4zNjA1NzY2MSBDMjMuMTcxMjE5NCw3LjMzMzY2MzkyIDIzLjE4NDgzMzQsNy4zMjAyMDc1OCAyMy4xOTg0NDc1LDcuMzIwMjA3NTggTDIzLjIxMjA2MTUsNy4zMjAyMDc1OCBDMjMuMjEyMDYxNSw3LjMyMDIwNzU4IDIzLjIyNTY3NTUsNy4zMjAyMDc1OCAyMy4yMzkyODk2LDcuMzMzNjYzOTIgTDI2LjE2NjMwNiwxMC4yMjY3Nzc5IEMyNi4xNzk5MiwxMC4yNDAyMzQzIDI2LjE3OTkyLDEwLjI1MzY5MDYgMjYuMTc5OTIsMTAuMjY3MTQ2OSBDMjYuMTc5OTIsMTAuMjgwNjAzMyAyNi4xNjYzMDYsMTAuMjk0MDU5NiAyNi4xNTI2OTE5LDEwLjMwNzUxNiBMMjMuMDIxNDY1MSwxMS42Mzk2OTQgTDIzLjAwNzg1MSwxMS42Mzk2OTQgQzIyLjk5NDIzNywxMS42Mzk2OTQgMjIuOTk0MjM3LDExLjYzOTY5NCAyMi45ODA2MjMsMTEuNjI2MjM3NyBaIE0xNi4zNTA1NzM2LDkuNDU5NzM4MSBDMTYuMzIzMzQ1Myw5LjE5MDYxMjc0IDE2LjIyODA0NjMsOC45MjE0ODczOCAxNi4wNzgyOTA2LDguNjkyNzMwODMgQzE2LjA2NDY3NjUsOC42NzkyNzQ1NiAxNi4wNjQ2NzY1LDguNjUyMzYyMDIgMTYuMDc4MjkwNiw4LjYyNTQ0OTQ5IEwxOS4zNTkzMDEsMy41Mzg5ODAyMiBDMTkuMzU5MzAxLDMuNTI1NTIzOTUgMTkuMzcyOTE1MSwzLjUxMjA2NzY4IDE5LjM4NjUyOTMsMy41MTIwNjc2OCBDMTkuNDAwMTQzNCwzLjUxMjA2NzY4IDE5LjQwMDE0MzQsMy41MTIwNjc2OCAxOS40MTM3NTc2LDMuNTI1NTIzOTUgTDIyLjMyNzE4NTgsNi40MTg2MjE1NSBDMjIuMzQwOCw2LjQzMjA3NzgyIDIyLjM0MDgsNi40NDU1MzQwOSAyMi4zNDA4LDYuNDU4OTkwMzUgTDIxLjU3ODQwNzYsMTEuMTgyMTQwNCBDMjEuNTc4NDA3NiwxMS4yMDkwNTI5IDIxLjU2NDc5MzQsMTEuMjIyNTA5MiAyMS41NTExNzkzLDExLjIyMjUwOTIgQzIxLjM3NDE5NTMsMTEuMjc2MzM0MyAyMS4yMTA4MjU1LDExLjM1NzA3MTkgMjEuMDc0Njg0LDExLjQ2NDcyMiBDMjEuMDc0Njg0LDExLjQ3ODE3ODMgMjEuMDYxMDY5OCwxMS40NzgxNzgzIDIxLjAzMzg0MTUsMTEuNDc4MTc4MyBMMTYuMzc3ODAxOSw5LjUwMDEwNjkgQzE2LjM2NDE4NzgsOS40ODY2NTA2MyAxNi4zNTA1NzM2LDkuNDczMTk0MzcgMTYuMzUwNTczNiw5LjQ1OTczODEgWiBNMjYuOTgzMTkwNywxMS4wMjA3NjY5IEwzMS45Nzk1Nzg4LDE1Ljk3MjY2NCBDMzIuMDA2ODA3MSwxNS45ODYxMjAyIDMyLjAwNjgwNzEsMTYuMDI2NDg4OSAzMS45Nzk1Nzg4LDE2LjAyNjQ4ODkgTDMxLjk1MjM1MDUsMTYuMDUzNDAxNCBDMzEuOTUyMzUwNSwxNi4wNjY4NTc3IDMxLjkzODczNjQsMTYuMDY2ODU3NyAzMS45MTE1MDgxLDE2LjA2Njg1NzcgTDIzLjU1MjQyODMsMTIuNTI3ODY2IEMyMy41Mzg4MTQxLDEyLjUyNzg2NiAyMy41MjUyLDEyLjUwMDk1MzUgMjMuNTI1MiwxMi40ODc0OTczIEMyMy41MjUyLDEyLjQ3NDA0MSAyMy41Mzg4MTQxLDEyLjQ2MDU4NDggMjMuNTUyNDI4MywxMi40NDcxMjg2IEwyNi45NTU5NjI0LDExLjAwNzMxMDcgQzI2Ljk1NTk2MjQsMTEuMDA3MzEwNyAyNi45Njk1NzY1LDExLjAwNzMxMDcgMjYuOTgzMTkwNywxMS4wMjA3NjY5IFogTTIzLjEzMDQzNjMsMTMuMzg5MDg4MSBMMzEuMTQ5MTg1OCwxNi43ODAwNzYxIEMzMS4xNjI4LDE2Ljc5MzUzMjQgMzEuMTYyOCwxNi44MDY5ODg3IDMxLjE2MjgsMTYuODIwNDQ1IEMzMS4xNjI4LDE2LjgzMzkwMTMgMzEuMTYyOCwxNi44NDczNTc2IDMxLjE0OTE4NTgsMTYuODYwODEzOSBMMjYuNzEwOTY0NSwyMS4yNjEwMjQ1IEMyNi43MTA5NjQ1LDIxLjI3NDQ4MDggMjYuNjk3MzUwMywyMS4yNzQ0ODA4IDI2LjY3MDEyMiwyMS4yNzQ0ODA4IEwyMS44MjM0NzU0LDIwLjI2NTI1ODIgQzIxLjc5NjI0NywyMC4yNjUyNTgyIDIxLjc4MjYzMjksMjAuMjUxODAxOSAyMS43ODI2MzI5LDIwLjIyNDg4OTMgQzIxLjc0MTc5MDMsMTkuODQ4MTEyOCAyMS41NjQ4MDYsMTkuNTExNzA1MyAyMS4yNjUyOTQyLDE5LjI4Mjk0ODEgQzIxLjI1MTY4LDE5LjI2OTQ5MTggMjEuMjUxNjgsMTkuMjU2MDM1NSAyMS4yNTE2OCwxOS4yNDI1NzkyIEwyMi4xMDkzNzMxLDEzLjk4MTE2NTMgQzIyLjEwOTM3MzEsMTMuOTU0MjUyNyAyMi4xMzY2MDE0LDEzLjk0MDc5NjQgMjIuMTUwMjE1NiwxMy45NDA3OTY0IEMyMi41MzE0MTI1LDEzLjg4Njk3MTIgMjIuODU4MTUyNywxMy42OTg1ODMgMjMuMDc1OTc5NiwxMy40MDI1NDQ0IEMyMy4wODk1OTM3LDEzLjM4OTA4ODEgMjMuMTAzMjA3OSwxMy4zODkwODgxIDIzLjEzMDQzNjMsMTMuMzg5MDg4MSBaIE0xNi4xNDYzNzksMTAuNDI4Njg1OSBMMjAuNTMwMTMxNywxMi4yODU2NTMyIEMyMC41NDM3NDU5LDEyLjI5OTEwOTUgMjAuNTU3MzYsMTIuMzEyNTY1OCAyMC41NTczNiwxMi4zMzk0NzgzIEMyMC41NDM3NDU5LDEyLjQwNjc1OTggMjAuNTMwMTMxNywxMi40ODc0OTc1IDIwLjUzMDEzMTcsMTIuNTY4MjM1MiBMMjAuNTMwMTMxNywxMi42MzU1MTY2IEwyMC41MzAxMzE3LDEyLjY4OTM0MTcgQzIwLjUzMDEzMTcsMTIuNzAyNzk4IDIwLjUxNjUxNzYsMTIuNzE2MjU0MyAyMC41MDI5MDM0LDEyLjcyOTcxMDYgQzIwLjUwMjkwMzQsMTIuNzI5NzEwNiAxMC44Nzc3MDcyLDE2LjgzMzg3NzUgMTAuODY0MDkzLDE2LjgzMzg3NzUgQzEwLjg1MDQ3ODksMTYuODMzODc3NSAxMC44MzY4NjQ3LDE2LjgzMzg3NzUgMTAuODIzMjUwNiwxNi44MjA0MjEyIEMxMC44MDk2MzY1LDE2LjgwNjk2NDkgMTAuODA5NjM2NSwxNi43ODAwNTI0IDEwLjgyMzI1MDYsMTYuNzY2NTk2MSBMMTQuNDMwOTk3NCwxMS4xODIyMzc4IEMxNC40NDQ2MTE2LDExLjE2ODc4MTUgMTQuNDU4MjI1NywxMS4xNTUzMjUzIDE0LjQ4NTQ1NCwxMS4xNTUzMjUzIEMxNC41ODA3NTMsMTEuMTY4NzgxNSAxNC42NjI0Mzc4LDExLjE4MjIzNzggMTQuNzQ0MTIyNiwxMS4xODIyMzc4IEMxNS4yODg2ODgyLDExLjE4MjIzNzggMTUuNzkyNDExMywxMC45MTMxMTIxIDE2LjA5MTkyMjQsMTAuNDU1NTk4NCBDMTYuMTA1NTM2NSwxMC40NDIxNDIyIDE2LjExOTE1MDcsMTAuNDI4Njg1OSAxNi4xNDYzNzksMTAuNDI4Njg1OSBaIE0yMS41NTExNDI5LDIxLjE4MDI0MzMgTDI1LjgxMjM3MTcsMjIuMDU0OTA1MyBDMjUuODI1OTg1OSwyMi4wNTQ5MDUzIDI1LjgzOTYsMjIuMDY4MzYxNiAyNS44Mzk2LDIyLjEwODczMDcgQzI1LjgzOTYsMjIuMTIyMTg3IDI1LjgzOTYsMjIuMTM1NjQzMyAyNS44MjU5ODU5LDIyLjE0OTA5OTcgTDE5LjkxNzQ0NDksMjguMDAyNjA3MiBDMTkuOTE3NDQ0OSwyOC4wMTYwNjM2IDE5LjkwMzgzMDcsMjguMDE2MDYzNiAxOS44OTAyMTY2LDI4LjAxNjA2MzYgTDE5Ljg2Mjk4ODMsMjguMDE2MDYzNiBDMTkuODQ5Mzc0MSwyOC4wMDI2MDcyIDE5LjgzNTc2LDI3Ljk4OTE1MDkgMTkuODM1NzYsMjcuOTYyMjM4MiBMMjAuODU2ODIxMiwyMS42OTE1ODQxIEMyMC44NTY4MjEyLDIxLjY3ODEyNzggMjAuODcwNDM1NCwyMS42NTEyMTUxIDIwLjg4NDA0OTUsMjEuNjUxMjE1MSBDMjEuMTI5MTA0MiwyMS41NTcwMjA4IDIxLjMzMzMxNjUsMjEuMzk1NTQ0NyAyMS40OTY2ODYzLDIxLjE5MzY5OTYgQzIxLjUxMDMwMDQsMjEuMTkzNjk5NiAyMS41MjM5MTQ2LDIxLjE4MDI0MzMgMjEuNTUxMTQyOSwyMS4xODAyNDMzIFogTTE5LjA0NjE2NzksMjAuNjgyNDAzIEMxOS4xNTUwODE0LDIxLjA5OTU0ODcgMTkuNDU0NTkzMywyMS40NjI4NjkyIDE5Ljg2MzAxODcsMjEuNjI0MzQ0OSBDMTkuODkwMjQ3MSwyMS42Mzc4MDEyIDE5Ljg5MDI0NzEsMjEuNjY0NzEzOSAxOS44NjMwMTg3LDIxLjY2NDcxMzkgQzE5Ljg2MzAxODcsMjEuNjY0NzEzOSAxOC42MjQxMjgzLDI5LjIxMzcwNTQgMTguNjI0MTI4MywyOS4yMjcxNjE3IEwxOC4xODg0NzQ2LDI5LjY1Nzc2MzcgQzE4LjE4ODQ3NDYsMjkuNjcxMjIwMSAxOC4xNzQ4NjA0LDI5LjY3MTIyMDEgMTguMTYxMjQ2MiwyOS42NzEyMjAxIEMxOC4xNDc2MzIsMjkuNjcxMjIwMSAxOC4xNDc2MzIsMjkuNjcxMjIwMSAxOC4xMzQwMTc4LDI5LjY1Nzc2MzcgTDEwLjk0NTczMDYsMTkuMjY5NDkwMSBDMTAuOTMyMTE2NSwxOS4yNTYwMzM4IDEwLjkzMjExNjUsMTkuMjI5MTIxMiAxMC45NDU3MzA2LDE5LjIxNTY2NDkgQzEwLjk4NjU3MzIsMTkuMTYxODM5NiAxMS4wMTM4MDE1LDE5LjEwODAxNDQgMTEuMDU0NjQ0MSwxOS4wNDA3MzI4IEMxMS4wNjgyNTgzLDE5LjAyNzI3NjUgMTEuMDgxODcyNCwxOS4wMTM4MjAyIDExLjEwOTEwMDgsMTkuMDEzODIwMiBMMTkuMDA1MzI1NCwyMC42NDIwMzQxIEMxOS4wMzI1NTM3LDIwLjY1NTQ5MDQgMTkuMDQ2MTY3OSwyMC42Njg5NDY3IDE5LjA0NjE2NzksMjAuNjgyNDAzIFogTTExLjMxMzM2NDcsMTguMDk4NzI4NiBDMTEuMjg2MTM2NSwxOC4wOTg3Mjg2IDExLjI3MjUyMjQsMTguMDg1MjcyNCAxMS4yNzI1MjI0LDE4LjA1ODM1OTggQzExLjI3MjUyMjQsMTcuOTUwNzA5NiAxMS4yNDUyOTQxLDE3Ljg1NjUxNTcgMTEuMjMxNjgsMTcuNzQ4ODY1NCBDMTEuMjMxNjgsMTcuNzIxOTUyOSAxMS4yMzE2OCwxNy43MDg0OTY2IDExLjI1ODkwODIsMTcuNjk1MDQwMyBDMTEuMjU4OTA4MiwxNy42OTUwNDAzIDIwLjkzODU0NTksMTMuNTYzOTYzNSAyMC45NTIxNiwxMy41NjM5NjM1IEMyMC45NTIxNiwxMy41NjM5NjM1IDIwLjk2NTc3NDEsMTMuNTYzOTYzNSAyMC45NzkzODgyLDEzLjU3NzQxOTcgQzIxLjA0NzQ1ODgsMTMuNjQ0NzAxMSAyMS4xMDE5MTUzLDEzLjY4NTA2OTkgMjEuMTU2MzcxOCwxMy43MjU0Mzg4IEMyMS4xODM2LDEzLjcyNTQzODggMjEuMTgzNiwxMy43NTIzNTEzIDIxLjE4MzYsMTMuNzY1ODA3NiBMMjAuMzM5NTI0NywxOC45NDY0NzQxIEMyMC4zMzk1MjQ3LDE4Ljk3MzM4NjYgMjAuMzI1OTEwNiwxOC45ODY4NDI5IDIwLjI5ODY4MjQsMTguOTg2ODQyOSBDMTkuODM1ODAyNCwxOS4wMTM3NTU0IDE5LjQyNzM3ODgsMTkuMjgyODgxIDE5LjE5NTkzODgsMTkuNjg2NTY5MyBDMTkuMTgyMzI0NywxOS43MDAwMjU1IDE5LjE2ODcxMDYsMTkuNzEzNDgxOCAxOS4xNDE0ODI0LDE5LjcxMzQ4MTggTDExLjMxMzM2NDcsMTguMDk4NzI4NiBaIE03Ljg2ODk3NzU4LDE5LjE4ODcyOTEgQzcuOTA5ODIwMywxOS4yNTYwMTExIDcuOTUwNjYzMDMsMTkuMzA5ODM2NyA3Ljk5MTUwNTc2LDE5LjM2MzY2MjMgQzguMDA1MTIsMTkuMzc3MTE4NyA4LjAwNTEyLDE5LjM5MDU3NTEgOC4wMDUxMiwxOS4zOTA1NzUxIEw2LjEzOTk2ODc5LDIyLjI4MzcwMDcgQzYuMTI2MzU0NTUsMjIuMjk3MTU3MSA2LjExMjc0MDMsMjIuMzEwNjEzNSA2LjA5OTEyNjA2LDIyLjMxMDYxMzUgQzYuMDk5MTI2MDYsMjIuMzEwNjEzNSA2LjA4NTUxMTgyLDIyLjMxMDYxMzUgNi4wNzE4OTc1OCwyMi4yOTcxNTcxIEw0LjQyNDU3NDI0LDIwLjY2ODkzMjkgQzQuNDEwOTYsMjAuNjU1NDc2NSA0LjQxMDk2LDIwLjY0MjAyMDEgNC40MTA5NiwyMC42Mjg1NjM3IEM0LjQxMDk2LDIwLjYxNTEwNzMgNC40MjQ1NzQyNCwyMC42MDE2NTA5IDQuNDM4MTg4NDgsMjAuNjAxNjUwOSBMNy44MTQ1MjA2MSwxOS4xNjE4MTYzIEw3LjgyODEzNDg1LDE5LjE2MTgxNjMgQzcuODQxNzQ5MDksMTkuMTYxODE2MyA3Ljg1NTM2MzMzLDE5LjE3NTI3MjcgNy44Njg5Nzc1OCwxOS4xODg3MjkxIFogTTEwLjE4MzMxOTEsMTkuODYxNTU3OSBDMTAuMTk2OTMzMiwxOS44NjE1NTc5IDEwLjIxMDU0NzMsMTkuODc1MDE0MiAxMC4yMjQxNjE0LDE5Ljg4ODQ3MDYgTDE3LjQzOTYyOTQsMzAuMzU3NDg3OCBDMTcuNDUzMjQzNSwzMC4zNzA5NDQxIDE3LjQ1MzI0MzUsMzAuMzk3ODU2NyAxNy40Mzk2Mjk0LDMwLjQxMTMxMzEgTDE1Ljg2MDM5NDksMzEuOTg1NzAyNSBDMTUuODYwMzk0OSwzMS45OTkxNTg5IDE1Ljg0Njc4MDgsMzEuOTk5MTU4OSAxNS44MDU5Mzg2LDMxLjk4NTcwMjUgTDYuNzkzNDEwNTcsMjMuMDY0MTYyMiBDNi43Nzk3OTY0OCwyMy4wNTA3MDU4IDYuNzc5Nzk2NDgsMjMuMDIzNzkzMiA2LjgwNzAyNDY2LDIyLjk5Njg4MDYgTDguNzY3NDUzNzEsMTkuOTU1NzUyMiBDOC43ODEwNjc4LDE5Ljk0MjI5NTggOC43OTQ2ODE4OSwxOS45Mjg4Mzk1IDguODIxOTEwMDcsMTkuOTI4ODM5NSBDOS4wMjYxMjE0MywxOS45OTYxMjExIDkuMjE2NzE4NywyMC4wMjMwMzM4IDkuNDIwOTMwMDYsMjAuMDIzMDMzOCBDOS42Nzk1OTc3OCwyMC4wMjMwMzM4IDkuOTI0NjUxNDEsMTkuOTY5MjA4NSAxMC4xODMzMTkxLDE5Ljg2MTU1NzkgWiBNOC45OTg5MTg1NiwxNi40MDMyMzIyIEM4Ljk4NTMwNDM5LDE2LjQwMzIzMjIgOC45NzE2OTAyMiwxNi4zODk3NzU5IDguOTU4MDc2MDQsMTYuMzc2MzE5NiBMNS4wOTE2NTA2MywxMC43MzgxMzg4IEM1LjA3ODAzNjQ2LDEwLjcyNDY4MjUgNS4wNzgwMzY0NiwxMC42OTc3NyA1LjA5MTY1MDYzLDEwLjY4NDMxMzcgTDguNTYzMjY1LDcuMjM5NTA2MzMgQzguNTYzMjY1LDcuMjI2MDUwMDYgOC41NzY4NzkxNyw3LjIyNjA1MDA2IDguNjA0MTA3NTIsNy4yMjYwNTAwNiBDOC42MDQxMDc1Miw3LjIzOTUwNjMzIDEyLjcwMTk3MzksOC45NjE5MTAwMiAxMy4xNjQ4NTU4LDkuMTYzNzU0MiBDMTMuMTc4NDcsOS4xNzcyMTA0OCAxMy4xOTIwODQyLDkuMTkwNjY2NzYgMTMuMTkyMDg0Miw5LjIxNzU3OTMyIEMxMy4xNjQ4NTU4LDkuMzM4Njg1ODMgMTMuMTUxMjQxNiw5LjQ1OTc5MjM0IDEzLjE1MTI0MTYsOS41ODA4OTg4NCBDMTMuMTUxMjQxNiw5Ljk5ODA0MzQ5IDEzLjMxNDYxMTcsMTAuMzg4Mjc1NiAxMy42MDA1MDk0LDEwLjY4NDMxMzcgQzEzLjYxNDEyMzUsMTAuNjk3NzcgMTMuNjE0MTIzNSwxMC43MjQ2ODI1IDEzLjYwMDUwOTQsMTAuNzM4MTM4OCBMOS45NTE5MTA3NCwxNi4zODk3NzU5IEM5LjkzODI5NjU3LDE2LjQwMzIzMjIgOS45MjQ2ODIzOSwxNi40MTY2ODg1IDkuODk3NDU0MDUsMTYuNDE2Njg4NSBDOS43NDc2OTgxMywxNi4zNzYzMTk2IDkuNTg0MzI4MDQsMTYuMzQ5NDA3MSA5LjQzNDU3MjEzLDE2LjM0OTQwNzEgQzkuMjk4NDMwMzksMTYuMzQ5NDA3MSA5LjE0ODY3NDQ4LDE2LjM3NjMxOTYgOC45OTg5MTg1NiwxNi40MDMyMzIyIFogTTEzLjY2ODYwMTksOC4zNTY0MjAzNCBDMTMuNDkxNjE4Niw4LjI3NTY4MTk4IDkuMzUyOTMzMjQsNi41MjYzNTA4MyA5LjM1MjkzMzI0LDYuNTI2MzUwODMgQzkuMzM5MzE5MTQsNi41MTI4OTQ0NCA5LjMyNTcwNTA1LDYuNTEyODk0NDQgOS4zMzkzMTkxNCw2LjQ4NTk4MTY1IEM5LjMzOTMxOTE0LDYuNDcyNTI1MjYgOS4zMzkzMTkxNCw2LjQ1OTA2ODg2IDkuMzUyOTMzMjQsNi40NDU2MTI0NyBMMTUuODMzMjQzMiwwLjAxMzQ1NjM5MzUgQzE1LjgzMzI0MzIsMCAxNS44NDY4NTczLDAgMTUuODYwNDcxNCwwIEMxNS44NzQwODU1LDAgMTUuODc0MDg1NSwwIDE1Ljg4NzY5OTYsMC4wMTM0NTYzOTM1IEwxOC42Nzg1ODk0LDIuNzcyMDE3MDUgQzE4LjY5MjIwMzUsMi43ODU0NzM0NSAxOC42OTIyMDM1LDIuODEyMzg2MjMgMTguNjc4NTg5NCwyLjgyNTg0MjYzIEwxNS4zMTU5MDc2LDguMDMzNDY2OSBDMTUuMzAyMjkzNSw4LjA0NjkyMzI5IDE1LjI4ODY3OTQsOC4wNjAzNzk2OSAxNS4yNjE0NTEyLDguMDYwMzc5NjkgQzE1LjA4NDQ2NzksOC4wMDY1NTQxMSAxNC45MDc0ODQ3LDcuOTc5NjQxMzMgMTQuNzMwNTAxNCw3Ljk3OTY0MTMzIEMxNC4zNjI5MjA4LDcuOTc5NjQxMzMgMTMuOTk1MzQwMiw4LjExNDIwNTI2IDEzLjcwOTQ0NDIsOC4zNDI5NjM5NSBDMTMuNjk1ODMwMSw4LjM1NjQyMDM0IDEzLjY5NTgzMDEsOC4zNTY0MjAzNCAxMy42Njg2MDE5LDguMzU2NDIwMzQgWiBNNy43ODcyODk5NSwxNy4zMzE3NTExIEM3Ljc3MzY3NTgxLDE3LjM0NTIwNzQgNy43NjAwNjE2NywxNy4zNTg2NjM3IDcuNzQ2NDQ3NTIsMTcuMzU4NjYzNyBMMC4wNDA4NDI0Mjk4LDE1Ljc0MzkwOCBDMC4wMTM2MTQxNDMzLDE1Ljc0MzkwOCAwLDE1LjczMDQ1MTcgMCwxNS43MTY5OTU0IEMwLDE1LjcwMzUzOTEgMCwxNS42OTAwODI4IDAuMDEzNjE0MTQzMywxNS42NzY2MjY1IEw0LjMxNTY4MzQyLDExLjQyNDQzNjMgQzQuMzE1NjgzNDIsMTEuNDEwOTgwMSA0LjMyOTI5NzU2LDExLjQxMDk4MDEgNC4zNDI5MTE3MSwxMS40MTA5ODAxIEM0LjM3MDEzOTk5LDExLjQyNDQzNjMgNC4zNzAxMzk5OSwxMS40MjQ0MzYzIDQuMzgzNzU0MTMsMTEuNDM3ODkyNiBDNC4zODM3NTQxMywxMS40NTEzNDg5IDguMDczMTg2OTYsMTYuNzgwMDQyOSA4LjExNDAyOTM5LDE2LjgzMzg2ODEgQzguMTI3NjQzNTQsMTYuODQ3MzI0NCA4LjEyNzY0MzU0LDE2Ljg3NDIzNyA4LjExNDAyOTM5LDE2Ljg4NzY5MzMgQzcuOTkxNTAyMSwxNy4wMjIyNTYzIDcuODY4OTc0ODEsMTcuMTcwMjc1NSA3Ljc4NzI4OTk1LDE3LjMzMTc1MTEgWiBNNy4zNTE1NTc4MywxOC4yNDY3NDY0IEM3LjM3ODc4NTk0LDE4LjI0Njc0NjQgNy4zOTI0LDE4LjI2MDIwMjcgNy4zOTI0LDE4LjI4NzExNTEgQzcuMzkyNCwxOC4zMDA1NzEzIDcuMzc4Nzg1OTQsMTguMzE0MDI3NSA3LjM1MTU1NzgzLDE4LjM0MDkzOTkgTDMuNjM0OTIsMTkuOTE1MzE2NSBDMy42MzQ5MiwxOS45MTUzMTY1IDMuNjIxMzA1OTQsMTkuOTE1MzE2NSAzLjYwNzY5MTg4LDE5LjkwMTg2MDMgTDAuNjI2MjEzMTg1LDE2Ljk0MTQ5NDEgQzAuNjEyNTk5MTI3LDE2LjkyODAzNzggMC41OTg5ODUwNjksMTYuOTAxMTI1NCAwLjYxMjU5OTEyNywxNi44ODc2NjkyIEMwLjYyNjIxMzE4NSwxNi44NzQyMTMgMC42Mzk4MjcyNDMsMTYuODYwNzU2OCAwLjY2NzA1NTM1OSwxNi44NjA3NTY4IEw3LjM1MTU1NzgzLDE4LjI0Njc0NjQgWiIvPjwvc3ZnPg==);\\n}\\n\\n.visuallyHidden {\\n  border: 0;\\n  clip: rect(0 0 0 0);\\n  height: 1px;\\n  margin: -1px;\\n  overflow: hidden;\\n  padding: 0;\\n  position: absolute;\\n  width: 1px;\\n  white-space: nowrap;\\n}\\n\\n.subheader {\\n  margin-top: 2em;\\n  border-top: 1px solid rgb(14, 30, 37);\\n\\n  h3 {\\n    padding-top: 1em;\\n    text-align: center;\\n  }\\n}\\n'], sourceRoot: \"\" }]), n.default = o;\n  }]).default;\n});\n\n\n//# sourceURL=webpack://cms_git/./node_modules/netlify-identity-widget/build/netlify-identity.js?");

/***/ }),

/***/ "./node_modules/rope-sequence/dist/index.es.js":
/*!*****************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.es.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar GOOD_LEAF_SIZE = 200;\nvar RopeSequence = function RopeSequence2() {\n};\nRopeSequence.prototype.append = function append(other) {\n  if (!other.length) {\n    return this;\n  }\n  other = RopeSequence.from(other);\n  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);\n};\nRopeSequence.prototype.prepend = function prepend(other) {\n  if (!other.length) {\n    return this;\n  }\n  return RopeSequence.from(other).append(this);\n};\nRopeSequence.prototype.appendInner = function appendInner(other) {\n  return new Append(this, other);\n};\nRopeSequence.prototype.slice = function slice(from2, to) {\n  if (from2 === void 0)\n    from2 = 0;\n  if (to === void 0)\n    to = this.length;\n  if (from2 >= to) {\n    return RopeSequence.empty;\n  }\n  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));\n};\nRopeSequence.prototype.get = function get(i) {\n  if (i < 0 || i >= this.length) {\n    return void 0;\n  }\n  return this.getInner(i);\n};\nRopeSequence.prototype.forEach = function forEach(f, from2, to) {\n  if (from2 === void 0)\n    from2 = 0;\n  if (to === void 0)\n    to = this.length;\n  if (from2 <= to) {\n    this.forEachInner(f, from2, to, 0);\n  } else {\n    this.forEachInvertedInner(f, from2, to, 0);\n  }\n};\nRopeSequence.prototype.map = function map(f, from2, to) {\n  if (from2 === void 0)\n    from2 = 0;\n  if (to === void 0)\n    to = this.length;\n  var result = [];\n  this.forEach(function(elt, i) {\n    return result.push(f(elt, i));\n  }, from2, to);\n  return result;\n};\nRopeSequence.from = function from(values) {\n  if (values instanceof RopeSequence) {\n    return values;\n  }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty;\n};\nvar Leaf = /* @__PURE__ */ function(RopeSequence3) {\n  function Leaf2(values) {\n    RopeSequence3.call(this);\n    this.values = values;\n  }\n  if (RopeSequence3)\n    Leaf2.__proto__ = RopeSequence3;\n  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);\n  Leaf2.prototype.constructor = Leaf2;\n  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };\n  Leaf2.prototype.flatten = function flatten() {\n    return this.values;\n  };\n  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {\n    if (from2 == 0 && to == this.length) {\n      return this;\n    }\n    return new Leaf2(this.values.slice(from2, to));\n  };\n  Leaf2.prototype.getInner = function getInner(i) {\n    return this.values[i];\n  };\n  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {\n    for (var i = from2; i < to; i++) {\n      if (f(this.values[i], start + i) === false) {\n        return false;\n      }\n    }\n  };\n  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {\n    for (var i = from2 - 1; i >= to; i--) {\n      if (f(this.values[i], start + i) === false) {\n        return false;\n      }\n    }\n  };\n  Leaf2.prototype.leafAppend = function leafAppend(other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE) {\n      return new Leaf2(this.values.concat(other.flatten()));\n    }\n  };\n  Leaf2.prototype.leafPrepend = function leafPrepend(other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE) {\n      return new Leaf2(other.flatten().concat(this.values));\n    }\n  };\n  prototypeAccessors.length.get = function() {\n    return this.values.length;\n  };\n  prototypeAccessors.depth.get = function() {\n    return 0;\n  };\n  Object.defineProperties(Leaf2.prototype, prototypeAccessors);\n  return Leaf2;\n}(RopeSequence);\nRopeSequence.empty = new Leaf([]);\nvar Append = /* @__PURE__ */ function(RopeSequence3) {\n  function Append2(left, right) {\n    RopeSequence3.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n  if (RopeSequence3)\n    Append2.__proto__ = RopeSequence3;\n  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);\n  Append2.prototype.constructor = Append2;\n  Append2.prototype.flatten = function flatten() {\n    return this.left.flatten().concat(this.right.flatten());\n  };\n  Append2.prototype.getInner = function getInner(i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);\n  };\n  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {\n    var leftLen = this.left.length;\n    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {\n      return false;\n    }\n    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {\n      return false;\n    }\n  };\n  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {\n    var leftLen = this.left.length;\n    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {\n      return false;\n    }\n    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {\n      return false;\n    }\n  };\n  Append2.prototype.sliceInner = function sliceInner(from2, to) {\n    if (from2 == 0 && to == this.length) {\n      return this;\n    }\n    var leftLen = this.left.length;\n    if (to <= leftLen) {\n      return this.left.slice(from2, to);\n    }\n    if (from2 >= leftLen) {\n      return this.right.slice(from2 - leftLen, to - leftLen);\n    }\n    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));\n  };\n  Append2.prototype.leafAppend = function leafAppend(other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) {\n      return new Append2(this.left, inner);\n    }\n  };\n  Append2.prototype.leafPrepend = function leafPrepend(other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) {\n      return new Append2(inner, this.right);\n    }\n  };\n  Append2.prototype.appendInner = function appendInner2(other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {\n      return new Append2(this.left, new Append2(this.right, other));\n    }\n    return new Append2(this, other);\n  };\n  return Append2;\n}(RopeSequence);\nvar ropeSequence = RopeSequence;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ropeSequence);\n\n\n//# sourceURL=webpack://cms_git/./node_modules/rope-sequence/dist/index.es.js?");

/***/ }),

/***/ "./node_modules/showdown/dist/showdown.js":
/*!************************************************!*\
  !*** ./node_modules/showdown/dist/showdown.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;\n/*! showdown v 2.1.0 - 21-04-2022 */\n(function() {\n  function getDefaultOpts(simple) {\n    \"use strict\";\n    var defaultOptions = {\n      omitExtraWLInCodeBlocks: {\n        defaultValue: false,\n        describe: \"Omit the default extra whiteline added to code blocks\",\n        type: \"boolean\"\n      },\n      noHeaderId: {\n        defaultValue: false,\n        describe: \"Turn on/off generated header id\",\n        type: \"boolean\"\n      },\n      prefixHeaderId: {\n        defaultValue: false,\n        describe: \"Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix\",\n        type: \"string\"\n      },\n      rawPrefixHeaderId: {\n        defaultValue: false,\n        describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the \" char is used in the prefix)',\n        type: \"boolean\"\n      },\n      ghCompatibleHeaderId: {\n        defaultValue: false,\n        describe: \"Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)\",\n        type: \"boolean\"\n      },\n      rawHeaderId: {\n        defaultValue: false,\n        describe: `Remove only spaces, ' and \" from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`,\n        type: \"boolean\"\n      },\n      headerLevelStart: {\n        defaultValue: false,\n        describe: \"The header blocks level start\",\n        type: \"integer\"\n      },\n      parseImgDimensions: {\n        defaultValue: false,\n        describe: \"Turn on/off image dimension parsing\",\n        type: \"boolean\"\n      },\n      simplifiedAutoLink: {\n        defaultValue: false,\n        describe: \"Turn on/off GFM autolink style\",\n        type: \"boolean\"\n      },\n      excludeTrailingPunctuationFromURLs: {\n        defaultValue: false,\n        describe: \"Excludes trailing punctuation from links generated with autoLinking\",\n        type: \"boolean\"\n      },\n      literalMidWordUnderscores: {\n        defaultValue: false,\n        describe: \"Parse midword underscores as literal underscores\",\n        type: \"boolean\"\n      },\n      literalMidWordAsterisks: {\n        defaultValue: false,\n        describe: \"Parse midword asterisks as literal asterisks\",\n        type: \"boolean\"\n      },\n      strikethrough: {\n        defaultValue: false,\n        describe: \"Turn on/off strikethrough support\",\n        type: \"boolean\"\n      },\n      tables: {\n        defaultValue: false,\n        describe: \"Turn on/off tables support\",\n        type: \"boolean\"\n      },\n      tablesHeaderId: {\n        defaultValue: false,\n        describe: \"Add an id to table headers\",\n        type: \"boolean\"\n      },\n      ghCodeBlocks: {\n        defaultValue: true,\n        describe: \"Turn on/off GFM fenced code blocks support\",\n        type: \"boolean\"\n      },\n      tasklists: {\n        defaultValue: false,\n        describe: \"Turn on/off GFM tasklist support\",\n        type: \"boolean\"\n      },\n      smoothLivePreview: {\n        defaultValue: false,\n        describe: \"Prevents weird effects in live previews due to incomplete input\",\n        type: \"boolean\"\n      },\n      smartIndentationFix: {\n        defaultValue: false,\n        describe: \"Tries to smartly fix indentation in es6 strings\",\n        type: \"boolean\"\n      },\n      disableForced4SpacesIndentedSublists: {\n        defaultValue: false,\n        describe: \"Disables the requirement of indenting nested sublists by 4 spaces\",\n        type: \"boolean\"\n      },\n      simpleLineBreaks: {\n        defaultValue: false,\n        describe: \"Parses simple line breaks as <br> (GFM Style)\",\n        type: \"boolean\"\n      },\n      requireSpaceBeforeHeadingText: {\n        defaultValue: false,\n        describe: \"Makes adding a space between `#` and the header text mandatory (GFM Style)\",\n        type: \"boolean\"\n      },\n      ghMentions: {\n        defaultValue: false,\n        describe: \"Enables github @mentions\",\n        type: \"boolean\"\n      },\n      ghMentionsLink: {\n        defaultValue: \"https://github.com/{u}\",\n        describe: \"Changes the link generated by @mentions. Only applies if ghMentions option is enabled.\",\n        type: \"string\"\n      },\n      encodeEmails: {\n        defaultValue: true,\n        describe: \"Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities\",\n        type: \"boolean\"\n      },\n      openLinksInNewWindow: {\n        defaultValue: false,\n        describe: \"Open all links in new windows\",\n        type: \"boolean\"\n      },\n      backslashEscapesHTMLTags: {\n        defaultValue: false,\n        describe: \"Support for HTML Tag escaping. ex: <div>foo</div>\",\n        type: \"boolean\"\n      },\n      emoji: {\n        defaultValue: false,\n        describe: \"Enable emoji support. Ex: `this is a :smile: emoji`\",\n        type: \"boolean\"\n      },\n      underline: {\n        defaultValue: false,\n        describe: \"Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`\",\n        type: \"boolean\"\n      },\n      ellipsis: {\n        defaultValue: true,\n        describe: \"Replaces three dots with the ellipsis unicode character\",\n        type: \"boolean\"\n      },\n      completeHTMLDocument: {\n        defaultValue: false,\n        describe: \"Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags\",\n        type: \"boolean\"\n      },\n      metadata: {\n        defaultValue: false,\n        describe: \"Enable support for document metadata (defined at the top of the document between `\\xAB\\xAB\\xAB` and `\\xBB\\xBB\\xBB` or between `---` and `---`).\",\n        type: \"boolean\"\n      },\n      splitAdjacentBlockquotes: {\n        defaultValue: false,\n        describe: \"Split adjacent blockquote blocks\",\n        type: \"boolean\"\n      }\n    };\n    if (simple === false) {\n      return JSON.parse(JSON.stringify(defaultOptions));\n    }\n    var ret = {};\n    for (var opt in defaultOptions) {\n      if (defaultOptions.hasOwnProperty(opt)) {\n        ret[opt] = defaultOptions[opt].defaultValue;\n      }\n    }\n    return ret;\n  }\n  function allOptionsOn() {\n    \"use strict\";\n    var options = getDefaultOpts(true), ret = {};\n    for (var opt in options) {\n      if (options.hasOwnProperty(opt)) {\n        ret[opt] = true;\n      }\n    }\n    return ret;\n  }\n  var showdown = {}, parsers = {}, extensions = {}, globalOptions = getDefaultOpts(true), setFlavor = \"vanilla\", flavor = {\n    github: {\n      omitExtraWLInCodeBlocks: true,\n      simplifiedAutoLink: true,\n      excludeTrailingPunctuationFromURLs: true,\n      literalMidWordUnderscores: true,\n      strikethrough: true,\n      tables: true,\n      tablesHeaderId: true,\n      ghCodeBlocks: true,\n      tasklists: true,\n      disableForced4SpacesIndentedSublists: true,\n      simpleLineBreaks: true,\n      requireSpaceBeforeHeadingText: true,\n      ghCompatibleHeaderId: true,\n      ghMentions: true,\n      backslashEscapesHTMLTags: true,\n      emoji: true,\n      splitAdjacentBlockquotes: true\n    },\n    original: {\n      noHeaderId: true,\n      ghCodeBlocks: false\n    },\n    ghost: {\n      omitExtraWLInCodeBlocks: true,\n      parseImgDimensions: true,\n      simplifiedAutoLink: true,\n      excludeTrailingPunctuationFromURLs: true,\n      literalMidWordUnderscores: true,\n      strikethrough: true,\n      tables: true,\n      tablesHeaderId: true,\n      ghCodeBlocks: true,\n      tasklists: true,\n      smoothLivePreview: true,\n      simpleLineBreaks: true,\n      requireSpaceBeforeHeadingText: true,\n      ghMentions: false,\n      encodeEmails: true\n    },\n    vanilla: getDefaultOpts(true),\n    allOn: allOptionsOn()\n  };\n  showdown.helper = {};\n  showdown.extensions = {};\n  showdown.setOption = function(key, value) {\n    \"use strict\";\n    globalOptions[key] = value;\n    return this;\n  };\n  showdown.getOption = function(key) {\n    \"use strict\";\n    return globalOptions[key];\n  };\n  showdown.getOptions = function() {\n    \"use strict\";\n    return globalOptions;\n  };\n  showdown.resetOptions = function() {\n    \"use strict\";\n    globalOptions = getDefaultOpts(true);\n  };\n  showdown.setFlavor = function(name) {\n    \"use strict\";\n    if (!flavor.hasOwnProperty(name)) {\n      throw Error(name + \" flavor was not found\");\n    }\n    showdown.resetOptions();\n    var preset = flavor[name];\n    setFlavor = name;\n    for (var option in preset) {\n      if (preset.hasOwnProperty(option)) {\n        globalOptions[option] = preset[option];\n      }\n    }\n  };\n  showdown.getFlavor = function() {\n    \"use strict\";\n    return setFlavor;\n  };\n  showdown.getFlavorOptions = function(name) {\n    \"use strict\";\n    if (flavor.hasOwnProperty(name)) {\n      return flavor[name];\n    }\n  };\n  showdown.getDefaultOptions = function(simple) {\n    \"use strict\";\n    return getDefaultOpts(simple);\n  };\n  showdown.subParser = function(name, func) {\n    \"use strict\";\n    if (showdown.helper.isString(name)) {\n      if (typeof func !== \"undefined\") {\n        parsers[name] = func;\n      } else {\n        if (parsers.hasOwnProperty(name)) {\n          return parsers[name];\n        } else {\n          throw Error(\"SubParser named \" + name + \" not registered!\");\n        }\n      }\n    }\n  };\n  showdown.extension = function(name, ext) {\n    \"use strict\";\n    if (!showdown.helper.isString(name)) {\n      throw Error(\"Extension 'name' must be a string\");\n    }\n    name = showdown.helper.stdExtName(name);\n    if (showdown.helper.isUndefined(ext)) {\n      if (!extensions.hasOwnProperty(name)) {\n        throw Error(\"Extension named \" + name + \" is not registered!\");\n      }\n      return extensions[name];\n    } else {\n      if (typeof ext === \"function\") {\n        ext = ext();\n      }\n      if (!showdown.helper.isArray(ext)) {\n        ext = [ext];\n      }\n      var validExtension = validate(ext, name);\n      if (validExtension.valid) {\n        extensions[name] = ext;\n      } else {\n        throw Error(validExtension.error);\n      }\n    }\n  };\n  showdown.getAllExtensions = function() {\n    \"use strict\";\n    return extensions;\n  };\n  showdown.removeExtension = function(name) {\n    \"use strict\";\n    delete extensions[name];\n  };\n  showdown.resetExtensions = function() {\n    \"use strict\";\n    extensions = {};\n  };\n  function validate(extension, name) {\n    \"use strict\";\n    var errMsg = name ? \"Error in \" + name + \" extension->\" : \"Error in unnamed extension\", ret = {\n      valid: true,\n      error: \"\"\n    };\n    if (!showdown.helper.isArray(extension)) {\n      extension = [extension];\n    }\n    for (var i = 0; i < extension.length; ++i) {\n      var baseMsg = errMsg + \" sub-extension \" + i + \": \", ext = extension[i];\n      if (typeof ext !== \"object\") {\n        ret.valid = false;\n        ret.error = baseMsg + \"must be an object, but \" + typeof ext + \" given\";\n        return ret;\n      }\n      if (!showdown.helper.isString(ext.type)) {\n        ret.valid = false;\n        ret.error = baseMsg + 'property \"type\" must be a string, but ' + typeof ext.type + \" given\";\n        return ret;\n      }\n      var type = ext.type = ext.type.toLowerCase();\n      if (type === \"language\") {\n        type = ext.type = \"lang\";\n      }\n      if (type === \"html\") {\n        type = ext.type = \"output\";\n      }\n      if (type !== \"lang\" && type !== \"output\" && type !== \"listener\") {\n        ret.valid = false;\n        ret.error = baseMsg + \"type \" + type + ' is not recognized. Valid values: \"lang/language\", \"output/html\" or \"listener\"';\n        return ret;\n      }\n      if (type === \"listener\") {\n        if (showdown.helper.isUndefined(ext.listeners)) {\n          ret.valid = false;\n          ret.error = baseMsg + '. Extensions of type \"listener\" must have a property called \"listeners\"';\n          return ret;\n        }\n      } else {\n        if (showdown.helper.isUndefined(ext.filter) && showdown.helper.isUndefined(ext.regex)) {\n          ret.valid = false;\n          ret.error = baseMsg + type + ' extensions must define either a \"regex\" property or a \"filter\" method';\n          return ret;\n        }\n      }\n      if (ext.listeners) {\n        if (typeof ext.listeners !== \"object\") {\n          ret.valid = false;\n          ret.error = baseMsg + '\"listeners\" property must be an object but ' + typeof ext.listeners + \" given\";\n          return ret;\n        }\n        for (var ln in ext.listeners) {\n          if (ext.listeners.hasOwnProperty(ln)) {\n            if (typeof ext.listeners[ln] !== \"function\") {\n              ret.valid = false;\n              ret.error = baseMsg + '\"listeners\" property must be an hash of [event name]: [callback]. listeners.' + ln + \" must be a function but \" + typeof ext.listeners[ln] + \" given\";\n              return ret;\n            }\n          }\n        }\n      }\n      if (ext.filter) {\n        if (typeof ext.filter !== \"function\") {\n          ret.valid = false;\n          ret.error = baseMsg + '\"filter\" must be a function, but ' + typeof ext.filter + \" given\";\n          return ret;\n        }\n      } else if (ext.regex) {\n        if (showdown.helper.isString(ext.regex)) {\n          ext.regex = new RegExp(ext.regex, \"g\");\n        }\n        if (!(ext.regex instanceof RegExp)) {\n          ret.valid = false;\n          ret.error = baseMsg + '\"regex\" property must either be a string or a RegExp object, but ' + typeof ext.regex + \" given\";\n          return ret;\n        }\n        if (showdown.helper.isUndefined(ext.replace)) {\n          ret.valid = false;\n          ret.error = baseMsg + '\"regex\" extensions must implement a replace string or function';\n          return ret;\n        }\n      }\n    }\n    return ret;\n  }\n  showdown.validateExtension = function(ext) {\n    \"use strict\";\n    var validateExtension = validate(ext, null);\n    if (!validateExtension.valid) {\n      console.warn(validateExtension.error);\n      return false;\n    }\n    return true;\n  };\n  if (!showdown.hasOwnProperty(\"helper\")) {\n    showdown.helper = {};\n  }\n  showdown.helper.isString = function(a) {\n    \"use strict\";\n    return typeof a === \"string\" || a instanceof String;\n  };\n  showdown.helper.isFunction = function(a) {\n    \"use strict\";\n    var getType = {};\n    return a && getType.toString.call(a) === \"[object Function]\";\n  };\n  showdown.helper.isArray = function(a) {\n    \"use strict\";\n    return Array.isArray(a);\n  };\n  showdown.helper.isUndefined = function(value) {\n    \"use strict\";\n    return typeof value === \"undefined\";\n  };\n  showdown.helper.forEach = function(obj, callback) {\n    \"use strict\";\n    if (showdown.helper.isUndefined(obj)) {\n      throw new Error(\"obj param is required\");\n    }\n    if (showdown.helper.isUndefined(callback)) {\n      throw new Error(\"callback param is required\");\n    }\n    if (!showdown.helper.isFunction(callback)) {\n      throw new Error(\"callback param must be a function/closure\");\n    }\n    if (typeof obj.forEach === \"function\") {\n      obj.forEach(callback);\n    } else if (showdown.helper.isArray(obj)) {\n      for (var i = 0; i < obj.length; i++) {\n        callback(obj[i], i, obj);\n      }\n    } else if (typeof obj === \"object\") {\n      for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          callback(obj[prop], prop, obj);\n        }\n      }\n    } else {\n      throw new Error(\"obj does not seem to be an array or an iterable object\");\n    }\n  };\n  showdown.helper.stdExtName = function(s) {\n    \"use strict\";\n    return s.replace(/[_?*+\\/\\\\.^-]/g, \"\").replace(/\\s/g, \"\").toLowerCase();\n  };\n  function escapeCharactersCallback(wholeMatch, m1) {\n    \"use strict\";\n    var charCodeToEscape = m1.charCodeAt(0);\n    return \"\\xA8E\" + charCodeToEscape + \"E\";\n  }\n  showdown.helper.escapeCharactersCallback = escapeCharactersCallback;\n  showdown.helper.escapeCharacters = function(text, charsToEscape, afterBackslash) {\n    \"use strict\";\n    var regexString = \"([\" + charsToEscape.replace(/([\\[\\]\\\\])/g, \"\\\\$1\") + \"])\";\n    if (afterBackslash) {\n      regexString = \"\\\\\\\\\" + regexString;\n    }\n    var regex = new RegExp(regexString, \"g\");\n    text = text.replace(regex, escapeCharactersCallback);\n    return text;\n  };\n  showdown.helper.unescapeHTMLEntities = function(txt) {\n    \"use strict\";\n    return txt.replace(/&quot;/g, '\"').replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\").replace(/&amp;/g, \"&\");\n  };\n  var rgxFindMatchPos = function(str, left, right, flags) {\n    \"use strict\";\n    var f = flags || \"\", g = f.indexOf(\"g\") > -1, x = new RegExp(left + \"|\" + right, \"g\" + f.replace(/g/g, \"\")), l = new RegExp(left, f.replace(/g/g, \"\")), pos = [], t, s, m, start, end;\n    do {\n      t = 0;\n      while (m = x.exec(str)) {\n        if (l.test(m[0])) {\n          if (!t++) {\n            s = x.lastIndex;\n            start = s - m[0].length;\n          }\n        } else if (t) {\n          if (!--t) {\n            end = m.index + m[0].length;\n            var obj = {\n              left: { start, end: s },\n              match: { start: s, end: m.index },\n              right: { start: m.index, end },\n              wholeMatch: { start, end }\n            };\n            pos.push(obj);\n            if (!g) {\n              return pos;\n            }\n          }\n        }\n      }\n    } while (t && (x.lastIndex = s));\n    return pos;\n  };\n  showdown.helper.matchRecursiveRegExp = function(str, left, right, flags) {\n    \"use strict\";\n    var matchPos = rgxFindMatchPos(str, left, right, flags), results = [];\n    for (var i = 0; i < matchPos.length; ++i) {\n      results.push([\n        str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),\n        str.slice(matchPos[i].match.start, matchPos[i].match.end),\n        str.slice(matchPos[i].left.start, matchPos[i].left.end),\n        str.slice(matchPos[i].right.start, matchPos[i].right.end)\n      ]);\n    }\n    return results;\n  };\n  showdown.helper.replaceRecursiveRegExp = function(str, replacement, left, right, flags) {\n    \"use strict\";\n    if (!showdown.helper.isFunction(replacement)) {\n      var repStr = replacement;\n      replacement = function() {\n        return repStr;\n      };\n    }\n    var matchPos = rgxFindMatchPos(str, left, right, flags), finalStr = str, lng = matchPos.length;\n    if (lng > 0) {\n      var bits = [];\n      if (matchPos[0].wholeMatch.start !== 0) {\n        bits.push(str.slice(0, matchPos[0].wholeMatch.start));\n      }\n      for (var i = 0; i < lng; ++i) {\n        bits.push(\n          replacement(\n            str.slice(matchPos[i].wholeMatch.start, matchPos[i].wholeMatch.end),\n            str.slice(matchPos[i].match.start, matchPos[i].match.end),\n            str.slice(matchPos[i].left.start, matchPos[i].left.end),\n            str.slice(matchPos[i].right.start, matchPos[i].right.end)\n          )\n        );\n        if (i < lng - 1) {\n          bits.push(str.slice(matchPos[i].wholeMatch.end, matchPos[i + 1].wholeMatch.start));\n        }\n      }\n      if (matchPos[lng - 1].wholeMatch.end < str.length) {\n        bits.push(str.slice(matchPos[lng - 1].wholeMatch.end));\n      }\n      finalStr = bits.join(\"\");\n    }\n    return finalStr;\n  };\n  showdown.helper.regexIndexOf = function(str, regex, fromIndex) {\n    \"use strict\";\n    if (!showdown.helper.isString(str)) {\n      throw \"InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string\";\n    }\n    if (regex instanceof RegExp === false) {\n      throw \"InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp\";\n    }\n    var indexOf = str.substring(fromIndex || 0).search(regex);\n    return indexOf >= 0 ? indexOf + (fromIndex || 0) : indexOf;\n  };\n  showdown.helper.splitAtIndex = function(str, index) {\n    \"use strict\";\n    if (!showdown.helper.isString(str)) {\n      throw \"InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string\";\n    }\n    return [str.substring(0, index), str.substring(index)];\n  };\n  showdown.helper.encodeEmailAddress = function(mail) {\n    \"use strict\";\n    var encode = [\n      function(ch) {\n        return \"&#\" + ch.charCodeAt(0) + \";\";\n      },\n      function(ch) {\n        return \"&#x\" + ch.charCodeAt(0).toString(16) + \";\";\n      },\n      function(ch) {\n        return ch;\n      }\n    ];\n    mail = mail.replace(/./g, function(ch) {\n      if (ch === \"@\") {\n        ch = encode[Math.floor(Math.random() * 2)](ch);\n      } else {\n        var r = Math.random();\n        ch = r > 0.9 ? encode[2](ch) : r > 0.45 ? encode[1](ch) : encode[0](ch);\n      }\n      return ch;\n    });\n    return mail;\n  };\n  showdown.helper.padEnd = function padEnd(str, targetLength, padString) {\n    \"use strict\";\n    targetLength = targetLength >> 0;\n    padString = String(padString || \" \");\n    if (str.length > targetLength) {\n      return String(str);\n    } else {\n      targetLength = targetLength - str.length;\n      if (targetLength > padString.length) {\n        padString += padString.repeat(targetLength / padString.length);\n      }\n      return String(str) + padString.slice(0, targetLength);\n    }\n  };\n  if (typeof console === \"undefined\") {\n    console = {\n      warn: function(msg) {\n        \"use strict\";\n        alert(msg);\n      },\n      log: function(msg) {\n        \"use strict\";\n        alert(msg);\n      },\n      error: function(msg) {\n        \"use strict\";\n        throw msg;\n      }\n    };\n  }\n  showdown.helper.regexes = {\n    asteriskDashAndColon: /([*_:~])/g\n  };\n  showdown.helper.emojis = {\n    \"+1\": \"\\u{1F44D}\",\n    \"-1\": \"\\u{1F44E}\",\n    \"100\": \"\\u{1F4AF}\",\n    \"1234\": \"\\u{1F522}\",\n    \"1st_place_medal\": \"\\u{1F947}\",\n    \"2nd_place_medal\": \"\\u{1F948}\",\n    \"3rd_place_medal\": \"\\u{1F949}\",\n    \"8ball\": \"\\u{1F3B1}\",\n    \"a\": \"\\u{1F170}\\uFE0F\",\n    \"ab\": \"\\u{1F18E}\",\n    \"abc\": \"\\u{1F524}\",\n    \"abcd\": \"\\u{1F521}\",\n    \"accept\": \"\\u{1F251}\",\n    \"aerial_tramway\": \"\\u{1F6A1}\",\n    \"airplane\": \"\\u2708\\uFE0F\",\n    \"alarm_clock\": \"\\u23F0\",\n    \"alembic\": \"\\u2697\\uFE0F\",\n    \"alien\": \"\\u{1F47D}\",\n    \"ambulance\": \"\\u{1F691}\",\n    \"amphora\": \"\\u{1F3FA}\",\n    \"anchor\": \"\\u2693\\uFE0F\",\n    \"angel\": \"\\u{1F47C}\",\n    \"anger\": \"\\u{1F4A2}\",\n    \"angry\": \"\\u{1F620}\",\n    \"anguished\": \"\\u{1F627}\",\n    \"ant\": \"\\u{1F41C}\",\n    \"apple\": \"\\u{1F34E}\",\n    \"aquarius\": \"\\u2652\\uFE0F\",\n    \"aries\": \"\\u2648\\uFE0F\",\n    \"arrow_backward\": \"\\u25C0\\uFE0F\",\n    \"arrow_double_down\": \"\\u23EC\",\n    \"arrow_double_up\": \"\\u23EB\",\n    \"arrow_down\": \"\\u2B07\\uFE0F\",\n    \"arrow_down_small\": \"\\u{1F53D}\",\n    \"arrow_forward\": \"\\u25B6\\uFE0F\",\n    \"arrow_heading_down\": \"\\u2935\\uFE0F\",\n    \"arrow_heading_up\": \"\\u2934\\uFE0F\",\n    \"arrow_left\": \"\\u2B05\\uFE0F\",\n    \"arrow_lower_left\": \"\\u2199\\uFE0F\",\n    \"arrow_lower_right\": \"\\u2198\\uFE0F\",\n    \"arrow_right\": \"\\u27A1\\uFE0F\",\n    \"arrow_right_hook\": \"\\u21AA\\uFE0F\",\n    \"arrow_up\": \"\\u2B06\\uFE0F\",\n    \"arrow_up_down\": \"\\u2195\\uFE0F\",\n    \"arrow_up_small\": \"\\u{1F53C}\",\n    \"arrow_upper_left\": \"\\u2196\\uFE0F\",\n    \"arrow_upper_right\": \"\\u2197\\uFE0F\",\n    \"arrows_clockwise\": \"\\u{1F503}\",\n    \"arrows_counterclockwise\": \"\\u{1F504}\",\n    \"art\": \"\\u{1F3A8}\",\n    \"articulated_lorry\": \"\\u{1F69B}\",\n    \"artificial_satellite\": \"\\u{1F6F0}\",\n    \"astonished\": \"\\u{1F632}\",\n    \"athletic_shoe\": \"\\u{1F45F}\",\n    \"atm\": \"\\u{1F3E7}\",\n    \"atom_symbol\": \"\\u269B\\uFE0F\",\n    \"avocado\": \"\\u{1F951}\",\n    \"b\": \"\\u{1F171}\\uFE0F\",\n    \"baby\": \"\\u{1F476}\",\n    \"baby_bottle\": \"\\u{1F37C}\",\n    \"baby_chick\": \"\\u{1F424}\",\n    \"baby_symbol\": \"\\u{1F6BC}\",\n    \"back\": \"\\u{1F519}\",\n    \"bacon\": \"\\u{1F953}\",\n    \"badminton\": \"\\u{1F3F8}\",\n    \"baggage_claim\": \"\\u{1F6C4}\",\n    \"baguette_bread\": \"\\u{1F956}\",\n    \"balance_scale\": \"\\u2696\\uFE0F\",\n    \"balloon\": \"\\u{1F388}\",\n    \"ballot_box\": \"\\u{1F5F3}\",\n    \"ballot_box_with_check\": \"\\u2611\\uFE0F\",\n    \"bamboo\": \"\\u{1F38D}\",\n    \"banana\": \"\\u{1F34C}\",\n    \"bangbang\": \"\\u203C\\uFE0F\",\n    \"bank\": \"\\u{1F3E6}\",\n    \"bar_chart\": \"\\u{1F4CA}\",\n    \"barber\": \"\\u{1F488}\",\n    \"baseball\": \"\\u26BE\\uFE0F\",\n    \"basketball\": \"\\u{1F3C0}\",\n    \"basketball_man\": \"\\u26F9\\uFE0F\",\n    \"basketball_woman\": \"\\u26F9\\uFE0F&zwj;\\u2640\\uFE0F\",\n    \"bat\": \"\\u{1F987}\",\n    \"bath\": \"\\u{1F6C0}\",\n    \"bathtub\": \"\\u{1F6C1}\",\n    \"battery\": \"\\u{1F50B}\",\n    \"beach_umbrella\": \"\\u{1F3D6}\",\n    \"bear\": \"\\u{1F43B}\",\n    \"bed\": \"\\u{1F6CF}\",\n    \"bee\": \"\\u{1F41D}\",\n    \"beer\": \"\\u{1F37A}\",\n    \"beers\": \"\\u{1F37B}\",\n    \"beetle\": \"\\u{1F41E}\",\n    \"beginner\": \"\\u{1F530}\",\n    \"bell\": \"\\u{1F514}\",\n    \"bellhop_bell\": \"\\u{1F6CE}\",\n    \"bento\": \"\\u{1F371}\",\n    \"biking_man\": \"\\u{1F6B4}\",\n    \"bike\": \"\\u{1F6B2}\",\n    \"biking_woman\": \"\\u{1F6B4}&zwj;\\u2640\\uFE0F\",\n    \"bikini\": \"\\u{1F459}\",\n    \"biohazard\": \"\\u2623\\uFE0F\",\n    \"bird\": \"\\u{1F426}\",\n    \"birthday\": \"\\u{1F382}\",\n    \"black_circle\": \"\\u26AB\\uFE0F\",\n    \"black_flag\": \"\\u{1F3F4}\",\n    \"black_heart\": \"\\u{1F5A4}\",\n    \"black_joker\": \"\\u{1F0CF}\",\n    \"black_large_square\": \"\\u2B1B\\uFE0F\",\n    \"black_medium_small_square\": \"\\u25FE\\uFE0F\",\n    \"black_medium_square\": \"\\u25FC\\uFE0F\",\n    \"black_nib\": \"\\u2712\\uFE0F\",\n    \"black_small_square\": \"\\u25AA\\uFE0F\",\n    \"black_square_button\": \"\\u{1F532}\",\n    \"blonde_man\": \"\\u{1F471}\",\n    \"blonde_woman\": \"\\u{1F471}&zwj;\\u2640\\uFE0F\",\n    \"blossom\": \"\\u{1F33C}\",\n    \"blowfish\": \"\\u{1F421}\",\n    \"blue_book\": \"\\u{1F4D8}\",\n    \"blue_car\": \"\\u{1F699}\",\n    \"blue_heart\": \"\\u{1F499}\",\n    \"blush\": \"\\u{1F60A}\",\n    \"boar\": \"\\u{1F417}\",\n    \"boat\": \"\\u26F5\\uFE0F\",\n    \"bomb\": \"\\u{1F4A3}\",\n    \"book\": \"\\u{1F4D6}\",\n    \"bookmark\": \"\\u{1F516}\",\n    \"bookmark_tabs\": \"\\u{1F4D1}\",\n    \"books\": \"\\u{1F4DA}\",\n    \"boom\": \"\\u{1F4A5}\",\n    \"boot\": \"\\u{1F462}\",\n    \"bouquet\": \"\\u{1F490}\",\n    \"bowing_man\": \"\\u{1F647}\",\n    \"bow_and_arrow\": \"\\u{1F3F9}\",\n    \"bowing_woman\": \"\\u{1F647}&zwj;\\u2640\\uFE0F\",\n    \"bowling\": \"\\u{1F3B3}\",\n    \"boxing_glove\": \"\\u{1F94A}\",\n    \"boy\": \"\\u{1F466}\",\n    \"bread\": \"\\u{1F35E}\",\n    \"bride_with_veil\": \"\\u{1F470}\",\n    \"bridge_at_night\": \"\\u{1F309}\",\n    \"briefcase\": \"\\u{1F4BC}\",\n    \"broken_heart\": \"\\u{1F494}\",\n    \"bug\": \"\\u{1F41B}\",\n    \"building_construction\": \"\\u{1F3D7}\",\n    \"bulb\": \"\\u{1F4A1}\",\n    \"bullettrain_front\": \"\\u{1F685}\",\n    \"bullettrain_side\": \"\\u{1F684}\",\n    \"burrito\": \"\\u{1F32F}\",\n    \"bus\": \"\\u{1F68C}\",\n    \"business_suit_levitating\": \"\\u{1F574}\",\n    \"busstop\": \"\\u{1F68F}\",\n    \"bust_in_silhouette\": \"\\u{1F464}\",\n    \"busts_in_silhouette\": \"\\u{1F465}\",\n    \"butterfly\": \"\\u{1F98B}\",\n    \"cactus\": \"\\u{1F335}\",\n    \"cake\": \"\\u{1F370}\",\n    \"calendar\": \"\\u{1F4C6}\",\n    \"call_me_hand\": \"\\u{1F919}\",\n    \"calling\": \"\\u{1F4F2}\",\n    \"camel\": \"\\u{1F42B}\",\n    \"camera\": \"\\u{1F4F7}\",\n    \"camera_flash\": \"\\u{1F4F8}\",\n    \"camping\": \"\\u{1F3D5}\",\n    \"cancer\": \"\\u264B\\uFE0F\",\n    \"candle\": \"\\u{1F56F}\",\n    \"candy\": \"\\u{1F36C}\",\n    \"canoe\": \"\\u{1F6F6}\",\n    \"capital_abcd\": \"\\u{1F520}\",\n    \"capricorn\": \"\\u2651\\uFE0F\",\n    \"car\": \"\\u{1F697}\",\n    \"card_file_box\": \"\\u{1F5C3}\",\n    \"card_index\": \"\\u{1F4C7}\",\n    \"card_index_dividers\": \"\\u{1F5C2}\",\n    \"carousel_horse\": \"\\u{1F3A0}\",\n    \"carrot\": \"\\u{1F955}\",\n    \"cat\": \"\\u{1F431}\",\n    \"cat2\": \"\\u{1F408}\",\n    \"cd\": \"\\u{1F4BF}\",\n    \"chains\": \"\\u26D3\",\n    \"champagne\": \"\\u{1F37E}\",\n    \"chart\": \"\\u{1F4B9}\",\n    \"chart_with_downwards_trend\": \"\\u{1F4C9}\",\n    \"chart_with_upwards_trend\": \"\\u{1F4C8}\",\n    \"checkered_flag\": \"\\u{1F3C1}\",\n    \"cheese\": \"\\u{1F9C0}\",\n    \"cherries\": \"\\u{1F352}\",\n    \"cherry_blossom\": \"\\u{1F338}\",\n    \"chestnut\": \"\\u{1F330}\",\n    \"chicken\": \"\\u{1F414}\",\n    \"children_crossing\": \"\\u{1F6B8}\",\n    \"chipmunk\": \"\\u{1F43F}\",\n    \"chocolate_bar\": \"\\u{1F36B}\",\n    \"christmas_tree\": \"\\u{1F384}\",\n    \"church\": \"\\u26EA\\uFE0F\",\n    \"cinema\": \"\\u{1F3A6}\",\n    \"circus_tent\": \"\\u{1F3AA}\",\n    \"city_sunrise\": \"\\u{1F307}\",\n    \"city_sunset\": \"\\u{1F306}\",\n    \"cityscape\": \"\\u{1F3D9}\",\n    \"cl\": \"\\u{1F191}\",\n    \"clamp\": \"\\u{1F5DC}\",\n    \"clap\": \"\\u{1F44F}\",\n    \"clapper\": \"\\u{1F3AC}\",\n    \"classical_building\": \"\\u{1F3DB}\",\n    \"clinking_glasses\": \"\\u{1F942}\",\n    \"clipboard\": \"\\u{1F4CB}\",\n    \"clock1\": \"\\u{1F550}\",\n    \"clock10\": \"\\u{1F559}\",\n    \"clock1030\": \"\\u{1F565}\",\n    \"clock11\": \"\\u{1F55A}\",\n    \"clock1130\": \"\\u{1F566}\",\n    \"clock12\": \"\\u{1F55B}\",\n    \"clock1230\": \"\\u{1F567}\",\n    \"clock130\": \"\\u{1F55C}\",\n    \"clock2\": \"\\u{1F551}\",\n    \"clock230\": \"\\u{1F55D}\",\n    \"clock3\": \"\\u{1F552}\",\n    \"clock330\": \"\\u{1F55E}\",\n    \"clock4\": \"\\u{1F553}\",\n    \"clock430\": \"\\u{1F55F}\",\n    \"clock5\": \"\\u{1F554}\",\n    \"clock530\": \"\\u{1F560}\",\n    \"clock6\": \"\\u{1F555}\",\n    \"clock630\": \"\\u{1F561}\",\n    \"clock7\": \"\\u{1F556}\",\n    \"clock730\": \"\\u{1F562}\",\n    \"clock8\": \"\\u{1F557}\",\n    \"clock830\": \"\\u{1F563}\",\n    \"clock9\": \"\\u{1F558}\",\n    \"clock930\": \"\\u{1F564}\",\n    \"closed_book\": \"\\u{1F4D5}\",\n    \"closed_lock_with_key\": \"\\u{1F510}\",\n    \"closed_umbrella\": \"\\u{1F302}\",\n    \"cloud\": \"\\u2601\\uFE0F\",\n    \"cloud_with_lightning\": \"\\u{1F329}\",\n    \"cloud_with_lightning_and_rain\": \"\\u26C8\",\n    \"cloud_with_rain\": \"\\u{1F327}\",\n    \"cloud_with_snow\": \"\\u{1F328}\",\n    \"clown_face\": \"\\u{1F921}\",\n    \"clubs\": \"\\u2663\\uFE0F\",\n    \"cocktail\": \"\\u{1F378}\",\n    \"coffee\": \"\\u2615\\uFE0F\",\n    \"coffin\": \"\\u26B0\\uFE0F\",\n    \"cold_sweat\": \"\\u{1F630}\",\n    \"comet\": \"\\u2604\\uFE0F\",\n    \"computer\": \"\\u{1F4BB}\",\n    \"computer_mouse\": \"\\u{1F5B1}\",\n    \"confetti_ball\": \"\\u{1F38A}\",\n    \"confounded\": \"\\u{1F616}\",\n    \"confused\": \"\\u{1F615}\",\n    \"congratulations\": \"\\u3297\\uFE0F\",\n    \"construction\": \"\\u{1F6A7}\",\n    \"construction_worker_man\": \"\\u{1F477}\",\n    \"construction_worker_woman\": \"\\u{1F477}&zwj;\\u2640\\uFE0F\",\n    \"control_knobs\": \"\\u{1F39B}\",\n    \"convenience_store\": \"\\u{1F3EA}\",\n    \"cookie\": \"\\u{1F36A}\",\n    \"cool\": \"\\u{1F192}\",\n    \"policeman\": \"\\u{1F46E}\",\n    \"copyright\": \"\\xA9\\uFE0F\",\n    \"corn\": \"\\u{1F33D}\",\n    \"couch_and_lamp\": \"\\u{1F6CB}\",\n    \"couple\": \"\\u{1F46B}\",\n    \"couple_with_heart_woman_man\": \"\\u{1F491}\",\n    \"couple_with_heart_man_man\": \"\\u{1F468}&zwj;\\u2764\\uFE0F&zwj;\\u{1F468}\",\n    \"couple_with_heart_woman_woman\": \"\\u{1F469}&zwj;\\u2764\\uFE0F&zwj;\\u{1F469}\",\n    \"couplekiss_man_man\": \"\\u{1F468}&zwj;\\u2764\\uFE0F&zwj;\\u{1F48B}&zwj;\\u{1F468}\",\n    \"couplekiss_man_woman\": \"\\u{1F48F}\",\n    \"couplekiss_woman_woman\": \"\\u{1F469}&zwj;\\u2764\\uFE0F&zwj;\\u{1F48B}&zwj;\\u{1F469}\",\n    \"cow\": \"\\u{1F42E}\",\n    \"cow2\": \"\\u{1F404}\",\n    \"cowboy_hat_face\": \"\\u{1F920}\",\n    \"crab\": \"\\u{1F980}\",\n    \"crayon\": \"\\u{1F58D}\",\n    \"credit_card\": \"\\u{1F4B3}\",\n    \"crescent_moon\": \"\\u{1F319}\",\n    \"cricket\": \"\\u{1F3CF}\",\n    \"crocodile\": \"\\u{1F40A}\",\n    \"croissant\": \"\\u{1F950}\",\n    \"crossed_fingers\": \"\\u{1F91E}\",\n    \"crossed_flags\": \"\\u{1F38C}\",\n    \"crossed_swords\": \"\\u2694\\uFE0F\",\n    \"crown\": \"\\u{1F451}\",\n    \"cry\": \"\\u{1F622}\",\n    \"crying_cat_face\": \"\\u{1F63F}\",\n    \"crystal_ball\": \"\\u{1F52E}\",\n    \"cucumber\": \"\\u{1F952}\",\n    \"cupid\": \"\\u{1F498}\",\n    \"curly_loop\": \"\\u27B0\",\n    \"currency_exchange\": \"\\u{1F4B1}\",\n    \"curry\": \"\\u{1F35B}\",\n    \"custard\": \"\\u{1F36E}\",\n    \"customs\": \"\\u{1F6C3}\",\n    \"cyclone\": \"\\u{1F300}\",\n    \"dagger\": \"\\u{1F5E1}\",\n    \"dancer\": \"\\u{1F483}\",\n    \"dancing_women\": \"\\u{1F46F}\",\n    \"dancing_men\": \"\\u{1F46F}&zwj;\\u2642\\uFE0F\",\n    \"dango\": \"\\u{1F361}\",\n    \"dark_sunglasses\": \"\\u{1F576}\",\n    \"dart\": \"\\u{1F3AF}\",\n    \"dash\": \"\\u{1F4A8}\",\n    \"date\": \"\\u{1F4C5}\",\n    \"deciduous_tree\": \"\\u{1F333}\",\n    \"deer\": \"\\u{1F98C}\",\n    \"department_store\": \"\\u{1F3EC}\",\n    \"derelict_house\": \"\\u{1F3DA}\",\n    \"desert\": \"\\u{1F3DC}\",\n    \"desert_island\": \"\\u{1F3DD}\",\n    \"desktop_computer\": \"\\u{1F5A5}\",\n    \"male_detective\": \"\\u{1F575}\\uFE0F\",\n    \"diamond_shape_with_a_dot_inside\": \"\\u{1F4A0}\",\n    \"diamonds\": \"\\u2666\\uFE0F\",\n    \"disappointed\": \"\\u{1F61E}\",\n    \"disappointed_relieved\": \"\\u{1F625}\",\n    \"dizzy\": \"\\u{1F4AB}\",\n    \"dizzy_face\": \"\\u{1F635}\",\n    \"do_not_litter\": \"\\u{1F6AF}\",\n    \"dog\": \"\\u{1F436}\",\n    \"dog2\": \"\\u{1F415}\",\n    \"dollar\": \"\\u{1F4B5}\",\n    \"dolls\": \"\\u{1F38E}\",\n    \"dolphin\": \"\\u{1F42C}\",\n    \"door\": \"\\u{1F6AA}\",\n    \"doughnut\": \"\\u{1F369}\",\n    \"dove\": \"\\u{1F54A}\",\n    \"dragon\": \"\\u{1F409}\",\n    \"dragon_face\": \"\\u{1F432}\",\n    \"dress\": \"\\u{1F457}\",\n    \"dromedary_camel\": \"\\u{1F42A}\",\n    \"drooling_face\": \"\\u{1F924}\",\n    \"droplet\": \"\\u{1F4A7}\",\n    \"drum\": \"\\u{1F941}\",\n    \"duck\": \"\\u{1F986}\",\n    \"dvd\": \"\\u{1F4C0}\",\n    \"e-mail\": \"\\u{1F4E7}\",\n    \"eagle\": \"\\u{1F985}\",\n    \"ear\": \"\\u{1F442}\",\n    \"ear_of_rice\": \"\\u{1F33E}\",\n    \"earth_africa\": \"\\u{1F30D}\",\n    \"earth_americas\": \"\\u{1F30E}\",\n    \"earth_asia\": \"\\u{1F30F}\",\n    \"egg\": \"\\u{1F95A}\",\n    \"eggplant\": \"\\u{1F346}\",\n    \"eight_pointed_black_star\": \"\\u2734\\uFE0F\",\n    \"eight_spoked_asterisk\": \"\\u2733\\uFE0F\",\n    \"electric_plug\": \"\\u{1F50C}\",\n    \"elephant\": \"\\u{1F418}\",\n    \"email\": \"\\u2709\\uFE0F\",\n    \"end\": \"\\u{1F51A}\",\n    \"envelope_with_arrow\": \"\\u{1F4E9}\",\n    \"euro\": \"\\u{1F4B6}\",\n    \"european_castle\": \"\\u{1F3F0}\",\n    \"european_post_office\": \"\\u{1F3E4}\",\n    \"evergreen_tree\": \"\\u{1F332}\",\n    \"exclamation\": \"\\u2757\\uFE0F\",\n    \"expressionless\": \"\\u{1F611}\",\n    \"eye\": \"\\u{1F441}\",\n    \"eye_speech_bubble\": \"\\u{1F441}&zwj;\\u{1F5E8}\",\n    \"eyeglasses\": \"\\u{1F453}\",\n    \"eyes\": \"\\u{1F440}\",\n    \"face_with_head_bandage\": \"\\u{1F915}\",\n    \"face_with_thermometer\": \"\\u{1F912}\",\n    \"fist_oncoming\": \"\\u{1F44A}\",\n    \"factory\": \"\\u{1F3ED}\",\n    \"fallen_leaf\": \"\\u{1F342}\",\n    \"family_man_woman_boy\": \"\\u{1F46A}\",\n    \"family_man_boy\": \"\\u{1F468}&zwj;\\u{1F466}\",\n    \"family_man_boy_boy\": \"\\u{1F468}&zwj;\\u{1F466}&zwj;\\u{1F466}\",\n    \"family_man_girl\": \"\\u{1F468}&zwj;\\u{1F467}\",\n    \"family_man_girl_boy\": \"\\u{1F468}&zwj;\\u{1F467}&zwj;\\u{1F466}\",\n    \"family_man_girl_girl\": \"\\u{1F468}&zwj;\\u{1F467}&zwj;\\u{1F467}\",\n    \"family_man_man_boy\": \"\\u{1F468}&zwj;\\u{1F468}&zwj;\\u{1F466}\",\n    \"family_man_man_boy_boy\": \"\\u{1F468}&zwj;\\u{1F468}&zwj;\\u{1F466}&zwj;\\u{1F466}\",\n    \"family_man_man_girl\": \"\\u{1F468}&zwj;\\u{1F468}&zwj;\\u{1F467}\",\n    \"family_man_man_girl_boy\": \"\\u{1F468}&zwj;\\u{1F468}&zwj;\\u{1F467}&zwj;\\u{1F466}\",\n    \"family_man_man_girl_girl\": \"\\u{1F468}&zwj;\\u{1F468}&zwj;\\u{1F467}&zwj;\\u{1F467}\",\n    \"family_man_woman_boy_boy\": \"\\u{1F468}&zwj;\\u{1F469}&zwj;\\u{1F466}&zwj;\\u{1F466}\",\n    \"family_man_woman_girl\": \"\\u{1F468}&zwj;\\u{1F469}&zwj;\\u{1F467}\",\n    \"family_man_woman_girl_boy\": \"\\u{1F468}&zwj;\\u{1F469}&zwj;\\u{1F467}&zwj;\\u{1F466}\",\n    \"family_man_woman_girl_girl\": \"\\u{1F468}&zwj;\\u{1F469}&zwj;\\u{1F467}&zwj;\\u{1F467}\",\n    \"family_woman_boy\": \"\\u{1F469}&zwj;\\u{1F466}\",\n    \"family_woman_boy_boy\": \"\\u{1F469}&zwj;\\u{1F466}&zwj;\\u{1F466}\",\n    \"family_woman_girl\": \"\\u{1F469}&zwj;\\u{1F467}\",\n    \"family_woman_girl_boy\": \"\\u{1F469}&zwj;\\u{1F467}&zwj;\\u{1F466}\",\n    \"family_woman_girl_girl\": \"\\u{1F469}&zwj;\\u{1F467}&zwj;\\u{1F467}\",\n    \"family_woman_woman_boy\": \"\\u{1F469}&zwj;\\u{1F469}&zwj;\\u{1F466}\",\n    \"family_woman_woman_boy_boy\": \"\\u{1F469}&zwj;\\u{1F469}&zwj;\\u{1F466}&zwj;\\u{1F466}\",\n    \"family_woman_woman_girl\": \"\\u{1F469}&zwj;\\u{1F469}&zwj;\\u{1F467}\",\n    \"family_woman_woman_girl_boy\": \"\\u{1F469}&zwj;\\u{1F469}&zwj;\\u{1F467}&zwj;\\u{1F466}\",\n    \"family_woman_woman_girl_girl\": \"\\u{1F469}&zwj;\\u{1F469}&zwj;\\u{1F467}&zwj;\\u{1F467}\",\n    \"fast_forward\": \"\\u23E9\",\n    \"fax\": \"\\u{1F4E0}\",\n    \"fearful\": \"\\u{1F628}\",\n    \"feet\": \"\\u{1F43E}\",\n    \"female_detective\": \"\\u{1F575}\\uFE0F&zwj;\\u2640\\uFE0F\",\n    \"ferris_wheel\": \"\\u{1F3A1}\",\n    \"ferry\": \"\\u26F4\",\n    \"field_hockey\": \"\\u{1F3D1}\",\n    \"file_cabinet\": \"\\u{1F5C4}\",\n    \"file_folder\": \"\\u{1F4C1}\",\n    \"film_projector\": \"\\u{1F4FD}\",\n    \"film_strip\": \"\\u{1F39E}\",\n    \"fire\": \"\\u{1F525}\",\n    \"fire_engine\": \"\\u{1F692}\",\n    \"fireworks\": \"\\u{1F386}\",\n    \"first_quarter_moon\": \"\\u{1F313}\",\n    \"first_quarter_moon_with_face\": \"\\u{1F31B}\",\n    \"fish\": \"\\u{1F41F}\",\n    \"fish_cake\": \"\\u{1F365}\",\n    \"fishing_pole_and_fish\": \"\\u{1F3A3}\",\n    \"fist_raised\": \"\\u270A\",\n    \"fist_left\": \"\\u{1F91B}\",\n    \"fist_right\": \"\\u{1F91C}\",\n    \"flags\": \"\\u{1F38F}\",\n    \"flashlight\": \"\\u{1F526}\",\n    \"fleur_de_lis\": \"\\u269C\\uFE0F\",\n    \"flight_arrival\": \"\\u{1F6EC}\",\n    \"flight_departure\": \"\\u{1F6EB}\",\n    \"floppy_disk\": \"\\u{1F4BE}\",\n    \"flower_playing_cards\": \"\\u{1F3B4}\",\n    \"flushed\": \"\\u{1F633}\",\n    \"fog\": \"\\u{1F32B}\",\n    \"foggy\": \"\\u{1F301}\",\n    \"football\": \"\\u{1F3C8}\",\n    \"footprints\": \"\\u{1F463}\",\n    \"fork_and_knife\": \"\\u{1F374}\",\n    \"fountain\": \"\\u26F2\\uFE0F\",\n    \"fountain_pen\": \"\\u{1F58B}\",\n    \"four_leaf_clover\": \"\\u{1F340}\",\n    \"fox_face\": \"\\u{1F98A}\",\n    \"framed_picture\": \"\\u{1F5BC}\",\n    \"free\": \"\\u{1F193}\",\n    \"fried_egg\": \"\\u{1F373}\",\n    \"fried_shrimp\": \"\\u{1F364}\",\n    \"fries\": \"\\u{1F35F}\",\n    \"frog\": \"\\u{1F438}\",\n    \"frowning\": \"\\u{1F626}\",\n    \"frowning_face\": \"\\u2639\\uFE0F\",\n    \"frowning_man\": \"\\u{1F64D}&zwj;\\u2642\\uFE0F\",\n    \"frowning_woman\": \"\\u{1F64D}\",\n    \"middle_finger\": \"\\u{1F595}\",\n    \"fuelpump\": \"\\u26FD\\uFE0F\",\n    \"full_moon\": \"\\u{1F315}\",\n    \"full_moon_with_face\": \"\\u{1F31D}\",\n    \"funeral_urn\": \"\\u26B1\\uFE0F\",\n    \"game_die\": \"\\u{1F3B2}\",\n    \"gear\": \"\\u2699\\uFE0F\",\n    \"gem\": \"\\u{1F48E}\",\n    \"gemini\": \"\\u264A\\uFE0F\",\n    \"ghost\": \"\\u{1F47B}\",\n    \"gift\": \"\\u{1F381}\",\n    \"gift_heart\": \"\\u{1F49D}\",\n    \"girl\": \"\\u{1F467}\",\n    \"globe_with_meridians\": \"\\u{1F310}\",\n    \"goal_net\": \"\\u{1F945}\",\n    \"goat\": \"\\u{1F410}\",\n    \"golf\": \"\\u26F3\\uFE0F\",\n    \"golfing_man\": \"\\u{1F3CC}\\uFE0F\",\n    \"golfing_woman\": \"\\u{1F3CC}\\uFE0F&zwj;\\u2640\\uFE0F\",\n    \"gorilla\": \"\\u{1F98D}\",\n    \"grapes\": \"\\u{1F347}\",\n    \"green_apple\": \"\\u{1F34F}\",\n    \"green_book\": \"\\u{1F4D7}\",\n    \"green_heart\": \"\\u{1F49A}\",\n    \"green_salad\": \"\\u{1F957}\",\n    \"grey_exclamation\": \"\\u2755\",\n    \"grey_question\": \"\\u2754\",\n    \"grimacing\": \"\\u{1F62C}\",\n    \"grin\": \"\\u{1F601}\",\n    \"grinning\": \"\\u{1F600}\",\n    \"guardsman\": \"\\u{1F482}\",\n    \"guardswoman\": \"\\u{1F482}&zwj;\\u2640\\uFE0F\",\n    \"guitar\": \"\\u{1F3B8}\",\n    \"gun\": \"\\u{1F52B}\",\n    \"haircut_woman\": \"\\u{1F487}\",\n    \"haircut_man\": \"\\u{1F487}&zwj;\\u2642\\uFE0F\",\n    \"hamburger\": \"\\u{1F354}\",\n    \"hammer\": \"\\u{1F528}\",\n    \"hammer_and_pick\": \"\\u2692\",\n    \"hammer_and_wrench\": \"\\u{1F6E0}\",\n    \"hamster\": \"\\u{1F439}\",\n    \"hand\": \"\\u270B\",\n    \"handbag\": \"\\u{1F45C}\",\n    \"handshake\": \"\\u{1F91D}\",\n    \"hankey\": \"\\u{1F4A9}\",\n    \"hatched_chick\": \"\\u{1F425}\",\n    \"hatching_chick\": \"\\u{1F423}\",\n    \"headphones\": \"\\u{1F3A7}\",\n    \"hear_no_evil\": \"\\u{1F649}\",\n    \"heart\": \"\\u2764\\uFE0F\",\n    \"heart_decoration\": \"\\u{1F49F}\",\n    \"heart_eyes\": \"\\u{1F60D}\",\n    \"heart_eyes_cat\": \"\\u{1F63B}\",\n    \"heartbeat\": \"\\u{1F493}\",\n    \"heartpulse\": \"\\u{1F497}\",\n    \"hearts\": \"\\u2665\\uFE0F\",\n    \"heavy_check_mark\": \"\\u2714\\uFE0F\",\n    \"heavy_division_sign\": \"\\u2797\",\n    \"heavy_dollar_sign\": \"\\u{1F4B2}\",\n    \"heavy_heart_exclamation\": \"\\u2763\\uFE0F\",\n    \"heavy_minus_sign\": \"\\u2796\",\n    \"heavy_multiplication_x\": \"\\u2716\\uFE0F\",\n    \"heavy_plus_sign\": \"\\u2795\",\n    \"helicopter\": \"\\u{1F681}\",\n    \"herb\": \"\\u{1F33F}\",\n    \"hibiscus\": \"\\u{1F33A}\",\n    \"high_brightness\": \"\\u{1F506}\",\n    \"high_heel\": \"\\u{1F460}\",\n    \"hocho\": \"\\u{1F52A}\",\n    \"hole\": \"\\u{1F573}\",\n    \"honey_pot\": \"\\u{1F36F}\",\n    \"horse\": \"\\u{1F434}\",\n    \"horse_racing\": \"\\u{1F3C7}\",\n    \"hospital\": \"\\u{1F3E5}\",\n    \"hot_pepper\": \"\\u{1F336}\",\n    \"hotdog\": \"\\u{1F32D}\",\n    \"hotel\": \"\\u{1F3E8}\",\n    \"hotsprings\": \"\\u2668\\uFE0F\",\n    \"hourglass\": \"\\u231B\\uFE0F\",\n    \"hourglass_flowing_sand\": \"\\u23F3\",\n    \"house\": \"\\u{1F3E0}\",\n    \"house_with_garden\": \"\\u{1F3E1}\",\n    \"houses\": \"\\u{1F3D8}\",\n    \"hugs\": \"\\u{1F917}\",\n    \"hushed\": \"\\u{1F62F}\",\n    \"ice_cream\": \"\\u{1F368}\",\n    \"ice_hockey\": \"\\u{1F3D2}\",\n    \"ice_skate\": \"\\u26F8\",\n    \"icecream\": \"\\u{1F366}\",\n    \"id\": \"\\u{1F194}\",\n    \"ideograph_advantage\": \"\\u{1F250}\",\n    \"imp\": \"\\u{1F47F}\",\n    \"inbox_tray\": \"\\u{1F4E5}\",\n    \"incoming_envelope\": \"\\u{1F4E8}\",\n    \"tipping_hand_woman\": \"\\u{1F481}\",\n    \"information_source\": \"\\u2139\\uFE0F\",\n    \"innocent\": \"\\u{1F607}\",\n    \"interrobang\": \"\\u2049\\uFE0F\",\n    \"iphone\": \"\\u{1F4F1}\",\n    \"izakaya_lantern\": \"\\u{1F3EE}\",\n    \"jack_o_lantern\": \"\\u{1F383}\",\n    \"japan\": \"\\u{1F5FE}\",\n    \"japanese_castle\": \"\\u{1F3EF}\",\n    \"japanese_goblin\": \"\\u{1F47A}\",\n    \"japanese_ogre\": \"\\u{1F479}\",\n    \"jeans\": \"\\u{1F456}\",\n    \"joy\": \"\\u{1F602}\",\n    \"joy_cat\": \"\\u{1F639}\",\n    \"joystick\": \"\\u{1F579}\",\n    \"kaaba\": \"\\u{1F54B}\",\n    \"key\": \"\\u{1F511}\",\n    \"keyboard\": \"\\u2328\\uFE0F\",\n    \"keycap_ten\": \"\\u{1F51F}\",\n    \"kick_scooter\": \"\\u{1F6F4}\",\n    \"kimono\": \"\\u{1F458}\",\n    \"kiss\": \"\\u{1F48B}\",\n    \"kissing\": \"\\u{1F617}\",\n    \"kissing_cat\": \"\\u{1F63D}\",\n    \"kissing_closed_eyes\": \"\\u{1F61A}\",\n    \"kissing_heart\": \"\\u{1F618}\",\n    \"kissing_smiling_eyes\": \"\\u{1F619}\",\n    \"kiwi_fruit\": \"\\u{1F95D}\",\n    \"koala\": \"\\u{1F428}\",\n    \"koko\": \"\\u{1F201}\",\n    \"label\": \"\\u{1F3F7}\",\n    \"large_blue_circle\": \"\\u{1F535}\",\n    \"large_blue_diamond\": \"\\u{1F537}\",\n    \"large_orange_diamond\": \"\\u{1F536}\",\n    \"last_quarter_moon\": \"\\u{1F317}\",\n    \"last_quarter_moon_with_face\": \"\\u{1F31C}\",\n    \"latin_cross\": \"\\u271D\\uFE0F\",\n    \"laughing\": \"\\u{1F606}\",\n    \"leaves\": \"\\u{1F343}\",\n    \"ledger\": \"\\u{1F4D2}\",\n    \"left_luggage\": \"\\u{1F6C5}\",\n    \"left_right_arrow\": \"\\u2194\\uFE0F\",\n    \"leftwards_arrow_with_hook\": \"\\u21A9\\uFE0F\",\n    \"lemon\": \"\\u{1F34B}\",\n    \"leo\": \"\\u264C\\uFE0F\",\n    \"leopard\": \"\\u{1F406}\",\n    \"level_slider\": \"\\u{1F39A}\",\n    \"libra\": \"\\u264E\\uFE0F\",\n    \"light_rail\": \"\\u{1F688}\",\n    \"link\": \"\\u{1F517}\",\n    \"lion\": \"\\u{1F981}\",\n    \"lips\": \"\\u{1F444}\",\n    \"lipstick\": \"\\u{1F484}\",\n    \"lizard\": \"\\u{1F98E}\",\n    \"lock\": \"\\u{1F512}\",\n    \"lock_with_ink_pen\": \"\\u{1F50F}\",\n    \"lollipop\": \"\\u{1F36D}\",\n    \"loop\": \"\\u27BF\",\n    \"loud_sound\": \"\\u{1F50A}\",\n    \"loudspeaker\": \"\\u{1F4E2}\",\n    \"love_hotel\": \"\\u{1F3E9}\",\n    \"love_letter\": \"\\u{1F48C}\",\n    \"low_brightness\": \"\\u{1F505}\",\n    \"lying_face\": \"\\u{1F925}\",\n    \"m\": \"\\u24C2\\uFE0F\",\n    \"mag\": \"\\u{1F50D}\",\n    \"mag_right\": \"\\u{1F50E}\",\n    \"mahjong\": \"\\u{1F004}\\uFE0F\",\n    \"mailbox\": \"\\u{1F4EB}\",\n    \"mailbox_closed\": \"\\u{1F4EA}\",\n    \"mailbox_with_mail\": \"\\u{1F4EC}\",\n    \"mailbox_with_no_mail\": \"\\u{1F4ED}\",\n    \"man\": \"\\u{1F468}\",\n    \"man_artist\": \"\\u{1F468}&zwj;\\u{1F3A8}\",\n    \"man_astronaut\": \"\\u{1F468}&zwj;\\u{1F680}\",\n    \"man_cartwheeling\": \"\\u{1F938}&zwj;\\u2642\\uFE0F\",\n    \"man_cook\": \"\\u{1F468}&zwj;\\u{1F373}\",\n    \"man_dancing\": \"\\u{1F57A}\",\n    \"man_facepalming\": \"\\u{1F926}&zwj;\\u2642\\uFE0F\",\n    \"man_factory_worker\": \"\\u{1F468}&zwj;\\u{1F3ED}\",\n    \"man_farmer\": \"\\u{1F468}&zwj;\\u{1F33E}\",\n    \"man_firefighter\": \"\\u{1F468}&zwj;\\u{1F692}\",\n    \"man_health_worker\": \"\\u{1F468}&zwj;\\u2695\\uFE0F\",\n    \"man_in_tuxedo\": \"\\u{1F935}\",\n    \"man_judge\": \"\\u{1F468}&zwj;\\u2696\\uFE0F\",\n    \"man_juggling\": \"\\u{1F939}&zwj;\\u2642\\uFE0F\",\n    \"man_mechanic\": \"\\u{1F468}&zwj;\\u{1F527}\",\n    \"man_office_worker\": \"\\u{1F468}&zwj;\\u{1F4BC}\",\n    \"man_pilot\": \"\\u{1F468}&zwj;\\u2708\\uFE0F\",\n    \"man_playing_handball\": \"\\u{1F93E}&zwj;\\u2642\\uFE0F\",\n    \"man_playing_water_polo\": \"\\u{1F93D}&zwj;\\u2642\\uFE0F\",\n    \"man_scientist\": \"\\u{1F468}&zwj;\\u{1F52C}\",\n    \"man_shrugging\": \"\\u{1F937}&zwj;\\u2642\\uFE0F\",\n    \"man_singer\": \"\\u{1F468}&zwj;\\u{1F3A4}\",\n    \"man_student\": \"\\u{1F468}&zwj;\\u{1F393}\",\n    \"man_teacher\": \"\\u{1F468}&zwj;\\u{1F3EB}\",\n    \"man_technologist\": \"\\u{1F468}&zwj;\\u{1F4BB}\",\n    \"man_with_gua_pi_mao\": \"\\u{1F472}\",\n    \"man_with_turban\": \"\\u{1F473}\",\n    \"tangerine\": \"\\u{1F34A}\",\n    \"mans_shoe\": \"\\u{1F45E}\",\n    \"mantelpiece_clock\": \"\\u{1F570}\",\n    \"maple_leaf\": \"\\u{1F341}\",\n    \"martial_arts_uniform\": \"\\u{1F94B}\",\n    \"mask\": \"\\u{1F637}\",\n    \"massage_woman\": \"\\u{1F486}\",\n    \"massage_man\": \"\\u{1F486}&zwj;\\u2642\\uFE0F\",\n    \"meat_on_bone\": \"\\u{1F356}\",\n    \"medal_military\": \"\\u{1F396}\",\n    \"medal_sports\": \"\\u{1F3C5}\",\n    \"mega\": \"\\u{1F4E3}\",\n    \"melon\": \"\\u{1F348}\",\n    \"memo\": \"\\u{1F4DD}\",\n    \"men_wrestling\": \"\\u{1F93C}&zwj;\\u2642\\uFE0F\",\n    \"menorah\": \"\\u{1F54E}\",\n    \"mens\": \"\\u{1F6B9}\",\n    \"metal\": \"\\u{1F918}\",\n    \"metro\": \"\\u{1F687}\",\n    \"microphone\": \"\\u{1F3A4}\",\n    \"microscope\": \"\\u{1F52C}\",\n    \"milk_glass\": \"\\u{1F95B}\",\n    \"milky_way\": \"\\u{1F30C}\",\n    \"minibus\": \"\\u{1F690}\",\n    \"minidisc\": \"\\u{1F4BD}\",\n    \"mobile_phone_off\": \"\\u{1F4F4}\",\n    \"money_mouth_face\": \"\\u{1F911}\",\n    \"money_with_wings\": \"\\u{1F4B8}\",\n    \"moneybag\": \"\\u{1F4B0}\",\n    \"monkey\": \"\\u{1F412}\",\n    \"monkey_face\": \"\\u{1F435}\",\n    \"monorail\": \"\\u{1F69D}\",\n    \"moon\": \"\\u{1F314}\",\n    \"mortar_board\": \"\\u{1F393}\",\n    \"mosque\": \"\\u{1F54C}\",\n    \"motor_boat\": \"\\u{1F6E5}\",\n    \"motor_scooter\": \"\\u{1F6F5}\",\n    \"motorcycle\": \"\\u{1F3CD}\",\n    \"motorway\": \"\\u{1F6E3}\",\n    \"mount_fuji\": \"\\u{1F5FB}\",\n    \"mountain\": \"\\u26F0\",\n    \"mountain_biking_man\": \"\\u{1F6B5}\",\n    \"mountain_biking_woman\": \"\\u{1F6B5}&zwj;\\u2640\\uFE0F\",\n    \"mountain_cableway\": \"\\u{1F6A0}\",\n    \"mountain_railway\": \"\\u{1F69E}\",\n    \"mountain_snow\": \"\\u{1F3D4}\",\n    \"mouse\": \"\\u{1F42D}\",\n    \"mouse2\": \"\\u{1F401}\",\n    \"movie_camera\": \"\\u{1F3A5}\",\n    \"moyai\": \"\\u{1F5FF}\",\n    \"mrs_claus\": \"\\u{1F936}\",\n    \"muscle\": \"\\u{1F4AA}\",\n    \"mushroom\": \"\\u{1F344}\",\n    \"musical_keyboard\": \"\\u{1F3B9}\",\n    \"musical_note\": \"\\u{1F3B5}\",\n    \"musical_score\": \"\\u{1F3BC}\",\n    \"mute\": \"\\u{1F507}\",\n    \"nail_care\": \"\\u{1F485}\",\n    \"name_badge\": \"\\u{1F4DB}\",\n    \"national_park\": \"\\u{1F3DE}\",\n    \"nauseated_face\": \"\\u{1F922}\",\n    \"necktie\": \"\\u{1F454}\",\n    \"negative_squared_cross_mark\": \"\\u274E\",\n    \"nerd_face\": \"\\u{1F913}\",\n    \"neutral_face\": \"\\u{1F610}\",\n    \"new\": \"\\u{1F195}\",\n    \"new_moon\": \"\\u{1F311}\",\n    \"new_moon_with_face\": \"\\u{1F31A}\",\n    \"newspaper\": \"\\u{1F4F0}\",\n    \"newspaper_roll\": \"\\u{1F5DE}\",\n    \"next_track_button\": \"\\u23ED\",\n    \"ng\": \"\\u{1F196}\",\n    \"no_good_man\": \"\\u{1F645}&zwj;\\u2642\\uFE0F\",\n    \"no_good_woman\": \"\\u{1F645}\",\n    \"night_with_stars\": \"\\u{1F303}\",\n    \"no_bell\": \"\\u{1F515}\",\n    \"no_bicycles\": \"\\u{1F6B3}\",\n    \"no_entry\": \"\\u26D4\\uFE0F\",\n    \"no_entry_sign\": \"\\u{1F6AB}\",\n    \"no_mobile_phones\": \"\\u{1F4F5}\",\n    \"no_mouth\": \"\\u{1F636}\",\n    \"no_pedestrians\": \"\\u{1F6B7}\",\n    \"no_smoking\": \"\\u{1F6AD}\",\n    \"non-potable_water\": \"\\u{1F6B1}\",\n    \"nose\": \"\\u{1F443}\",\n    \"notebook\": \"\\u{1F4D3}\",\n    \"notebook_with_decorative_cover\": \"\\u{1F4D4}\",\n    \"notes\": \"\\u{1F3B6}\",\n    \"nut_and_bolt\": \"\\u{1F529}\",\n    \"o\": \"\\u2B55\\uFE0F\",\n    \"o2\": \"\\u{1F17E}\\uFE0F\",\n    \"ocean\": \"\\u{1F30A}\",\n    \"octopus\": \"\\u{1F419}\",\n    \"oden\": \"\\u{1F362}\",\n    \"office\": \"\\u{1F3E2}\",\n    \"oil_drum\": \"\\u{1F6E2}\",\n    \"ok\": \"\\u{1F197}\",\n    \"ok_hand\": \"\\u{1F44C}\",\n    \"ok_man\": \"\\u{1F646}&zwj;\\u2642\\uFE0F\",\n    \"ok_woman\": \"\\u{1F646}\",\n    \"old_key\": \"\\u{1F5DD}\",\n    \"older_man\": \"\\u{1F474}\",\n    \"older_woman\": \"\\u{1F475}\",\n    \"om\": \"\\u{1F549}\",\n    \"on\": \"\\u{1F51B}\",\n    \"oncoming_automobile\": \"\\u{1F698}\",\n    \"oncoming_bus\": \"\\u{1F68D}\",\n    \"oncoming_police_car\": \"\\u{1F694}\",\n    \"oncoming_taxi\": \"\\u{1F696}\",\n    \"open_file_folder\": \"\\u{1F4C2}\",\n    \"open_hands\": \"\\u{1F450}\",\n    \"open_mouth\": \"\\u{1F62E}\",\n    \"open_umbrella\": \"\\u2602\\uFE0F\",\n    \"ophiuchus\": \"\\u26CE\",\n    \"orange_book\": \"\\u{1F4D9}\",\n    \"orthodox_cross\": \"\\u2626\\uFE0F\",\n    \"outbox_tray\": \"\\u{1F4E4}\",\n    \"owl\": \"\\u{1F989}\",\n    \"ox\": \"\\u{1F402}\",\n    \"package\": \"\\u{1F4E6}\",\n    \"page_facing_up\": \"\\u{1F4C4}\",\n    \"page_with_curl\": \"\\u{1F4C3}\",\n    \"pager\": \"\\u{1F4DF}\",\n    \"paintbrush\": \"\\u{1F58C}\",\n    \"palm_tree\": \"\\u{1F334}\",\n    \"pancakes\": \"\\u{1F95E}\",\n    \"panda_face\": \"\\u{1F43C}\",\n    \"paperclip\": \"\\u{1F4CE}\",\n    \"paperclips\": \"\\u{1F587}\",\n    \"parasol_on_ground\": \"\\u26F1\",\n    \"parking\": \"\\u{1F17F}\\uFE0F\",\n    \"part_alternation_mark\": \"\\u303D\\uFE0F\",\n    \"partly_sunny\": \"\\u26C5\\uFE0F\",\n    \"passenger_ship\": \"\\u{1F6F3}\",\n    \"passport_control\": \"\\u{1F6C2}\",\n    \"pause_button\": \"\\u23F8\",\n    \"peace_symbol\": \"\\u262E\\uFE0F\",\n    \"peach\": \"\\u{1F351}\",\n    \"peanuts\": \"\\u{1F95C}\",\n    \"pear\": \"\\u{1F350}\",\n    \"pen\": \"\\u{1F58A}\",\n    \"pencil2\": \"\\u270F\\uFE0F\",\n    \"penguin\": \"\\u{1F427}\",\n    \"pensive\": \"\\u{1F614}\",\n    \"performing_arts\": \"\\u{1F3AD}\",\n    \"persevere\": \"\\u{1F623}\",\n    \"person_fencing\": \"\\u{1F93A}\",\n    \"pouting_woman\": \"\\u{1F64E}\",\n    \"phone\": \"\\u260E\\uFE0F\",\n    \"pick\": \"\\u26CF\",\n    \"pig\": \"\\u{1F437}\",\n    \"pig2\": \"\\u{1F416}\",\n    \"pig_nose\": \"\\u{1F43D}\",\n    \"pill\": \"\\u{1F48A}\",\n    \"pineapple\": \"\\u{1F34D}\",\n    \"ping_pong\": \"\\u{1F3D3}\",\n    \"pisces\": \"\\u2653\\uFE0F\",\n    \"pizza\": \"\\u{1F355}\",\n    \"place_of_worship\": \"\\u{1F6D0}\",\n    \"plate_with_cutlery\": \"\\u{1F37D}\",\n    \"play_or_pause_button\": \"\\u23EF\",\n    \"point_down\": \"\\u{1F447}\",\n    \"point_left\": \"\\u{1F448}\",\n    \"point_right\": \"\\u{1F449}\",\n    \"point_up\": \"\\u261D\\uFE0F\",\n    \"point_up_2\": \"\\u{1F446}\",\n    \"police_car\": \"\\u{1F693}\",\n    \"policewoman\": \"\\u{1F46E}&zwj;\\u2640\\uFE0F\",\n    \"poodle\": \"\\u{1F429}\",\n    \"popcorn\": \"\\u{1F37F}\",\n    \"post_office\": \"\\u{1F3E3}\",\n    \"postal_horn\": \"\\u{1F4EF}\",\n    \"postbox\": \"\\u{1F4EE}\",\n    \"potable_water\": \"\\u{1F6B0}\",\n    \"potato\": \"\\u{1F954}\",\n    \"pouch\": \"\\u{1F45D}\",\n    \"poultry_leg\": \"\\u{1F357}\",\n    \"pound\": \"\\u{1F4B7}\",\n    \"rage\": \"\\u{1F621}\",\n    \"pouting_cat\": \"\\u{1F63E}\",\n    \"pouting_man\": \"\\u{1F64E}&zwj;\\u2642\\uFE0F\",\n    \"pray\": \"\\u{1F64F}\",\n    \"prayer_beads\": \"\\u{1F4FF}\",\n    \"pregnant_woman\": \"\\u{1F930}\",\n    \"previous_track_button\": \"\\u23EE\",\n    \"prince\": \"\\u{1F934}\",\n    \"princess\": \"\\u{1F478}\",\n    \"printer\": \"\\u{1F5A8}\",\n    \"purple_heart\": \"\\u{1F49C}\",\n    \"purse\": \"\\u{1F45B}\",\n    \"pushpin\": \"\\u{1F4CC}\",\n    \"put_litter_in_its_place\": \"\\u{1F6AE}\",\n    \"question\": \"\\u2753\",\n    \"rabbit\": \"\\u{1F430}\",\n    \"rabbit2\": \"\\u{1F407}\",\n    \"racehorse\": \"\\u{1F40E}\",\n    \"racing_car\": \"\\u{1F3CE}\",\n    \"radio\": \"\\u{1F4FB}\",\n    \"radio_button\": \"\\u{1F518}\",\n    \"radioactive\": \"\\u2622\\uFE0F\",\n    \"railway_car\": \"\\u{1F683}\",\n    \"railway_track\": \"\\u{1F6E4}\",\n    \"rainbow\": \"\\u{1F308}\",\n    \"rainbow_flag\": \"\\u{1F3F3}\\uFE0F&zwj;\\u{1F308}\",\n    \"raised_back_of_hand\": \"\\u{1F91A}\",\n    \"raised_hand_with_fingers_splayed\": \"\\u{1F590}\",\n    \"raised_hands\": \"\\u{1F64C}\",\n    \"raising_hand_woman\": \"\\u{1F64B}\",\n    \"raising_hand_man\": \"\\u{1F64B}&zwj;\\u2642\\uFE0F\",\n    \"ram\": \"\\u{1F40F}\",\n    \"ramen\": \"\\u{1F35C}\",\n    \"rat\": \"\\u{1F400}\",\n    \"record_button\": \"\\u23FA\",\n    \"recycle\": \"\\u267B\\uFE0F\",\n    \"red_circle\": \"\\u{1F534}\",\n    \"registered\": \"\\xAE\\uFE0F\",\n    \"relaxed\": \"\\u263A\\uFE0F\",\n    \"relieved\": \"\\u{1F60C}\",\n    \"reminder_ribbon\": \"\\u{1F397}\",\n    \"repeat\": \"\\u{1F501}\",\n    \"repeat_one\": \"\\u{1F502}\",\n    \"rescue_worker_helmet\": \"\\u26D1\",\n    \"restroom\": \"\\u{1F6BB}\",\n    \"revolving_hearts\": \"\\u{1F49E}\",\n    \"rewind\": \"\\u23EA\",\n    \"rhinoceros\": \"\\u{1F98F}\",\n    \"ribbon\": \"\\u{1F380}\",\n    \"rice\": \"\\u{1F35A}\",\n    \"rice_ball\": \"\\u{1F359}\",\n    \"rice_cracker\": \"\\u{1F358}\",\n    \"rice_scene\": \"\\u{1F391}\",\n    \"right_anger_bubble\": \"\\u{1F5EF}\",\n    \"ring\": \"\\u{1F48D}\",\n    \"robot\": \"\\u{1F916}\",\n    \"rocket\": \"\\u{1F680}\",\n    \"rofl\": \"\\u{1F923}\",\n    \"roll_eyes\": \"\\u{1F644}\",\n    \"roller_coaster\": \"\\u{1F3A2}\",\n    \"rooster\": \"\\u{1F413}\",\n    \"rose\": \"\\u{1F339}\",\n    \"rosette\": \"\\u{1F3F5}\",\n    \"rotating_light\": \"\\u{1F6A8}\",\n    \"round_pushpin\": \"\\u{1F4CD}\",\n    \"rowing_man\": \"\\u{1F6A3}\",\n    \"rowing_woman\": \"\\u{1F6A3}&zwj;\\u2640\\uFE0F\",\n    \"rugby_football\": \"\\u{1F3C9}\",\n    \"running_man\": \"\\u{1F3C3}\",\n    \"running_shirt_with_sash\": \"\\u{1F3BD}\",\n    \"running_woman\": \"\\u{1F3C3}&zwj;\\u2640\\uFE0F\",\n    \"sa\": \"\\u{1F202}\\uFE0F\",\n    \"sagittarius\": \"\\u2650\\uFE0F\",\n    \"sake\": \"\\u{1F376}\",\n    \"sandal\": \"\\u{1F461}\",\n    \"santa\": \"\\u{1F385}\",\n    \"satellite\": \"\\u{1F4E1}\",\n    \"saxophone\": \"\\u{1F3B7}\",\n    \"school\": \"\\u{1F3EB}\",\n    \"school_satchel\": \"\\u{1F392}\",\n    \"scissors\": \"\\u2702\\uFE0F\",\n    \"scorpion\": \"\\u{1F982}\",\n    \"scorpius\": \"\\u264F\\uFE0F\",\n    \"scream\": \"\\u{1F631}\",\n    \"scream_cat\": \"\\u{1F640}\",\n    \"scroll\": \"\\u{1F4DC}\",\n    \"seat\": \"\\u{1F4BA}\",\n    \"secret\": \"\\u3299\\uFE0F\",\n    \"see_no_evil\": \"\\u{1F648}\",\n    \"seedling\": \"\\u{1F331}\",\n    \"selfie\": \"\\u{1F933}\",\n    \"shallow_pan_of_food\": \"\\u{1F958}\",\n    \"shamrock\": \"\\u2618\\uFE0F\",\n    \"shark\": \"\\u{1F988}\",\n    \"shaved_ice\": \"\\u{1F367}\",\n    \"sheep\": \"\\u{1F411}\",\n    \"shell\": \"\\u{1F41A}\",\n    \"shield\": \"\\u{1F6E1}\",\n    \"shinto_shrine\": \"\\u26E9\",\n    \"ship\": \"\\u{1F6A2}\",\n    \"shirt\": \"\\u{1F455}\",\n    \"shopping\": \"\\u{1F6CD}\",\n    \"shopping_cart\": \"\\u{1F6D2}\",\n    \"shower\": \"\\u{1F6BF}\",\n    \"shrimp\": \"\\u{1F990}\",\n    \"signal_strength\": \"\\u{1F4F6}\",\n    \"six_pointed_star\": \"\\u{1F52F}\",\n    \"ski\": \"\\u{1F3BF}\",\n    \"skier\": \"\\u26F7\",\n    \"skull\": \"\\u{1F480}\",\n    \"skull_and_crossbones\": \"\\u2620\\uFE0F\",\n    \"sleeping\": \"\\u{1F634}\",\n    \"sleeping_bed\": \"\\u{1F6CC}\",\n    \"sleepy\": \"\\u{1F62A}\",\n    \"slightly_frowning_face\": \"\\u{1F641}\",\n    \"slightly_smiling_face\": \"\\u{1F642}\",\n    \"slot_machine\": \"\\u{1F3B0}\",\n    \"small_airplane\": \"\\u{1F6E9}\",\n    \"small_blue_diamond\": \"\\u{1F539}\",\n    \"small_orange_diamond\": \"\\u{1F538}\",\n    \"small_red_triangle\": \"\\u{1F53A}\",\n    \"small_red_triangle_down\": \"\\u{1F53B}\",\n    \"smile\": \"\\u{1F604}\",\n    \"smile_cat\": \"\\u{1F638}\",\n    \"smiley\": \"\\u{1F603}\",\n    \"smiley_cat\": \"\\u{1F63A}\",\n    \"smiling_imp\": \"\\u{1F608}\",\n    \"smirk\": \"\\u{1F60F}\",\n    \"smirk_cat\": \"\\u{1F63C}\",\n    \"smoking\": \"\\u{1F6AC}\",\n    \"snail\": \"\\u{1F40C}\",\n    \"snake\": \"\\u{1F40D}\",\n    \"sneezing_face\": \"\\u{1F927}\",\n    \"snowboarder\": \"\\u{1F3C2}\",\n    \"snowflake\": \"\\u2744\\uFE0F\",\n    \"snowman\": \"\\u26C4\\uFE0F\",\n    \"snowman_with_snow\": \"\\u2603\\uFE0F\",\n    \"sob\": \"\\u{1F62D}\",\n    \"soccer\": \"\\u26BD\\uFE0F\",\n    \"soon\": \"\\u{1F51C}\",\n    \"sos\": \"\\u{1F198}\",\n    \"sound\": \"\\u{1F509}\",\n    \"space_invader\": \"\\u{1F47E}\",\n    \"spades\": \"\\u2660\\uFE0F\",\n    \"spaghetti\": \"\\u{1F35D}\",\n    \"sparkle\": \"\\u2747\\uFE0F\",\n    \"sparkler\": \"\\u{1F387}\",\n    \"sparkles\": \"\\u2728\",\n    \"sparkling_heart\": \"\\u{1F496}\",\n    \"speak_no_evil\": \"\\u{1F64A}\",\n    \"speaker\": \"\\u{1F508}\",\n    \"speaking_head\": \"\\u{1F5E3}\",\n    \"speech_balloon\": \"\\u{1F4AC}\",\n    \"speedboat\": \"\\u{1F6A4}\",\n    \"spider\": \"\\u{1F577}\",\n    \"spider_web\": \"\\u{1F578}\",\n    \"spiral_calendar\": \"\\u{1F5D3}\",\n    \"spiral_notepad\": \"\\u{1F5D2}\",\n    \"spoon\": \"\\u{1F944}\",\n    \"squid\": \"\\u{1F991}\",\n    \"stadium\": \"\\u{1F3DF}\",\n    \"star\": \"\\u2B50\\uFE0F\",\n    \"star2\": \"\\u{1F31F}\",\n    \"star_and_crescent\": \"\\u262A\\uFE0F\",\n    \"star_of_david\": \"\\u2721\\uFE0F\",\n    \"stars\": \"\\u{1F320}\",\n    \"station\": \"\\u{1F689}\",\n    \"statue_of_liberty\": \"\\u{1F5FD}\",\n    \"steam_locomotive\": \"\\u{1F682}\",\n    \"stew\": \"\\u{1F372}\",\n    \"stop_button\": \"\\u23F9\",\n    \"stop_sign\": \"\\u{1F6D1}\",\n    \"stopwatch\": \"\\u23F1\",\n    \"straight_ruler\": \"\\u{1F4CF}\",\n    \"strawberry\": \"\\u{1F353}\",\n    \"stuck_out_tongue\": \"\\u{1F61B}\",\n    \"stuck_out_tongue_closed_eyes\": \"\\u{1F61D}\",\n    \"stuck_out_tongue_winking_eye\": \"\\u{1F61C}\",\n    \"studio_microphone\": \"\\u{1F399}\",\n    \"stuffed_flatbread\": \"\\u{1F959}\",\n    \"sun_behind_large_cloud\": \"\\u{1F325}\",\n    \"sun_behind_rain_cloud\": \"\\u{1F326}\",\n    \"sun_behind_small_cloud\": \"\\u{1F324}\",\n    \"sun_with_face\": \"\\u{1F31E}\",\n    \"sunflower\": \"\\u{1F33B}\",\n    \"sunglasses\": \"\\u{1F60E}\",\n    \"sunny\": \"\\u2600\\uFE0F\",\n    \"sunrise\": \"\\u{1F305}\",\n    \"sunrise_over_mountains\": \"\\u{1F304}\",\n    \"surfing_man\": \"\\u{1F3C4}\",\n    \"surfing_woman\": \"\\u{1F3C4}&zwj;\\u2640\\uFE0F\",\n    \"sushi\": \"\\u{1F363}\",\n    \"suspension_railway\": \"\\u{1F69F}\",\n    \"sweat\": \"\\u{1F613}\",\n    \"sweat_drops\": \"\\u{1F4A6}\",\n    \"sweat_smile\": \"\\u{1F605}\",\n    \"sweet_potato\": \"\\u{1F360}\",\n    \"swimming_man\": \"\\u{1F3CA}\",\n    \"swimming_woman\": \"\\u{1F3CA}&zwj;\\u2640\\uFE0F\",\n    \"symbols\": \"\\u{1F523}\",\n    \"synagogue\": \"\\u{1F54D}\",\n    \"syringe\": \"\\u{1F489}\",\n    \"taco\": \"\\u{1F32E}\",\n    \"tada\": \"\\u{1F389}\",\n    \"tanabata_tree\": \"\\u{1F38B}\",\n    \"taurus\": \"\\u2649\\uFE0F\",\n    \"taxi\": \"\\u{1F695}\",\n    \"tea\": \"\\u{1F375}\",\n    \"telephone_receiver\": \"\\u{1F4DE}\",\n    \"telescope\": \"\\u{1F52D}\",\n    \"tennis\": \"\\u{1F3BE}\",\n    \"tent\": \"\\u26FA\\uFE0F\",\n    \"thermometer\": \"\\u{1F321}\",\n    \"thinking\": \"\\u{1F914}\",\n    \"thought_balloon\": \"\\u{1F4AD}\",\n    \"ticket\": \"\\u{1F3AB}\",\n    \"tickets\": \"\\u{1F39F}\",\n    \"tiger\": \"\\u{1F42F}\",\n    \"tiger2\": \"\\u{1F405}\",\n    \"timer_clock\": \"\\u23F2\",\n    \"tipping_hand_man\": \"\\u{1F481}&zwj;\\u2642\\uFE0F\",\n    \"tired_face\": \"\\u{1F62B}\",\n    \"tm\": \"\\u2122\\uFE0F\",\n    \"toilet\": \"\\u{1F6BD}\",\n    \"tokyo_tower\": \"\\u{1F5FC}\",\n    \"tomato\": \"\\u{1F345}\",\n    \"tongue\": \"\\u{1F445}\",\n    \"top\": \"\\u{1F51D}\",\n    \"tophat\": \"\\u{1F3A9}\",\n    \"tornado\": \"\\u{1F32A}\",\n    \"trackball\": \"\\u{1F5B2}\",\n    \"tractor\": \"\\u{1F69C}\",\n    \"traffic_light\": \"\\u{1F6A5}\",\n    \"train\": \"\\u{1F68B}\",\n    \"train2\": \"\\u{1F686}\",\n    \"tram\": \"\\u{1F68A}\",\n    \"triangular_flag_on_post\": \"\\u{1F6A9}\",\n    \"triangular_ruler\": \"\\u{1F4D0}\",\n    \"trident\": \"\\u{1F531}\",\n    \"triumph\": \"\\u{1F624}\",\n    \"trolleybus\": \"\\u{1F68E}\",\n    \"trophy\": \"\\u{1F3C6}\",\n    \"tropical_drink\": \"\\u{1F379}\",\n    \"tropical_fish\": \"\\u{1F420}\",\n    \"truck\": \"\\u{1F69A}\",\n    \"trumpet\": \"\\u{1F3BA}\",\n    \"tulip\": \"\\u{1F337}\",\n    \"tumbler_glass\": \"\\u{1F943}\",\n    \"turkey\": \"\\u{1F983}\",\n    \"turtle\": \"\\u{1F422}\",\n    \"tv\": \"\\u{1F4FA}\",\n    \"twisted_rightwards_arrows\": \"\\u{1F500}\",\n    \"two_hearts\": \"\\u{1F495}\",\n    \"two_men_holding_hands\": \"\\u{1F46C}\",\n    \"two_women_holding_hands\": \"\\u{1F46D}\",\n    \"u5272\": \"\\u{1F239}\",\n    \"u5408\": \"\\u{1F234}\",\n    \"u55b6\": \"\\u{1F23A}\",\n    \"u6307\": \"\\u{1F22F}\\uFE0F\",\n    \"u6708\": \"\\u{1F237}\\uFE0F\",\n    \"u6709\": \"\\u{1F236}\",\n    \"u6e80\": \"\\u{1F235}\",\n    \"u7121\": \"\\u{1F21A}\\uFE0F\",\n    \"u7533\": \"\\u{1F238}\",\n    \"u7981\": \"\\u{1F232}\",\n    \"u7a7a\": \"\\u{1F233}\",\n    \"umbrella\": \"\\u2614\\uFE0F\",\n    \"unamused\": \"\\u{1F612}\",\n    \"underage\": \"\\u{1F51E}\",\n    \"unicorn\": \"\\u{1F984}\",\n    \"unlock\": \"\\u{1F513}\",\n    \"up\": \"\\u{1F199}\",\n    \"upside_down_face\": \"\\u{1F643}\",\n    \"v\": \"\\u270C\\uFE0F\",\n    \"vertical_traffic_light\": \"\\u{1F6A6}\",\n    \"vhs\": \"\\u{1F4FC}\",\n    \"vibration_mode\": \"\\u{1F4F3}\",\n    \"video_camera\": \"\\u{1F4F9}\",\n    \"video_game\": \"\\u{1F3AE}\",\n    \"violin\": \"\\u{1F3BB}\",\n    \"virgo\": \"\\u264D\\uFE0F\",\n    \"volcano\": \"\\u{1F30B}\",\n    \"volleyball\": \"\\u{1F3D0}\",\n    \"vs\": \"\\u{1F19A}\",\n    \"vulcan_salute\": \"\\u{1F596}\",\n    \"walking_man\": \"\\u{1F6B6}\",\n    \"walking_woman\": \"\\u{1F6B6}&zwj;\\u2640\\uFE0F\",\n    \"waning_crescent_moon\": \"\\u{1F318}\",\n    \"waning_gibbous_moon\": \"\\u{1F316}\",\n    \"warning\": \"\\u26A0\\uFE0F\",\n    \"wastebasket\": \"\\u{1F5D1}\",\n    \"watch\": \"\\u231A\\uFE0F\",\n    \"water_buffalo\": \"\\u{1F403}\",\n    \"watermelon\": \"\\u{1F349}\",\n    \"wave\": \"\\u{1F44B}\",\n    \"wavy_dash\": \"\\u3030\\uFE0F\",\n    \"waxing_crescent_moon\": \"\\u{1F312}\",\n    \"wc\": \"\\u{1F6BE}\",\n    \"weary\": \"\\u{1F629}\",\n    \"wedding\": \"\\u{1F492}\",\n    \"weight_lifting_man\": \"\\u{1F3CB}\\uFE0F\",\n    \"weight_lifting_woman\": \"\\u{1F3CB}\\uFE0F&zwj;\\u2640\\uFE0F\",\n    \"whale\": \"\\u{1F433}\",\n    \"whale2\": \"\\u{1F40B}\",\n    \"wheel_of_dharma\": \"\\u2638\\uFE0F\",\n    \"wheelchair\": \"\\u267F\\uFE0F\",\n    \"white_check_mark\": \"\\u2705\",\n    \"white_circle\": \"\\u26AA\\uFE0F\",\n    \"white_flag\": \"\\u{1F3F3}\\uFE0F\",\n    \"white_flower\": \"\\u{1F4AE}\",\n    \"white_large_square\": \"\\u2B1C\\uFE0F\",\n    \"white_medium_small_square\": \"\\u25FD\\uFE0F\",\n    \"white_medium_square\": \"\\u25FB\\uFE0F\",\n    \"white_small_square\": \"\\u25AB\\uFE0F\",\n    \"white_square_button\": \"\\u{1F533}\",\n    \"wilted_flower\": \"\\u{1F940}\",\n    \"wind_chime\": \"\\u{1F390}\",\n    \"wind_face\": \"\\u{1F32C}\",\n    \"wine_glass\": \"\\u{1F377}\",\n    \"wink\": \"\\u{1F609}\",\n    \"wolf\": \"\\u{1F43A}\",\n    \"woman\": \"\\u{1F469}\",\n    \"woman_artist\": \"\\u{1F469}&zwj;\\u{1F3A8}\",\n    \"woman_astronaut\": \"\\u{1F469}&zwj;\\u{1F680}\",\n    \"woman_cartwheeling\": \"\\u{1F938}&zwj;\\u2640\\uFE0F\",\n    \"woman_cook\": \"\\u{1F469}&zwj;\\u{1F373}\",\n    \"woman_facepalming\": \"\\u{1F926}&zwj;\\u2640\\uFE0F\",\n    \"woman_factory_worker\": \"\\u{1F469}&zwj;\\u{1F3ED}\",\n    \"woman_farmer\": \"\\u{1F469}&zwj;\\u{1F33E}\",\n    \"woman_firefighter\": \"\\u{1F469}&zwj;\\u{1F692}\",\n    \"woman_health_worker\": \"\\u{1F469}&zwj;\\u2695\\uFE0F\",\n    \"woman_judge\": \"\\u{1F469}&zwj;\\u2696\\uFE0F\",\n    \"woman_juggling\": \"\\u{1F939}&zwj;\\u2640\\uFE0F\",\n    \"woman_mechanic\": \"\\u{1F469}&zwj;\\u{1F527}\",\n    \"woman_office_worker\": \"\\u{1F469}&zwj;\\u{1F4BC}\",\n    \"woman_pilot\": \"\\u{1F469}&zwj;\\u2708\\uFE0F\",\n    \"woman_playing_handball\": \"\\u{1F93E}&zwj;\\u2640\\uFE0F\",\n    \"woman_playing_water_polo\": \"\\u{1F93D}&zwj;\\u2640\\uFE0F\",\n    \"woman_scientist\": \"\\u{1F469}&zwj;\\u{1F52C}\",\n    \"woman_shrugging\": \"\\u{1F937}&zwj;\\u2640\\uFE0F\",\n    \"woman_singer\": \"\\u{1F469}&zwj;\\u{1F3A4}\",\n    \"woman_student\": \"\\u{1F469}&zwj;\\u{1F393}\",\n    \"woman_teacher\": \"\\u{1F469}&zwj;\\u{1F3EB}\",\n    \"woman_technologist\": \"\\u{1F469}&zwj;\\u{1F4BB}\",\n    \"woman_with_turban\": \"\\u{1F473}&zwj;\\u2640\\uFE0F\",\n    \"womans_clothes\": \"\\u{1F45A}\",\n    \"womans_hat\": \"\\u{1F452}\",\n    \"women_wrestling\": \"\\u{1F93C}&zwj;\\u2640\\uFE0F\",\n    \"womens\": \"\\u{1F6BA}\",\n    \"world_map\": \"\\u{1F5FA}\",\n    \"worried\": \"\\u{1F61F}\",\n    \"wrench\": \"\\u{1F527}\",\n    \"writing_hand\": \"\\u270D\\uFE0F\",\n    \"x\": \"\\u274C\",\n    \"yellow_heart\": \"\\u{1F49B}\",\n    \"yen\": \"\\u{1F4B4}\",\n    \"yin_yang\": \"\\u262F\\uFE0F\",\n    \"yum\": \"\\u{1F60B}\",\n    \"zap\": \"\\u26A1\\uFE0F\",\n    \"zipper_mouth_face\": \"\\u{1F910}\",\n    \"zzz\": \"\\u{1F4A4}\",\n    \"octocat\": '<img alt=\":octocat:\" height=\"20\" width=\"20\" align=\"absmiddle\" src=\"https://assets-cdn.github.com/images/icons/emoji/octocat.png\">',\n    \"showdown\": `<span style=\"font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;\">S</span>`\n  };\n  showdown.Converter = function(converterOptions) {\n    \"use strict\";\n    var options = {}, langExtensions = [], outputModifiers = [], listeners = {}, setConvFlavor = setFlavor, metadata = {\n      parsed: {},\n      raw: \"\",\n      format: \"\"\n    };\n    _constructor();\n    function _constructor() {\n      converterOptions = converterOptions || {};\n      for (var gOpt in globalOptions) {\n        if (globalOptions.hasOwnProperty(gOpt)) {\n          options[gOpt] = globalOptions[gOpt];\n        }\n      }\n      if (typeof converterOptions === \"object\") {\n        for (var opt in converterOptions) {\n          if (converterOptions.hasOwnProperty(opt)) {\n            options[opt] = converterOptions[opt];\n          }\n        }\n      } else {\n        throw Error(\"Converter expects the passed parameter to be an object, but \" + typeof converterOptions + \" was passed instead.\");\n      }\n      if (options.extensions) {\n        showdown.helper.forEach(options.extensions, _parseExtension);\n      }\n    }\n    function _parseExtension(ext, name) {\n      name = name || null;\n      if (showdown.helper.isString(ext)) {\n        ext = showdown.helper.stdExtName(ext);\n        name = ext;\n        if (showdown.extensions[ext]) {\n          console.warn(\"DEPRECATION WARNING: \" + ext + \" is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!\");\n          legacyExtensionLoading(showdown.extensions[ext], ext);\n          return;\n        } else if (!showdown.helper.isUndefined(extensions[ext])) {\n          ext = extensions[ext];\n        } else {\n          throw Error('Extension \"' + ext + '\" could not be loaded. It was either not found or is not a valid extension.');\n        }\n      }\n      if (typeof ext === \"function\") {\n        ext = ext();\n      }\n      if (!showdown.helper.isArray(ext)) {\n        ext = [ext];\n      }\n      var validExt = validate(ext, name);\n      if (!validExt.valid) {\n        throw Error(validExt.error);\n      }\n      for (var i = 0; i < ext.length; ++i) {\n        switch (ext[i].type) {\n          case \"lang\":\n            langExtensions.push(ext[i]);\n            break;\n          case \"output\":\n            outputModifiers.push(ext[i]);\n            break;\n        }\n        if (ext[i].hasOwnProperty(\"listeners\")) {\n          for (var ln in ext[i].listeners) {\n            if (ext[i].listeners.hasOwnProperty(ln)) {\n              listen(ln, ext[i].listeners[ln]);\n            }\n          }\n        }\n      }\n    }\n    function legacyExtensionLoading(ext, name) {\n      if (typeof ext === \"function\") {\n        ext = ext(new showdown.Converter());\n      }\n      if (!showdown.helper.isArray(ext)) {\n        ext = [ext];\n      }\n      var valid = validate(ext, name);\n      if (!valid.valid) {\n        throw Error(valid.error);\n      }\n      for (var i = 0; i < ext.length; ++i) {\n        switch (ext[i].type) {\n          case \"lang\":\n            langExtensions.push(ext[i]);\n            break;\n          case \"output\":\n            outputModifiers.push(ext[i]);\n            break;\n          default:\n            throw Error(\"Extension loader error: Type unrecognized!!!\");\n        }\n      }\n    }\n    function listen(name, callback) {\n      if (!showdown.helper.isString(name)) {\n        throw Error(\"Invalid argument in converter.listen() method: name must be a string, but \" + typeof name + \" given\");\n      }\n      if (typeof callback !== \"function\") {\n        throw Error(\"Invalid argument in converter.listen() method: callback must be a function, but \" + typeof callback + \" given\");\n      }\n      if (!listeners.hasOwnProperty(name)) {\n        listeners[name] = [];\n      }\n      listeners[name].push(callback);\n    }\n    function rTrimInputText(text) {\n      var rsp = text.match(/^\\s*/)[0].length, rgx = new RegExp(\"^\\\\s{0,\" + rsp + \"}\", \"gm\");\n      return text.replace(rgx, \"\");\n    }\n    this._dispatch = function dispatch(evtName, text, options2, globals) {\n      if (listeners.hasOwnProperty(evtName)) {\n        for (var ei = 0; ei < listeners[evtName].length; ++ei) {\n          var nText = listeners[evtName][ei](evtName, text, this, options2, globals);\n          if (nText && typeof nText !== \"undefined\") {\n            text = nText;\n          }\n        }\n      }\n      return text;\n    };\n    this.listen = function(name, callback) {\n      listen(name, callback);\n      return this;\n    };\n    this.makeHtml = function(text) {\n      if (!text) {\n        return text;\n      }\n      var globals = {\n        gHtmlBlocks: [],\n        gHtmlMdBlocks: [],\n        gHtmlSpans: [],\n        gUrls: {},\n        gTitles: {},\n        gDimensions: {},\n        gListLevel: 0,\n        hashLinkCounts: {},\n        langExtensions,\n        outputModifiers,\n        converter: this,\n        ghCodeBlocks: [],\n        metadata: {\n          parsed: {},\n          raw: \"\",\n          format: \"\"\n        }\n      };\n      text = text.replace(//g, \"\\xA8T\");\n      text = text.replace(/\\$/g, \"\\xA8D\");\n      text = text.replace(/\\r\\n/g, \"\\n\");\n      text = text.replace(/\\r/g, \"\\n\");\n      text = text.replace(/\\u00A0/g, \"&nbsp;\");\n      if (options.smartIndentationFix) {\n        text = rTrimInputText(text);\n      }\n      text = \"\\n\\n\" + text + \"\\n\\n\";\n      text = showdown.subParser(\"detab\")(text, options, globals);\n      text = text.replace(/^[ \\t]+$/mg, \"\");\n      showdown.helper.forEach(langExtensions, function(ext) {\n        text = showdown.subParser(\"runExtension\")(ext, text, options, globals);\n      });\n      text = showdown.subParser(\"metadata\")(text, options, globals);\n      text = showdown.subParser(\"hashPreCodeTags\")(text, options, globals);\n      text = showdown.subParser(\"githubCodeBlocks\")(text, options, globals);\n      text = showdown.subParser(\"hashHTMLBlocks\")(text, options, globals);\n      text = showdown.subParser(\"hashCodeTags\")(text, options, globals);\n      text = showdown.subParser(\"stripLinkDefinitions\")(text, options, globals);\n      text = showdown.subParser(\"blockGamut\")(text, options, globals);\n      text = showdown.subParser(\"unhashHTMLSpans\")(text, options, globals);\n      text = showdown.subParser(\"unescapeSpecialChars\")(text, options, globals);\n      text = text.replace(/D/g, \"$$\");\n      text = text.replace(/T/g, \"\\xA8\");\n      text = showdown.subParser(\"completeHTMLDocument\")(text, options, globals);\n      showdown.helper.forEach(outputModifiers, function(ext) {\n        text = showdown.subParser(\"runExtension\")(ext, text, options, globals);\n      });\n      metadata = globals.metadata;\n      return text;\n    };\n    this.makeMarkdown = this.makeMd = function(src, HTMLParser) {\n      src = src.replace(/\\r\\n/g, \"\\n\");\n      src = src.replace(/\\r/g, \"\\n\");\n      src = src.replace(/>[ \\t]+</, \">\\xA8NBSP;<\");\n      if (!HTMLParser) {\n        if (window && window.document) {\n          HTMLParser = window.document;\n        } else {\n          throw new Error(\"HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM\");\n        }\n      }\n      var doc = HTMLParser.createElement(\"div\");\n      doc.innerHTML = src;\n      var globals = {\n        preList: substitutePreCodeTags(doc)\n      };\n      clean(doc);\n      var nodes = doc.childNodes, mdDoc = \"\";\n      for (var i = 0; i < nodes.length; i++) {\n        mdDoc += showdown.subParser(\"makeMarkdown.node\")(nodes[i], globals);\n      }\n      function clean(node) {\n        for (var n = 0; n < node.childNodes.length; ++n) {\n          var child = node.childNodes[n];\n          if (child.nodeType === 3) {\n            if (!/\\S/.test(child.nodeValue) && !/^[ ]+$/.test(child.nodeValue)) {\n              node.removeChild(child);\n              --n;\n            } else {\n              child.nodeValue = child.nodeValue.split(\"\\n\").join(\" \");\n              child.nodeValue = child.nodeValue.replace(/(\\s)+/g, \"$1\");\n            }\n          } else if (child.nodeType === 1) {\n            clean(child);\n          }\n        }\n      }\n      function substitutePreCodeTags(doc2) {\n        var pres = doc2.querySelectorAll(\"pre\"), presPH = [];\n        for (var i2 = 0; i2 < pres.length; ++i2) {\n          if (pres[i2].childElementCount === 1 && pres[i2].firstChild.tagName.toLowerCase() === \"code\") {\n            var content = pres[i2].firstChild.innerHTML.trim(), language = pres[i2].firstChild.getAttribute(\"data-language\") || \"\";\n            if (language === \"\") {\n              var classes = pres[i2].firstChild.className.split(\" \");\n              for (var c = 0; c < classes.length; ++c) {\n                var matches = classes[c].match(/^language-(.+)$/);\n                if (matches !== null) {\n                  language = matches[1];\n                  break;\n                }\n              }\n            }\n            content = showdown.helper.unescapeHTMLEntities(content);\n            presPH.push(content);\n            pres[i2].outerHTML = '<precode language=\"' + language + '\" precodenum=\"' + i2.toString() + '\"></precode>';\n          } else {\n            presPH.push(pres[i2].innerHTML);\n            pres[i2].innerHTML = \"\";\n            pres[i2].setAttribute(\"prenum\", i2.toString());\n          }\n        }\n        return presPH;\n      }\n      return mdDoc;\n    };\n    this.setOption = function(key, value) {\n      options[key] = value;\n    };\n    this.getOption = function(key) {\n      return options[key];\n    };\n    this.getOptions = function() {\n      return options;\n    };\n    this.addExtension = function(extension, name) {\n      name = name || null;\n      _parseExtension(extension, name);\n    };\n    this.useExtension = function(extensionName) {\n      _parseExtension(extensionName);\n    };\n    this.setFlavor = function(name) {\n      if (!flavor.hasOwnProperty(name)) {\n        throw Error(name + \" flavor was not found\");\n      }\n      var preset = flavor[name];\n      setConvFlavor = name;\n      for (var option in preset) {\n        if (preset.hasOwnProperty(option)) {\n          options[option] = preset[option];\n        }\n      }\n    };\n    this.getFlavor = function() {\n      return setConvFlavor;\n    };\n    this.removeExtension = function(extension) {\n      if (!showdown.helper.isArray(extension)) {\n        extension = [extension];\n      }\n      for (var a = 0; a < extension.length; ++a) {\n        var ext = extension[a];\n        for (var i = 0; i < langExtensions.length; ++i) {\n          if (langExtensions[i] === ext) {\n            langExtensions.splice(i, 1);\n          }\n        }\n        for (var ii = 0; ii < outputModifiers.length; ++ii) {\n          if (outputModifiers[ii] === ext) {\n            outputModifiers.splice(ii, 1);\n          }\n        }\n      }\n    };\n    this.getAllExtensions = function() {\n      return {\n        language: langExtensions,\n        output: outputModifiers\n      };\n    };\n    this.getMetadata = function(raw) {\n      if (raw) {\n        return metadata.raw;\n      } else {\n        return metadata.parsed;\n      }\n    };\n    this.getMetadataFormat = function() {\n      return metadata.format;\n    };\n    this._setMetadataPair = function(key, value) {\n      metadata.parsed[key] = value;\n    };\n    this._setMetadataFormat = function(format) {\n      metadata.format = format;\n    };\n    this._setMetadataRaw = function(raw) {\n      metadata.raw = raw;\n    };\n  };\n  showdown.subParser(\"anchors\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"anchors.before\", text, options, globals);\n    var writeAnchorTag = function(wholeMatch, linkText, linkId, url, m5, m6, title) {\n      if (showdown.helper.isUndefined(title)) {\n        title = \"\";\n      }\n      linkId = linkId.toLowerCase();\n      if (wholeMatch.search(/\\(<?\\s*>? ?(['\"].*['\"])?\\)$/m) > -1) {\n        url = \"\";\n      } else if (!url) {\n        if (!linkId) {\n          linkId = linkText.toLowerCase().replace(/ ?\\n/g, \" \");\n        }\n        url = \"#\" + linkId;\n        if (!showdown.helper.isUndefined(globals.gUrls[linkId])) {\n          url = globals.gUrls[linkId];\n          if (!showdown.helper.isUndefined(globals.gTitles[linkId])) {\n            title = globals.gTitles[linkId];\n          }\n        } else {\n          return wholeMatch;\n        }\n      }\n      url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n      var result = '<a href=\"' + url + '\"';\n      if (title !== \"\" && title !== null) {\n        title = title.replace(/\"/g, \"&quot;\");\n        title = title.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n        result += ' title=\"' + title + '\"';\n      }\n      if (options.openLinksInNewWindow && !/^#/.test(url)) {\n        result += ' rel=\"noopener noreferrer\" target=\"\\xA8E95Eblank\"';\n      }\n      result += \">\" + linkText + \"</a>\";\n      return result;\n    };\n    text = text.replace(/\\[((?:\\[[^\\]]*]|[^\\[\\]])*)] ?(?:\\n *)?\\[(.*?)]()()()()/g, writeAnchorTag);\n    text = text.replace(\n      /\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]()[ \\t]*\\([ \\t]?<([^>]*)>(?:[ \\t]*(([\"'])([^\"]*?)\\5))?[ \\t]?\\)/g,\n      writeAnchorTag\n    );\n    text = text.replace(\n      /\\[((?:\\[[^\\]]*]|[^\\[\\]])*)]()[ \\t]*\\([ \\t]?<?([\\S]+?(?:\\([\\S]*?\\)[\\S]*?)?)>?(?:[ \\t]*(([\"'])([^\"]*?)\\5))?[ \\t]?\\)/g,\n      writeAnchorTag\n    );\n    text = text.replace(/\\[([^\\[\\]]+)]()()()()()/g, writeAnchorTag);\n    if (options.ghMentions) {\n      text = text.replace(/(^|\\s)(\\\\)?(@([a-z\\d]+(?:[a-z\\d.-]+?[a-z\\d]+)*))/gmi, function(wm, st, escape, mentions, username) {\n        if (escape === \"\\\\\") {\n          return st + mentions;\n        }\n        if (!showdown.helper.isString(options.ghMentionsLink)) {\n          throw new Error(\"ghMentionsLink option must be a string\");\n        }\n        var lnk = options.ghMentionsLink.replace(/\\{u}/g, username), target = \"\";\n        if (options.openLinksInNewWindow) {\n          target = ' rel=\"noopener noreferrer\" target=\"\\xA8E95Eblank\"';\n        }\n        return st + '<a href=\"' + lnk + '\"' + target + \">\" + mentions + \"</a>\";\n      });\n    }\n    text = globals.converter._dispatch(\"anchors.after\", text, options, globals);\n    return text;\n  });\n  var simpleURLRegex = /([*~_]+|\\b)(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+?\\.[^'\">\\s]+?)()(\\1)?(?=\\s|$)(?![\"<>])/gi, simpleURLRegex2 = /([*~_]+|\\b)(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+\\.[^'\">\\s]+?)([.!?,()\\[\\]])?(\\1)?(?=\\s|$)(?![\"<>])/gi, delimUrlRegex = /()<(((https?|ftp|dict):\\/\\/|www\\.)[^'\">\\s]+)()>()/gi, simpleMailRegex = /(^|\\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)(?=$|\\s)/gmi, delimMailRegex = /<()(?:mailto:)?([-.\\w]+@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi, replaceLink = function(options) {\n    \"use strict\";\n    return function(wm, leadingMagicChars, link, m2, m3, trailingPunctuation, trailingMagicChars) {\n      link = link.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n      var lnkTxt = link, append = \"\", target = \"\", lmc = leadingMagicChars || \"\", tmc = trailingMagicChars || \"\";\n      if (/^www\\./i.test(link)) {\n        link = link.replace(/^www\\./i, \"http://www.\");\n      }\n      if (options.excludeTrailingPunctuationFromURLs && trailingPunctuation) {\n        append = trailingPunctuation;\n      }\n      if (options.openLinksInNewWindow) {\n        target = ' rel=\"noopener noreferrer\" target=\"\\xA8E95Eblank\"';\n      }\n      return lmc + '<a href=\"' + link + '\"' + target + \">\" + lnkTxt + \"</a>\" + append + tmc;\n    };\n  }, replaceMail = function(options, globals) {\n    \"use strict\";\n    return function(wholeMatch, b, mail) {\n      var href = \"mailto:\";\n      b = b || \"\";\n      mail = showdown.subParser(\"unescapeSpecialChars\")(mail, options, globals);\n      if (options.encodeEmails) {\n        href = showdown.helper.encodeEmailAddress(href + mail);\n        mail = showdown.helper.encodeEmailAddress(mail);\n      } else {\n        href = href + mail;\n      }\n      return b + '<a href=\"' + href + '\">' + mail + \"</a>\";\n    };\n  };\n  showdown.subParser(\"autoLinks\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"autoLinks.before\", text, options, globals);\n    text = text.replace(delimUrlRegex, replaceLink(options));\n    text = text.replace(delimMailRegex, replaceMail(options, globals));\n    text = globals.converter._dispatch(\"autoLinks.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"simplifiedAutoLinks\", function(text, options, globals) {\n    \"use strict\";\n    if (!options.simplifiedAutoLink) {\n      return text;\n    }\n    text = globals.converter._dispatch(\"simplifiedAutoLinks.before\", text, options, globals);\n    if (options.excludeTrailingPunctuationFromURLs) {\n      text = text.replace(simpleURLRegex2, replaceLink(options));\n    } else {\n      text = text.replace(simpleURLRegex, replaceLink(options));\n    }\n    text = text.replace(simpleMailRegex, replaceMail(options, globals));\n    text = globals.converter._dispatch(\"simplifiedAutoLinks.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"blockGamut\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"blockGamut.before\", text, options, globals);\n    text = showdown.subParser(\"blockQuotes\")(text, options, globals);\n    text = showdown.subParser(\"headers\")(text, options, globals);\n    text = showdown.subParser(\"horizontalRule\")(text, options, globals);\n    text = showdown.subParser(\"lists\")(text, options, globals);\n    text = showdown.subParser(\"codeBlocks\")(text, options, globals);\n    text = showdown.subParser(\"tables\")(text, options, globals);\n    text = showdown.subParser(\"hashHTMLBlocks\")(text, options, globals);\n    text = showdown.subParser(\"paragraphs\")(text, options, globals);\n    text = globals.converter._dispatch(\"blockGamut.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"blockQuotes\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"blockQuotes.before\", text, options, globals);\n    text = text + \"\\n\\n\";\n    var rgx = /(^ {0,3}>[ \\t]?.+\\n(.+\\n)*\\n*)+/gm;\n    if (options.splitAdjacentBlockquotes) {\n      rgx = /^ {0,3}>[\\s\\S]*?(?:\\n\\n)/gm;\n    }\n    text = text.replace(rgx, function(bq) {\n      bq = bq.replace(/^[ \\t]*>[ \\t]?/gm, \"\");\n      bq = bq.replace(/0/g, \"\");\n      bq = bq.replace(/^[ \\t]+$/gm, \"\");\n      bq = showdown.subParser(\"githubCodeBlocks\")(bq, options, globals);\n      bq = showdown.subParser(\"blockGamut\")(bq, options, globals);\n      bq = bq.replace(/(^|\\n)/g, \"$1  \");\n      bq = bq.replace(/(\\s*<pre>[^\\r]+?<\\/pre>)/gm, function(wholeMatch, m1) {\n        var pre = m1;\n        pre = pre.replace(/^  /mg, \"\\xA80\");\n        pre = pre.replace(/0/g, \"\");\n        return pre;\n      });\n      return showdown.subParser(\"hashBlock\")(\"<blockquote>\\n\" + bq + \"\\n</blockquote>\", options, globals);\n    });\n    text = globals.converter._dispatch(\"blockQuotes.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"codeBlocks\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"codeBlocks.before\", text, options, globals);\n    text += \"\\xA80\";\n    var pattern = /(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=0))/g;\n    text = text.replace(pattern, function(wholeMatch, m1, m2) {\n      var codeblock = m1, nextChar = m2, end = \"\\n\";\n      codeblock = showdown.subParser(\"outdent\")(codeblock, options, globals);\n      codeblock = showdown.subParser(\"encodeCode\")(codeblock, options, globals);\n      codeblock = showdown.subParser(\"detab\")(codeblock, options, globals);\n      codeblock = codeblock.replace(/^\\n+/g, \"\");\n      codeblock = codeblock.replace(/\\n+$/g, \"\");\n      if (options.omitExtraWLInCodeBlocks) {\n        end = \"\";\n      }\n      codeblock = \"<pre><code>\" + codeblock + end + \"</code></pre>\";\n      return showdown.subParser(\"hashBlock\")(codeblock, options, globals) + nextChar;\n    });\n    text = text.replace(/0/, \"\");\n    text = globals.converter._dispatch(\"codeBlocks.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"codeSpans\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"codeSpans.before\", text, options, globals);\n    if (typeof text === \"undefined\") {\n      text = \"\";\n    }\n    text = text.replace(\n      /(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\n      function(wholeMatch, m1, m2, m3) {\n        var c = m3;\n        c = c.replace(/^([ \\t]*)/g, \"\");\n        c = c.replace(/[ \\t]*$/g, \"\");\n        c = showdown.subParser(\"encodeCode\")(c, options, globals);\n        c = m1 + \"<code>\" + c + \"</code>\";\n        c = showdown.subParser(\"hashHTMLSpans\")(c, options, globals);\n        return c;\n      }\n    );\n    text = globals.converter._dispatch(\"codeSpans.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"completeHTMLDocument\", function(text, options, globals) {\n    \"use strict\";\n    if (!options.completeHTMLDocument) {\n      return text;\n    }\n    text = globals.converter._dispatch(\"completeHTMLDocument.before\", text, options, globals);\n    var doctype = \"html\", doctypeParsed = \"<!DOCTYPE HTML>\\n\", title = \"\", charset = '<meta charset=\"utf-8\">\\n', lang = \"\", metadata = \"\";\n    if (typeof globals.metadata.parsed.doctype !== \"undefined\") {\n      doctypeParsed = \"<!DOCTYPE \" + globals.metadata.parsed.doctype + \">\\n\";\n      doctype = globals.metadata.parsed.doctype.toString().toLowerCase();\n      if (doctype === \"html\" || doctype === \"html5\") {\n        charset = '<meta charset=\"utf-8\">';\n      }\n    }\n    for (var meta in globals.metadata.parsed) {\n      if (globals.metadata.parsed.hasOwnProperty(meta)) {\n        switch (meta.toLowerCase()) {\n          case \"doctype\":\n            break;\n          case \"title\":\n            title = \"<title>\" + globals.metadata.parsed.title + \"</title>\\n\";\n            break;\n          case \"charset\":\n            if (doctype === \"html\" || doctype === \"html5\") {\n              charset = '<meta charset=\"' + globals.metadata.parsed.charset + '\">\\n';\n            } else {\n              charset = '<meta name=\"charset\" content=\"' + globals.metadata.parsed.charset + '\">\\n';\n            }\n            break;\n          case \"language\":\n          case \"lang\":\n            lang = ' lang=\"' + globals.metadata.parsed[meta] + '\"';\n            metadata += '<meta name=\"' + meta + '\" content=\"' + globals.metadata.parsed[meta] + '\">\\n';\n            break;\n          default:\n            metadata += '<meta name=\"' + meta + '\" content=\"' + globals.metadata.parsed[meta] + '\">\\n';\n        }\n      }\n    }\n    text = doctypeParsed + \"<html\" + lang + \">\\n<head>\\n\" + title + charset + metadata + \"</head>\\n<body>\\n\" + text.trim() + \"\\n</body>\\n</html>\";\n    text = globals.converter._dispatch(\"completeHTMLDocument.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"detab\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"detab.before\", text, options, globals);\n    text = text.replace(/\\t(?=\\t)/g, \"    \");\n    text = text.replace(/\\t/g, \"\\xA8A\\xA8B\");\n    text = text.replace(/B(.+?)A/g, function(wholeMatch, m1) {\n      var leadingText = m1, numSpaces = 4 - leadingText.length % 4;\n      for (var i = 0; i < numSpaces; i++) {\n        leadingText += \" \";\n      }\n      return leadingText;\n    });\n    text = text.replace(/A/g, \"    \");\n    text = text.replace(/B/g, \"\");\n    text = globals.converter._dispatch(\"detab.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"ellipsis\", function(text, options, globals) {\n    \"use strict\";\n    if (!options.ellipsis) {\n      return text;\n    }\n    text = globals.converter._dispatch(\"ellipsis.before\", text, options, globals);\n    text = text.replace(/\\.\\.\\./g, \"\\u2026\");\n    text = globals.converter._dispatch(\"ellipsis.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"emoji\", function(text, options, globals) {\n    \"use strict\";\n    if (!options.emoji) {\n      return text;\n    }\n    text = globals.converter._dispatch(\"emoji.before\", text, options, globals);\n    var emojiRgx = /:([\\S]+?):/g;\n    text = text.replace(emojiRgx, function(wm, emojiCode) {\n      if (showdown.helper.emojis.hasOwnProperty(emojiCode)) {\n        return showdown.helper.emojis[emojiCode];\n      }\n      return wm;\n    });\n    text = globals.converter._dispatch(\"emoji.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"encodeAmpsAndAngles\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"encodeAmpsAndAngles.before\", text, options, globals);\n    text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g, \"&amp;\");\n    text = text.replace(/<(?![a-z\\/?$!])/gi, \"&lt;\");\n    text = text.replace(/</g, \"&lt;\");\n    text = text.replace(/>/g, \"&gt;\");\n    text = globals.converter._dispatch(\"encodeAmpsAndAngles.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"encodeBackslashEscapes\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"encodeBackslashEscapes.before\", text, options, globals);\n    text = text.replace(/\\\\(\\\\)/g, showdown.helper.escapeCharactersCallback);\n    text = text.replace(/\\\\([`*_{}\\[\\]()>#+.!~=|:-])/g, showdown.helper.escapeCharactersCallback);\n    text = globals.converter._dispatch(\"encodeBackslashEscapes.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"encodeCode\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"encodeCode.before\", text, options, globals);\n    text = text.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/([*_{}\\[\\]\\\\=~-])/g, showdown.helper.escapeCharactersCallback);\n    text = globals.converter._dispatch(\"encodeCode.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"escapeSpecialCharsWithinTagAttributes\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"escapeSpecialCharsWithinTagAttributes.before\", text, options, globals);\n    var tags = /<\\/?[a-z\\d_:-]+(?:[\\s]+[\\s\\S]+?)?>/gi, comments = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi;\n    text = text.replace(tags, function(wholeMatch) {\n      return wholeMatch.replace(/(.)<\\/?code>(?=.)/g, \"$1`\").replace(/([\\\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);\n    });\n    text = text.replace(comments, function(wholeMatch) {\n      return wholeMatch.replace(/([\\\\`*_~=|])/g, showdown.helper.escapeCharactersCallback);\n    });\n    text = globals.converter._dispatch(\"escapeSpecialCharsWithinTagAttributes.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"githubCodeBlocks\", function(text, options, globals) {\n    \"use strict\";\n    if (!options.ghCodeBlocks) {\n      return text;\n    }\n    text = globals.converter._dispatch(\"githubCodeBlocks.before\", text, options, globals);\n    text += \"\\xA80\";\n    text = text.replace(/(?:^|\\n)(?: {0,3})(```+|~~~+)(?: *)([^\\s`~]*)\\n([\\s\\S]*?)\\n(?: {0,3})\\1/g, function(wholeMatch, delim, language, codeblock) {\n      var end = options.omitExtraWLInCodeBlocks ? \"\" : \"\\n\";\n      codeblock = showdown.subParser(\"encodeCode\")(codeblock, options, globals);\n      codeblock = showdown.subParser(\"detab\")(codeblock, options, globals);\n      codeblock = codeblock.replace(/^\\n+/g, \"\");\n      codeblock = codeblock.replace(/\\n+$/g, \"\");\n      codeblock = \"<pre><code\" + (language ? ' class=\"' + language + \" language-\" + language + '\"' : \"\") + \">\" + codeblock + end + \"</code></pre>\";\n      codeblock = showdown.subParser(\"hashBlock\")(codeblock, options, globals);\n      return \"\\n\\n\\xA8G\" + (globals.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + \"G\\n\\n\";\n    });\n    text = text.replace(/0/, \"\");\n    return globals.converter._dispatch(\"githubCodeBlocks.after\", text, options, globals);\n  });\n  showdown.subParser(\"hashBlock\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"hashBlock.before\", text, options, globals);\n    text = text.replace(/(^\\n+|\\n+$)/g, \"\");\n    text = \"\\n\\n\\xA8K\" + (globals.gHtmlBlocks.push(text) - 1) + \"K\\n\\n\";\n    text = globals.converter._dispatch(\"hashBlock.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"hashCodeTags\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"hashCodeTags.before\", text, options, globals);\n    var repFunc = function(wholeMatch, match, left, right) {\n      var codeblock = left + showdown.subParser(\"encodeCode\")(match, options, globals) + right;\n      return \"\\xA8C\" + (globals.gHtmlSpans.push(codeblock) - 1) + \"C\";\n    };\n    text = showdown.helper.replaceRecursiveRegExp(text, repFunc, \"<code\\\\b[^>]*>\", \"</code>\", \"gim\");\n    text = globals.converter._dispatch(\"hashCodeTags.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"hashElement\", function(text, options, globals) {\n    \"use strict\";\n    return function(wholeMatch, m1) {\n      var blockText = m1;\n      blockText = blockText.replace(/\\n\\n/g, \"\\n\");\n      blockText = blockText.replace(/^\\n/, \"\");\n      blockText = blockText.replace(/\\n+$/g, \"\");\n      blockText = \"\\n\\n\\xA8K\" + (globals.gHtmlBlocks.push(blockText) - 1) + \"K\\n\\n\";\n      return blockText;\n    };\n  });\n  showdown.subParser(\"hashHTMLBlocks\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"hashHTMLBlocks.before\", text, options, globals);\n    var blockTags = [\n      \"pre\",\n      \"div\",\n      \"h1\",\n      \"h2\",\n      \"h3\",\n      \"h4\",\n      \"h5\",\n      \"h6\",\n      \"blockquote\",\n      \"table\",\n      \"dl\",\n      \"ol\",\n      \"ul\",\n      \"script\",\n      \"noscript\",\n      \"form\",\n      \"fieldset\",\n      \"iframe\",\n      \"math\",\n      \"style\",\n      \"section\",\n      \"header\",\n      \"footer\",\n      \"nav\",\n      \"article\",\n      \"aside\",\n      \"address\",\n      \"audio\",\n      \"canvas\",\n      \"figure\",\n      \"hgroup\",\n      \"output\",\n      \"video\",\n      \"p\"\n    ], repFunc = function(wholeMatch, match, left, right) {\n      var txt = wholeMatch;\n      if (left.search(/\\bmarkdown\\b/) !== -1) {\n        txt = left + globals.converter.makeHtml(match) + right;\n      }\n      return \"\\n\\n\\xA8K\" + (globals.gHtmlBlocks.push(txt) - 1) + \"K\\n\\n\";\n    };\n    if (options.backslashEscapesHTMLTags) {\n      text = text.replace(/\\\\<(\\/?[^>]+?)>/g, function(wm, inside) {\n        return \"&lt;\" + inside + \"&gt;\";\n      });\n    }\n    for (var i = 0; i < blockTags.length; ++i) {\n      var opTagPos, rgx1 = new RegExp(\"^ {0,3}(<\" + blockTags[i] + \"\\\\b[^>]*>)\", \"im\"), patLeft = \"<\" + blockTags[i] + \"\\\\b[^>]*>\", patRight = \"</\" + blockTags[i] + \">\";\n      while ((opTagPos = showdown.helper.regexIndexOf(text, rgx1)) !== -1) {\n        var subTexts = showdown.helper.splitAtIndex(text, opTagPos), newSubText1 = showdown.helper.replaceRecursiveRegExp(subTexts[1], repFunc, patLeft, patRight, \"im\");\n        if (newSubText1 === subTexts[1]) {\n          break;\n        }\n        text = subTexts[0].concat(newSubText1);\n      }\n    }\n    text = text.replace(\n      /(\\n {0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,\n      showdown.subParser(\"hashElement\")(text, options, globals)\n    );\n    text = showdown.helper.replaceRecursiveRegExp(text, function(txt) {\n      return \"\\n\\n\\xA8K\" + (globals.gHtmlBlocks.push(txt) - 1) + \"K\\n\\n\";\n    }, \"^ {0,3}<!--\", \"-->\", \"gm\");\n    text = text.replace(\n      /(?:\\n\\n)( {0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,\n      showdown.subParser(\"hashElement\")(text, options, globals)\n    );\n    text = globals.converter._dispatch(\"hashHTMLBlocks.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"hashHTMLSpans\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"hashHTMLSpans.before\", text, options, globals);\n    function hashHTMLSpan(html) {\n      return \"\\xA8C\" + (globals.gHtmlSpans.push(html) - 1) + \"C\";\n    }\n    text = text.replace(/<[^>]+?\\/>/gi, function(wm) {\n      return hashHTMLSpan(wm);\n    });\n    text = text.replace(/<([^>]+?)>[\\s\\S]*?<\\/\\1>/g, function(wm) {\n      return hashHTMLSpan(wm);\n    });\n    text = text.replace(/<([^>]+?)\\s[^>]+?>[\\s\\S]*?<\\/\\1>/g, function(wm) {\n      return hashHTMLSpan(wm);\n    });\n    text = text.replace(/<[^>]+?>/gi, function(wm) {\n      return hashHTMLSpan(wm);\n    });\n    text = globals.converter._dispatch(\"hashHTMLSpans.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"unhashHTMLSpans\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"unhashHTMLSpans.before\", text, options, globals);\n    for (var i = 0; i < globals.gHtmlSpans.length; ++i) {\n      var repText = globals.gHtmlSpans[i], limit = 0;\n      while (/C(\\d+)C/.test(repText)) {\n        var num = RegExp.$1;\n        repText = repText.replace(\"\\xA8C\" + num + \"C\", globals.gHtmlSpans[num]);\n        if (limit === 10) {\n          console.error(\"maximum nesting of 10 spans reached!!!\");\n          break;\n        }\n        ++limit;\n      }\n      text = text.replace(\"\\xA8C\" + i + \"C\", repText);\n    }\n    text = globals.converter._dispatch(\"unhashHTMLSpans.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"hashPreCodeTags\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"hashPreCodeTags.before\", text, options, globals);\n    var repFunc = function(wholeMatch, match, left, right) {\n      var codeblock = left + showdown.subParser(\"encodeCode\")(match, options, globals) + right;\n      return \"\\n\\n\\xA8G\" + (globals.ghCodeBlocks.push({ text: wholeMatch, codeblock }) - 1) + \"G\\n\\n\";\n    };\n    text = showdown.helper.replaceRecursiveRegExp(text, repFunc, \"^ {0,3}<pre\\\\b[^>]*>\\\\s*<code\\\\b[^>]*>\", \"^ {0,3}</code>\\\\s*</pre>\", \"gim\");\n    text = globals.converter._dispatch(\"hashPreCodeTags.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"headers\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"headers.before\", text, options, globals);\n    var headerLevelStart = isNaN(parseInt(options.headerLevelStart)) ? 1 : parseInt(options.headerLevelStart), setextRegexH1 = options.smoothLivePreview ? /^(.+)[ \\t]*\\n={2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm, setextRegexH2 = options.smoothLivePreview ? /^(.+)[ \\t]*\\n-{2,}[ \\t]*\\n+/gm : /^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm;\n    text = text.replace(setextRegexH1, function(wholeMatch, m1) {\n      var spanGamut = showdown.subParser(\"spanGamut\")(m1, options, globals), hID = options.noHeaderId ? \"\" : ' id=\"' + headerId(m1) + '\"', hLevel = headerLevelStart, hashBlock = \"<h\" + hLevel + hID + \">\" + spanGamut + \"</h\" + hLevel + \">\";\n      return showdown.subParser(\"hashBlock\")(hashBlock, options, globals);\n    });\n    text = text.replace(setextRegexH2, function(matchFound, m1) {\n      var spanGamut = showdown.subParser(\"spanGamut\")(m1, options, globals), hID = options.noHeaderId ? \"\" : ' id=\"' + headerId(m1) + '\"', hLevel = headerLevelStart + 1, hashBlock = \"<h\" + hLevel + hID + \">\" + spanGamut + \"</h\" + hLevel + \">\";\n      return showdown.subParser(\"hashBlock\")(hashBlock, options, globals);\n    });\n    var atxStyle = options.requireSpaceBeforeHeadingText ? /^(#{1,6})[ \\t]+(.+?)[ \\t]*#*\\n+/gm : /^(#{1,6})[ \\t]*(.+?)[ \\t]*#*\\n+/gm;\n    text = text.replace(atxStyle, function(wholeMatch, m1, m2) {\n      var hText = m2;\n      if (options.customizedHeaderId) {\n        hText = m2.replace(/\\s?\\{([^{]+?)}\\s*$/, \"\");\n      }\n      var span = showdown.subParser(\"spanGamut\")(hText, options, globals), hID = options.noHeaderId ? \"\" : ' id=\"' + headerId(m2) + '\"', hLevel = headerLevelStart - 1 + m1.length, header = \"<h\" + hLevel + hID + \">\" + span + \"</h\" + hLevel + \">\";\n      return showdown.subParser(\"hashBlock\")(header, options, globals);\n    });\n    function headerId(m) {\n      var title, prefix;\n      if (options.customizedHeaderId) {\n        var match = m.match(/\\{([^{]+?)}\\s*$/);\n        if (match && match[1]) {\n          m = match[1];\n        }\n      }\n      title = m;\n      if (showdown.helper.isString(options.prefixHeaderId)) {\n        prefix = options.prefixHeaderId;\n      } else if (options.prefixHeaderId === true) {\n        prefix = \"section-\";\n      } else {\n        prefix = \"\";\n      }\n      if (!options.rawPrefixHeaderId) {\n        title = prefix + title;\n      }\n      if (options.ghCompatibleHeaderId) {\n        title = title.replace(/ /g, \"-\").replace(/&amp;/g, \"\").replace(/T/g, \"\").replace(/D/g, \"\").replace(/[&+$,\\/:;=?@\"#{}|^~\\[\\]`\\\\*)(%.!'<>]/g, \"\").toLowerCase();\n      } else if (options.rawHeaderId) {\n        title = title.replace(/ /g, \"-\").replace(/&amp;/g, \"&\").replace(/T/g, \"\\xA8\").replace(/D/g, \"$\").replace(/[\"']/g, \"-\").toLowerCase();\n      } else {\n        title = title.replace(/[^\\w]/g, \"\").toLowerCase();\n      }\n      if (options.rawPrefixHeaderId) {\n        title = prefix + title;\n      }\n      if (globals.hashLinkCounts[title]) {\n        title = title + \"-\" + globals.hashLinkCounts[title]++;\n      } else {\n        globals.hashLinkCounts[title] = 1;\n      }\n      return title;\n    }\n    text = globals.converter._dispatch(\"headers.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"horizontalRule\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"horizontalRule.before\", text, options, globals);\n    var key = showdown.subParser(\"hashBlock\")(\"<hr />\", options, globals);\n    text = text.replace(/^ {0,2}( ?-){3,}[ \\t]*$/gm, key);\n    text = text.replace(/^ {0,2}( ?\\*){3,}[ \\t]*$/gm, key);\n    text = text.replace(/^ {0,2}( ?_){3,}[ \\t]*$/gm, key);\n    text = globals.converter._dispatch(\"horizontalRule.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"images\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"images.before\", text, options, globals);\n    var inlineRegExp = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<?([\\S]+?(?:\\([\\S]*?\\)[\\S]*?)?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:([\"'])([^\"]*?)\\6)?[ \\t]?\\)/g, crazyRegExp = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<([^>]*)>(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:(?:([\"'])([^\"]*?)\\6))?[ \\t]?\\)/g, base64RegExp = /!\\[([^\\]]*?)][ \\t]*()\\([ \\t]?<?(data:.+?\\/.+?;base64,[A-Za-z0-9+/=\\n]+?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*(?:([\"'])([^\"]*?)\\6)?[ \\t]?\\)/g, referenceRegExp = /!\\[([^\\]]*?)] ?(?:\\n *)?\\[([\\s\\S]*?)]()()()()()/g, refShortcutRegExp = /!\\[([^\\[\\]]+)]()()()()()/g;\n    function writeImageTagBase64(wholeMatch, altText, linkId, url, width, height, m5, title) {\n      url = url.replace(/\\s/g, \"\");\n      return writeImageTag(wholeMatch, altText, linkId, url, width, height, m5, title);\n    }\n    function writeImageTag(wholeMatch, altText, linkId, url, width, height, m5, title) {\n      var gUrls = globals.gUrls, gTitles = globals.gTitles, gDims = globals.gDimensions;\n      linkId = linkId.toLowerCase();\n      if (!title) {\n        title = \"\";\n      }\n      if (wholeMatch.search(/\\(<?\\s*>? ?(['\"].*['\"])?\\)$/m) > -1) {\n        url = \"\";\n      } else if (url === \"\" || url === null) {\n        if (linkId === \"\" || linkId === null) {\n          linkId = altText.toLowerCase().replace(/ ?\\n/g, \" \");\n        }\n        url = \"#\" + linkId;\n        if (!showdown.helper.isUndefined(gUrls[linkId])) {\n          url = gUrls[linkId];\n          if (!showdown.helper.isUndefined(gTitles[linkId])) {\n            title = gTitles[linkId];\n          }\n          if (!showdown.helper.isUndefined(gDims[linkId])) {\n            width = gDims[linkId].width;\n            height = gDims[linkId].height;\n          }\n        } else {\n          return wholeMatch;\n        }\n      }\n      altText = altText.replace(/\"/g, \"&quot;\").replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n      url = url.replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n      var result = '<img src=\"' + url + '\" alt=\"' + altText + '\"';\n      if (title && showdown.helper.isString(title)) {\n        title = title.replace(/\"/g, \"&quot;\").replace(showdown.helper.regexes.asteriskDashAndColon, showdown.helper.escapeCharactersCallback);\n        result += ' title=\"' + title + '\"';\n      }\n      if (width && height) {\n        width = width === \"*\" ? \"auto\" : width;\n        height = height === \"*\" ? \"auto\" : height;\n        result += ' width=\"' + width + '\"';\n        result += ' height=\"' + height + '\"';\n      }\n      result += \" />\";\n      return result;\n    }\n    text = text.replace(referenceRegExp, writeImageTag);\n    text = text.replace(base64RegExp, writeImageTagBase64);\n    text = text.replace(crazyRegExp, writeImageTag);\n    text = text.replace(inlineRegExp, writeImageTag);\n    text = text.replace(refShortcutRegExp, writeImageTag);\n    text = globals.converter._dispatch(\"images.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"italicsAndBold\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"italicsAndBold.before\", text, options, globals);\n    function parseInside(txt, left, right) {\n      return left + txt + right;\n    }\n    if (options.literalMidWordUnderscores) {\n      text = text.replace(/\\b___(\\S[\\s\\S]*?)___\\b/g, function(wm, txt) {\n        return parseInside(txt, \"<strong><em>\", \"</em></strong>\");\n      });\n      text = text.replace(/\\b__(\\S[\\s\\S]*?)__\\b/g, function(wm, txt) {\n        return parseInside(txt, \"<strong>\", \"</strong>\");\n      });\n      text = text.replace(/\\b_(\\S[\\s\\S]*?)_\\b/g, function(wm, txt) {\n        return parseInside(txt, \"<em>\", \"</em>\");\n      });\n    } else {\n      text = text.replace(/___(\\S[\\s\\S]*?)___/g, function(wm, m) {\n        return /\\S$/.test(m) ? parseInside(m, \"<strong><em>\", \"</em></strong>\") : wm;\n      });\n      text = text.replace(/__(\\S[\\s\\S]*?)__/g, function(wm, m) {\n        return /\\S$/.test(m) ? parseInside(m, \"<strong>\", \"</strong>\") : wm;\n      });\n      text = text.replace(/_([^\\s_][\\s\\S]*?)_/g, function(wm, m) {\n        return /\\S$/.test(m) ? parseInside(m, \"<em>\", \"</em>\") : wm;\n      });\n    }\n    if (options.literalMidWordAsterisks) {\n      text = text.replace(/([^*]|^)\\B\\*\\*\\*(\\S[\\s\\S]*?)\\*\\*\\*\\B(?!\\*)/g, function(wm, lead, txt) {\n        return parseInside(txt, lead + \"<strong><em>\", \"</em></strong>\");\n      });\n      text = text.replace(/([^*]|^)\\B\\*\\*(\\S[\\s\\S]*?)\\*\\*\\B(?!\\*)/g, function(wm, lead, txt) {\n        return parseInside(txt, lead + \"<strong>\", \"</strong>\");\n      });\n      text = text.replace(/([^*]|^)\\B\\*(\\S[\\s\\S]*?)\\*\\B(?!\\*)/g, function(wm, lead, txt) {\n        return parseInside(txt, lead + \"<em>\", \"</em>\");\n      });\n    } else {\n      text = text.replace(/\\*\\*\\*(\\S[\\s\\S]*?)\\*\\*\\*/g, function(wm, m) {\n        return /\\S$/.test(m) ? parseInside(m, \"<strong><em>\", \"</em></strong>\") : wm;\n      });\n      text = text.replace(/\\*\\*(\\S[\\s\\S]*?)\\*\\*/g, function(wm, m) {\n        return /\\S$/.test(m) ? parseInside(m, \"<strong>\", \"</strong>\") : wm;\n      });\n      text = text.replace(/\\*([^\\s*][\\s\\S]*?)\\*/g, function(wm, m) {\n        return /\\S$/.test(m) ? parseInside(m, \"<em>\", \"</em>\") : wm;\n      });\n    }\n    text = globals.converter._dispatch(\"italicsAndBold.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"lists\", function(text, options, globals) {\n    \"use strict\";\n    function processListItems(listStr, trimTrailing) {\n      globals.gListLevel++;\n      listStr = listStr.replace(/\\n{2,}$/, \"\\n\");\n      listStr += \"\\xA80\";\n      var rgx = /(\\n)?(^ {0,3})([*+-]|\\d+[.])[ \\t]+((\\[(x|X| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(0| {0,3}([*+-]|\\d+[.])[ \\t]+))/gm, isParagraphed = /\\n[ \\t]*\\n(?!0)/.test(listStr);\n      if (options.disableForced4SpacesIndentedSublists) {\n        rgx = /(\\n)?(^ {0,3})([*+-]|\\d+[.])[ \\t]+((\\[(x|X| )?])?[ \\t]*[^\\r]+?(\\n{1,2}))(?=\\n*(0|\\2([*+-]|\\d+[.])[ \\t]+))/gm;\n      }\n      listStr = listStr.replace(rgx, function(wholeMatch, m1, m2, m3, m4, taskbtn, checked) {\n        checked = checked && checked.trim() !== \"\";\n        var item = showdown.subParser(\"outdent\")(m4, options, globals), bulletStyle = \"\";\n        if (taskbtn && options.tasklists) {\n          bulletStyle = ' class=\"task-list-item\" style=\"list-style-type: none;\"';\n          item = item.replace(/^[ \\t]*\\[(x|X| )?]/m, function() {\n            var otp = '<input type=\"checkbox\" disabled style=\"margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;\"';\n            if (checked) {\n              otp += \" checked\";\n            }\n            otp += \">\";\n            return otp;\n          });\n        }\n        item = item.replace(/^([-*+]|\\d\\.)[ \\t]+[\\S\\n ]*/g, function(wm2) {\n          return \"\\xA8A\" + wm2;\n        });\n        if (m1 || item.search(/\\n{2,}/) > -1) {\n          item = showdown.subParser(\"githubCodeBlocks\")(item, options, globals);\n          item = showdown.subParser(\"blockGamut\")(item, options, globals);\n        } else {\n          item = showdown.subParser(\"lists\")(item, options, globals);\n          item = item.replace(/\\n$/, \"\");\n          item = showdown.subParser(\"hashHTMLBlocks\")(item, options, globals);\n          item = item.replace(/\\n\\n+/g, \"\\n\\n\");\n          if (isParagraphed) {\n            item = showdown.subParser(\"paragraphs\")(item, options, globals);\n          } else {\n            item = showdown.subParser(\"spanGamut\")(item, options, globals);\n          }\n        }\n        item = item.replace(\"\\xA8A\", \"\");\n        item = \"<li\" + bulletStyle + \">\" + item + \"</li>\\n\";\n        return item;\n      });\n      listStr = listStr.replace(/0/g, \"\");\n      globals.gListLevel--;\n      if (trimTrailing) {\n        listStr = listStr.replace(/\\s+$/, \"\");\n      }\n      return listStr;\n    }\n    function styleStartNumber(list, listType) {\n      if (listType === \"ol\") {\n        var res = list.match(/^ *(\\d+)\\./);\n        if (res && res[1] !== \"1\") {\n          return ' start=\"' + res[1] + '\"';\n        }\n      }\n      return \"\";\n    }\n    function parseConsecutiveLists(list, listType, trimTrailing) {\n      var olRgx = options.disableForced4SpacesIndentedSublists ? /^ ?\\d+\\.[ \\t]/gm : /^ {0,3}\\d+\\.[ \\t]/gm, ulRgx = options.disableForced4SpacesIndentedSublists ? /^ ?[*+-][ \\t]/gm : /^ {0,3}[*+-][ \\t]/gm, counterRxg = listType === \"ul\" ? olRgx : ulRgx, result = \"\";\n      if (list.search(counterRxg) !== -1) {\n        (function parseCL(txt) {\n          var pos = txt.search(counterRxg), style2 = styleStartNumber(list, listType);\n          if (pos !== -1) {\n            result += \"\\n\\n<\" + listType + style2 + \">\\n\" + processListItems(txt.slice(0, pos), !!trimTrailing) + \"</\" + listType + \">\\n\";\n            listType = listType === \"ul\" ? \"ol\" : \"ul\";\n            counterRxg = listType === \"ul\" ? olRgx : ulRgx;\n            parseCL(txt.slice(pos));\n          } else {\n            result += \"\\n\\n<\" + listType + style2 + \">\\n\" + processListItems(txt, !!trimTrailing) + \"</\" + listType + \">\\n\";\n          }\n        })(list);\n      } else {\n        var style = styleStartNumber(list, listType);\n        result = \"\\n\\n<\" + listType + style + \">\\n\" + processListItems(list, !!trimTrailing) + \"</\" + listType + \">\\n\";\n      }\n      return result;\n    }\n    text = globals.converter._dispatch(\"lists.before\", text, options, globals);\n    text += \"\\xA80\";\n    if (globals.gListLevel) {\n      text = text.replace(\n        /^(( {0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm,\n        function(wholeMatch, list, m2) {\n          var listType = m2.search(/[*+-]/g) > -1 ? \"ul\" : \"ol\";\n          return parseConsecutiveLists(list, listType, true);\n        }\n      );\n    } else {\n      text = text.replace(\n        /(\\n\\n|^\\n?)(( {0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm,\n        function(wholeMatch, m1, list, m3) {\n          var listType = m3.search(/[*+-]/g) > -1 ? \"ul\" : \"ol\";\n          return parseConsecutiveLists(list, listType, false);\n        }\n      );\n    }\n    text = text.replace(/0/, \"\");\n    text = globals.converter._dispatch(\"lists.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"metadata\", function(text, options, globals) {\n    \"use strict\";\n    if (!options.metadata) {\n      return text;\n    }\n    text = globals.converter._dispatch(\"metadata.before\", text, options, globals);\n    function parseMetadataContents(content) {\n      globals.metadata.raw = content;\n      content = content.replace(/&/g, \"&amp;\").replace(/\"/g, \"&quot;\");\n      content = content.replace(/\\n {4}/g, \" \");\n      content.replace(/^([\\S ]+): +([\\s\\S]+?)$/gm, function(wm, key, value) {\n        globals.metadata.parsed[key] = value;\n        return \"\";\n      });\n    }\n    text = text.replace(/^\\s*+(\\S*?)\\n([\\s\\S]+?)\\n+\\n/, function(wholematch, format, content) {\n      parseMetadataContents(content);\n      return \"\\xA8M\";\n    });\n    text = text.replace(/^\\s*---+(\\S*?)\\n([\\s\\S]+?)\\n---+\\n/, function(wholematch, format, content) {\n      if (format) {\n        globals.metadata.format = format;\n      }\n      parseMetadataContents(content);\n      return \"\\xA8M\";\n    });\n    text = text.replace(/M/g, \"\");\n    text = globals.converter._dispatch(\"metadata.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"outdent\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"outdent.before\", text, options, globals);\n    text = text.replace(/^(\\t|[ ]{1,4})/gm, \"\\xA80\");\n    text = text.replace(/0/g, \"\");\n    text = globals.converter._dispatch(\"outdent.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"paragraphs\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"paragraphs.before\", text, options, globals);\n    text = text.replace(/^\\n+/g, \"\");\n    text = text.replace(/\\n+$/g, \"\");\n    var grafs = text.split(/\\n{2,}/g), grafsOut = [], end = grafs.length;\n    for (var i = 0; i < end; i++) {\n      var str = grafs[i];\n      if (str.search(/(K|G)(\\d+)\\1/g) >= 0) {\n        grafsOut.push(str);\n      } else if (str.search(/\\S/) >= 0) {\n        str = showdown.subParser(\"spanGamut\")(str, options, globals);\n        str = str.replace(/^([ \\t]*)/g, \"<p>\");\n        str += \"</p>\";\n        grafsOut.push(str);\n      }\n    }\n    end = grafsOut.length;\n    for (i = 0; i < end; i++) {\n      var blockText = \"\", grafsOutIt = grafsOut[i], codeFlag = false;\n      while (/(K|G)(\\d+)\\1/.test(grafsOutIt)) {\n        var delim = RegExp.$1, num = RegExp.$2;\n        if (delim === \"K\") {\n          blockText = globals.gHtmlBlocks[num];\n        } else {\n          if (codeFlag) {\n            blockText = showdown.subParser(\"encodeCode\")(globals.ghCodeBlocks[num].text, options, globals);\n          } else {\n            blockText = globals.ghCodeBlocks[num].codeblock;\n          }\n        }\n        blockText = blockText.replace(/\\$/g, \"$$$$\");\n        grafsOutIt = grafsOutIt.replace(/(\\n\\n)?(K|G)\\d+\\2(\\n\\n)?/, blockText);\n        if (/^<pre\\b[^>]*>\\s*<code\\b[^>]*>/.test(grafsOutIt)) {\n          codeFlag = true;\n        }\n      }\n      grafsOut[i] = grafsOutIt;\n    }\n    text = grafsOut.join(\"\\n\");\n    text = text.replace(/^\\n+/g, \"\");\n    text = text.replace(/\\n+$/g, \"\");\n    return globals.converter._dispatch(\"paragraphs.after\", text, options, globals);\n  });\n  showdown.subParser(\"runExtension\", function(ext, text, options, globals) {\n    \"use strict\";\n    if (ext.filter) {\n      text = ext.filter(text, globals.converter, options);\n    } else if (ext.regex) {\n      var re = ext.regex;\n      if (!(re instanceof RegExp)) {\n        re = new RegExp(re, \"g\");\n      }\n      text = text.replace(re, ext.replace);\n    }\n    return text;\n  });\n  showdown.subParser(\"spanGamut\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"spanGamut.before\", text, options, globals);\n    text = showdown.subParser(\"codeSpans\")(text, options, globals);\n    text = showdown.subParser(\"escapeSpecialCharsWithinTagAttributes\")(text, options, globals);\n    text = showdown.subParser(\"encodeBackslashEscapes\")(text, options, globals);\n    text = showdown.subParser(\"images\")(text, options, globals);\n    text = showdown.subParser(\"anchors\")(text, options, globals);\n    text = showdown.subParser(\"autoLinks\")(text, options, globals);\n    text = showdown.subParser(\"simplifiedAutoLinks\")(text, options, globals);\n    text = showdown.subParser(\"emoji\")(text, options, globals);\n    text = showdown.subParser(\"underline\")(text, options, globals);\n    text = showdown.subParser(\"italicsAndBold\")(text, options, globals);\n    text = showdown.subParser(\"strikethrough\")(text, options, globals);\n    text = showdown.subParser(\"ellipsis\")(text, options, globals);\n    text = showdown.subParser(\"hashHTMLSpans\")(text, options, globals);\n    text = showdown.subParser(\"encodeAmpsAndAngles\")(text, options, globals);\n    if (options.simpleLineBreaks) {\n      if (!/\\n\\nK/.test(text)) {\n        text = text.replace(/\\n+/g, \"<br />\\n\");\n      }\n    } else {\n      text = text.replace(/  +\\n/g, \"<br />\\n\");\n    }\n    text = globals.converter._dispatch(\"spanGamut.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"strikethrough\", function(text, options, globals) {\n    \"use strict\";\n    function parseInside(txt) {\n      if (options.simplifiedAutoLink) {\n        txt = showdown.subParser(\"simplifiedAutoLinks\")(txt, options, globals);\n      }\n      return \"<del>\" + txt + \"</del>\";\n    }\n    if (options.strikethrough) {\n      text = globals.converter._dispatch(\"strikethrough.before\", text, options, globals);\n      text = text.replace(/(?:~){2}([\\s\\S]+?)(?:~){2}/g, function(wm, txt) {\n        return parseInside(txt);\n      });\n      text = globals.converter._dispatch(\"strikethrough.after\", text, options, globals);\n    }\n    return text;\n  });\n  showdown.subParser(\"stripLinkDefinitions\", function(text, options, globals) {\n    \"use strict\";\n    var regex = /^ {0,3}\\[([^\\]]+)]:[ \\t]*\\n?[ \\t]*<?([^>\\s]+)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"|'(](.+?)[\"|')][ \\t]*)?(?:\\n+|(?=0))/gm, base64Regex = /^ {0,3}\\[([^\\]]+)]:[ \\t]*\\n?[ \\t]*<?(data:.+?\\/.+?;base64,[A-Za-z0-9+/=\\n]+?)>?(?: =([*\\d]+[A-Za-z%]{0,4})x([*\\d]+[A-Za-z%]{0,4}))?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"|'(](.+?)[\"|')][ \\t]*)?(?:\\n\\n|(?=0)|(?=\\n\\[))/gm;\n    text += \"\\xA80\";\n    var replaceFunc = function(wholeMatch, linkId, url, width, height, blankLines, title) {\n      linkId = linkId.toLowerCase();\n      if (text.toLowerCase().split(linkId).length - 1 < 2) {\n        return wholeMatch;\n      }\n      if (url.match(/^data:.+?\\/.+?;base64,/)) {\n        globals.gUrls[linkId] = url.replace(/\\s/g, \"\");\n      } else {\n        globals.gUrls[linkId] = showdown.subParser(\"encodeAmpsAndAngles\")(url, options, globals);\n      }\n      if (blankLines) {\n        return blankLines + title;\n      } else {\n        if (title) {\n          globals.gTitles[linkId] = title.replace(/\"|'/g, \"&quot;\");\n        }\n        if (options.parseImgDimensions && width && height) {\n          globals.gDimensions[linkId] = {\n            width,\n            height\n          };\n        }\n      }\n      return \"\";\n    };\n    text = text.replace(base64Regex, replaceFunc);\n    text = text.replace(regex, replaceFunc);\n    text = text.replace(/0/, \"\");\n    return text;\n  });\n  showdown.subParser(\"tables\", function(text, options, globals) {\n    \"use strict\";\n    if (!options.tables) {\n      return text;\n    }\n    var tableRgx = /^ {0,3}\\|?.+\\|.+\\n {0,3}\\|?[ \\t]*:?[ \\t]*(?:[-=]){2,}[ \\t]*:?[ \\t]*\\|[ \\t]*:?[ \\t]*(?:[-=]){2,}[\\s\\S]+?(?:\\n\\n|0)/gm, singeColTblRgx = /^ {0,3}\\|.+\\|[ \\t]*\\n {0,3}\\|[ \\t]*:?[ \\t]*(?:[-=]){2,}[ \\t]*:?[ \\t]*\\|[ \\t]*\\n( {0,3}\\|.+\\|[ \\t]*\\n)*(?:\\n|0)/gm;\n    function parseStyles(sLine) {\n      if (/^:[ \\t]*--*$/.test(sLine)) {\n        return ' style=\"text-align:left;\"';\n      } else if (/^--*[ \\t]*:[ \\t]*$/.test(sLine)) {\n        return ' style=\"text-align:right;\"';\n      } else if (/^:[ \\t]*--*[ \\t]*:$/.test(sLine)) {\n        return ' style=\"text-align:center;\"';\n      } else {\n        return \"\";\n      }\n    }\n    function parseHeaders(header, style) {\n      var id = \"\";\n      header = header.trim();\n      if (options.tablesHeaderId || options.tableHeaderId) {\n        id = ' id=\"' + header.replace(/ /g, \"_\").toLowerCase() + '\"';\n      }\n      header = showdown.subParser(\"spanGamut\")(header, options, globals);\n      return \"<th\" + id + style + \">\" + header + \"</th>\\n\";\n    }\n    function parseCells(cell, style) {\n      var subText = showdown.subParser(\"spanGamut\")(cell, options, globals);\n      return \"<td\" + style + \">\" + subText + \"</td>\\n\";\n    }\n    function buildTable(headers, cells) {\n      var tb = \"<table>\\n<thead>\\n<tr>\\n\", tblLgn = headers.length;\n      for (var i = 0; i < tblLgn; ++i) {\n        tb += headers[i];\n      }\n      tb += \"</tr>\\n</thead>\\n<tbody>\\n\";\n      for (i = 0; i < cells.length; ++i) {\n        tb += \"<tr>\\n\";\n        for (var ii = 0; ii < tblLgn; ++ii) {\n          tb += cells[i][ii];\n        }\n        tb += \"</tr>\\n\";\n      }\n      tb += \"</tbody>\\n</table>\\n\";\n      return tb;\n    }\n    function parseTable(rawTable) {\n      var i, tableLines = rawTable.split(\"\\n\");\n      for (i = 0; i < tableLines.length; ++i) {\n        if (/^ {0,3}\\|/.test(tableLines[i])) {\n          tableLines[i] = tableLines[i].replace(/^ {0,3}\\|/, \"\");\n        }\n        if (/\\|[ \\t]*$/.test(tableLines[i])) {\n          tableLines[i] = tableLines[i].replace(/\\|[ \\t]*$/, \"\");\n        }\n        tableLines[i] = showdown.subParser(\"codeSpans\")(tableLines[i], options, globals);\n      }\n      var rawHeaders = tableLines[0].split(\"|\").map(function(s) {\n        return s.trim();\n      }), rawStyles = tableLines[1].split(\"|\").map(function(s) {\n        return s.trim();\n      }), rawCells = [], headers = [], styles = [], cells = [];\n      tableLines.shift();\n      tableLines.shift();\n      for (i = 0; i < tableLines.length; ++i) {\n        if (tableLines[i].trim() === \"\") {\n          continue;\n        }\n        rawCells.push(\n          tableLines[i].split(\"|\").map(function(s) {\n            return s.trim();\n          })\n        );\n      }\n      if (rawHeaders.length < rawStyles.length) {\n        return rawTable;\n      }\n      for (i = 0; i < rawStyles.length; ++i) {\n        styles.push(parseStyles(rawStyles[i]));\n      }\n      for (i = 0; i < rawHeaders.length; ++i) {\n        if (showdown.helper.isUndefined(styles[i])) {\n          styles[i] = \"\";\n        }\n        headers.push(parseHeaders(rawHeaders[i], styles[i]));\n      }\n      for (i = 0; i < rawCells.length; ++i) {\n        var row = [];\n        for (var ii = 0; ii < headers.length; ++ii) {\n          if (showdown.helper.isUndefined(rawCells[i][ii])) {\n          }\n          row.push(parseCells(rawCells[i][ii], styles[ii]));\n        }\n        cells.push(row);\n      }\n      return buildTable(headers, cells);\n    }\n    text = globals.converter._dispatch(\"tables.before\", text, options, globals);\n    text = text.replace(/\\\\(\\|)/g, showdown.helper.escapeCharactersCallback);\n    text = text.replace(tableRgx, parseTable);\n    text = text.replace(singeColTblRgx, parseTable);\n    text = globals.converter._dispatch(\"tables.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"underline\", function(text, options, globals) {\n    \"use strict\";\n    if (!options.underline) {\n      return text;\n    }\n    text = globals.converter._dispatch(\"underline.before\", text, options, globals);\n    if (options.literalMidWordUnderscores) {\n      text = text.replace(/\\b___(\\S[\\s\\S]*?)___\\b/g, function(wm, txt) {\n        return \"<u>\" + txt + \"</u>\";\n      });\n      text = text.replace(/\\b__(\\S[\\s\\S]*?)__\\b/g, function(wm, txt) {\n        return \"<u>\" + txt + \"</u>\";\n      });\n    } else {\n      text = text.replace(/___(\\S[\\s\\S]*?)___/g, function(wm, m) {\n        return /\\S$/.test(m) ? \"<u>\" + m + \"</u>\" : wm;\n      });\n      text = text.replace(/__(\\S[\\s\\S]*?)__/g, function(wm, m) {\n        return /\\S$/.test(m) ? \"<u>\" + m + \"</u>\" : wm;\n      });\n    }\n    text = text.replace(/(_)/g, showdown.helper.escapeCharactersCallback);\n    text = globals.converter._dispatch(\"underline.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"unescapeSpecialChars\", function(text, options, globals) {\n    \"use strict\";\n    text = globals.converter._dispatch(\"unescapeSpecialChars.before\", text, options, globals);\n    text = text.replace(/E(\\d+)E/g, function(wholeMatch, m1) {\n      var charCodeToReplace = parseInt(m1);\n      return String.fromCharCode(charCodeToReplace);\n    });\n    text = globals.converter._dispatch(\"unescapeSpecialChars.after\", text, options, globals);\n    return text;\n  });\n  showdown.subParser(\"makeMarkdown.blockquote\", function(node, globals) {\n    \"use strict\";\n    var txt = \"\";\n    if (node.hasChildNodes()) {\n      var children = node.childNodes, childrenLength = children.length;\n      for (var i = 0; i < childrenLength; ++i) {\n        var innerTxt = showdown.subParser(\"makeMarkdown.node\")(children[i], globals);\n        if (innerTxt === \"\") {\n          continue;\n        }\n        txt += innerTxt;\n      }\n    }\n    txt = txt.trim();\n    txt = \"> \" + txt.split(\"\\n\").join(\"\\n> \");\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.codeBlock\", function(node, globals) {\n    \"use strict\";\n    var lang = node.getAttribute(\"language\"), num = node.getAttribute(\"precodenum\");\n    return \"```\" + lang + \"\\n\" + globals.preList[num] + \"\\n```\";\n  });\n  showdown.subParser(\"makeMarkdown.codeSpan\", function(node) {\n    \"use strict\";\n    return \"`\" + node.innerHTML + \"`\";\n  });\n  showdown.subParser(\"makeMarkdown.emphasis\", function(node, globals) {\n    \"use strict\";\n    var txt = \"\";\n    if (node.hasChildNodes()) {\n      txt += \"*\";\n      var children = node.childNodes, childrenLength = children.length;\n      for (var i = 0; i < childrenLength; ++i) {\n        txt += showdown.subParser(\"makeMarkdown.node\")(children[i], globals);\n      }\n      txt += \"*\";\n    }\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.header\", function(node, globals, headerLevel) {\n    \"use strict\";\n    var headerMark = new Array(headerLevel + 1).join(\"#\"), txt = \"\";\n    if (node.hasChildNodes()) {\n      txt = headerMark + \" \";\n      var children = node.childNodes, childrenLength = children.length;\n      for (var i = 0; i < childrenLength; ++i) {\n        txt += showdown.subParser(\"makeMarkdown.node\")(children[i], globals);\n      }\n    }\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.hr\", function() {\n    \"use strict\";\n    return \"---\";\n  });\n  showdown.subParser(\"makeMarkdown.image\", function(node) {\n    \"use strict\";\n    var txt = \"\";\n    if (node.hasAttribute(\"src\")) {\n      txt += \"![\" + node.getAttribute(\"alt\") + \"](\";\n      txt += \"<\" + node.getAttribute(\"src\") + \">\";\n      if (node.hasAttribute(\"width\") && node.hasAttribute(\"height\")) {\n        txt += \" =\" + node.getAttribute(\"width\") + \"x\" + node.getAttribute(\"height\");\n      }\n      if (node.hasAttribute(\"title\")) {\n        txt += ' \"' + node.getAttribute(\"title\") + '\"';\n      }\n      txt += \")\";\n    }\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.links\", function(node, globals) {\n    \"use strict\";\n    var txt = \"\";\n    if (node.hasChildNodes() && node.hasAttribute(\"href\")) {\n      var children = node.childNodes, childrenLength = children.length;\n      txt = \"[\";\n      for (var i = 0; i < childrenLength; ++i) {\n        txt += showdown.subParser(\"makeMarkdown.node\")(children[i], globals);\n      }\n      txt += \"](\";\n      txt += \"<\" + node.getAttribute(\"href\") + \">\";\n      if (node.hasAttribute(\"title\")) {\n        txt += ' \"' + node.getAttribute(\"title\") + '\"';\n      }\n      txt += \")\";\n    }\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.list\", function(node, globals, type) {\n    \"use strict\";\n    var txt = \"\";\n    if (!node.hasChildNodes()) {\n      return \"\";\n    }\n    var listItems = node.childNodes, listItemsLenght = listItems.length, listNum = node.getAttribute(\"start\") || 1;\n    for (var i = 0; i < listItemsLenght; ++i) {\n      if (typeof listItems[i].tagName === \"undefined\" || listItems[i].tagName.toLowerCase() !== \"li\") {\n        continue;\n      }\n      var bullet = \"\";\n      if (type === \"ol\") {\n        bullet = listNum.toString() + \". \";\n      } else {\n        bullet = \"- \";\n      }\n      txt += bullet + showdown.subParser(\"makeMarkdown.listItem\")(listItems[i], globals);\n      ++listNum;\n    }\n    txt += \"\\n<!-- -->\\n\";\n    return txt.trim();\n  });\n  showdown.subParser(\"makeMarkdown.listItem\", function(node, globals) {\n    \"use strict\";\n    var listItemTxt = \"\";\n    var children = node.childNodes, childrenLenght = children.length;\n    for (var i = 0; i < childrenLenght; ++i) {\n      listItemTxt += showdown.subParser(\"makeMarkdown.node\")(children[i], globals);\n    }\n    if (!/\\n$/.test(listItemTxt)) {\n      listItemTxt += \"\\n\";\n    } else {\n      listItemTxt = listItemTxt.split(\"\\n\").join(\"\\n    \").replace(/^ {4}$/gm, \"\").replace(/\\n\\n+/g, \"\\n\\n\");\n    }\n    return listItemTxt;\n  });\n  showdown.subParser(\"makeMarkdown.node\", function(node, globals, spansOnly) {\n    \"use strict\";\n    spansOnly = spansOnly || false;\n    var txt = \"\";\n    if (node.nodeType === 3) {\n      return showdown.subParser(\"makeMarkdown.txt\")(node, globals);\n    }\n    if (node.nodeType === 8) {\n      return \"<!--\" + node.data + \"-->\\n\\n\";\n    }\n    if (node.nodeType !== 1) {\n      return \"\";\n    }\n    var tagName = node.tagName.toLowerCase();\n    switch (tagName) {\n      case \"h1\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.header\")(node, globals, 1) + \"\\n\\n\";\n        }\n        break;\n      case \"h2\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.header\")(node, globals, 2) + \"\\n\\n\";\n        }\n        break;\n      case \"h3\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.header\")(node, globals, 3) + \"\\n\\n\";\n        }\n        break;\n      case \"h4\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.header\")(node, globals, 4) + \"\\n\\n\";\n        }\n        break;\n      case \"h5\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.header\")(node, globals, 5) + \"\\n\\n\";\n        }\n        break;\n      case \"h6\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.header\")(node, globals, 6) + \"\\n\\n\";\n        }\n        break;\n      case \"p\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.paragraph\")(node, globals) + \"\\n\\n\";\n        }\n        break;\n      case \"blockquote\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.blockquote\")(node, globals) + \"\\n\\n\";\n        }\n        break;\n      case \"hr\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.hr\")(node, globals) + \"\\n\\n\";\n        }\n        break;\n      case \"ol\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.list\")(node, globals, \"ol\") + \"\\n\\n\";\n        }\n        break;\n      case \"ul\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.list\")(node, globals, \"ul\") + \"\\n\\n\";\n        }\n        break;\n      case \"precode\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.codeBlock\")(node, globals) + \"\\n\\n\";\n        }\n        break;\n      case \"pre\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.pre\")(node, globals) + \"\\n\\n\";\n        }\n        break;\n      case \"table\":\n        if (!spansOnly) {\n          txt = showdown.subParser(\"makeMarkdown.table\")(node, globals) + \"\\n\\n\";\n        }\n        break;\n      case \"code\":\n        txt = showdown.subParser(\"makeMarkdown.codeSpan\")(node, globals);\n        break;\n      case \"em\":\n      case \"i\":\n        txt = showdown.subParser(\"makeMarkdown.emphasis\")(node, globals);\n        break;\n      case \"strong\":\n      case \"b\":\n        txt = showdown.subParser(\"makeMarkdown.strong\")(node, globals);\n        break;\n      case \"del\":\n        txt = showdown.subParser(\"makeMarkdown.strikethrough\")(node, globals);\n        break;\n      case \"a\":\n        txt = showdown.subParser(\"makeMarkdown.links\")(node, globals);\n        break;\n      case \"img\":\n        txt = showdown.subParser(\"makeMarkdown.image\")(node, globals);\n        break;\n      default:\n        txt = node.outerHTML + \"\\n\\n\";\n    }\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.paragraph\", function(node, globals) {\n    \"use strict\";\n    var txt = \"\";\n    if (node.hasChildNodes()) {\n      var children = node.childNodes, childrenLength = children.length;\n      for (var i = 0; i < childrenLength; ++i) {\n        txt += showdown.subParser(\"makeMarkdown.node\")(children[i], globals);\n      }\n    }\n    txt = txt.trim();\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.pre\", function(node, globals) {\n    \"use strict\";\n    var num = node.getAttribute(\"prenum\");\n    return \"<pre>\" + globals.preList[num] + \"</pre>\";\n  });\n  showdown.subParser(\"makeMarkdown.strikethrough\", function(node, globals) {\n    \"use strict\";\n    var txt = \"\";\n    if (node.hasChildNodes()) {\n      txt += \"~~\";\n      var children = node.childNodes, childrenLength = children.length;\n      for (var i = 0; i < childrenLength; ++i) {\n        txt += showdown.subParser(\"makeMarkdown.node\")(children[i], globals);\n      }\n      txt += \"~~\";\n    }\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.strong\", function(node, globals) {\n    \"use strict\";\n    var txt = \"\";\n    if (node.hasChildNodes()) {\n      txt += \"**\";\n      var children = node.childNodes, childrenLength = children.length;\n      for (var i = 0; i < childrenLength; ++i) {\n        txt += showdown.subParser(\"makeMarkdown.node\")(children[i], globals);\n      }\n      txt += \"**\";\n    }\n    return txt;\n  });\n  showdown.subParser(\"makeMarkdown.table\", function(node, globals) {\n    \"use strict\";\n    var txt = \"\", tableArray = [[], []], headings = node.querySelectorAll(\"thead>tr>th\"), rows = node.querySelectorAll(\"tbody>tr\"), i, ii;\n    for (i = 0; i < headings.length; ++i) {\n      var headContent = showdown.subParser(\"makeMarkdown.tableCell\")(headings[i], globals), allign = \"---\";\n      if (headings[i].hasAttribute(\"style\")) {\n        var style = headings[i].getAttribute(\"style\").toLowerCase().replace(/\\s/g, \"\");\n        switch (style) {\n          case \"text-align:left;\":\n            allign = \":---\";\n            break;\n          case \"text-align:right;\":\n            allign = \"---:\";\n            break;\n          case \"text-align:center;\":\n            allign = \":---:\";\n            break;\n        }\n      }\n      tableArray[0][i] = headContent.trim();\n      tableArray[1][i] = allign;\n    }\n    for (i = 0; i < rows.length; ++i) {\n      var r = tableArray.push([]) - 1, cols = rows[i].getElementsByTagName(\"td\");\n      for (ii = 0; ii < headings.length; ++ii) {\n        var cellContent = \" \";\n        if (typeof cols[ii] !== \"undefined\") {\n          cellContent = showdown.subParser(\"makeMarkdown.tableCell\")(cols[ii], globals);\n        }\n        tableArray[r].push(cellContent);\n      }\n    }\n    var cellSpacesCount = 3;\n    for (i = 0; i < tableArray.length; ++i) {\n      for (ii = 0; ii < tableArray[i].length; ++ii) {\n        var strLen = tableArray[i][ii].length;\n        if (strLen > cellSpacesCount) {\n          cellSpacesCount = strLen;\n        }\n      }\n    }\n    for (i = 0; i < tableArray.length; ++i) {\n      for (ii = 0; ii < tableArray[i].length; ++ii) {\n        if (i === 1) {\n          if (tableArray[i][ii].slice(-1) === \":\") {\n            tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii].slice(-1), cellSpacesCount - 1, \"-\") + \":\";\n          } else {\n            tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount, \"-\");\n          }\n        } else {\n          tableArray[i][ii] = showdown.helper.padEnd(tableArray[i][ii], cellSpacesCount);\n        }\n      }\n      txt += \"| \" + tableArray[i].join(\" | \") + \" |\\n\";\n    }\n    return txt.trim();\n  });\n  showdown.subParser(\"makeMarkdown.tableCell\", function(node, globals) {\n    \"use strict\";\n    var txt = \"\";\n    if (!node.hasChildNodes()) {\n      return \"\";\n    }\n    var children = node.childNodes, childrenLength = children.length;\n    for (var i = 0; i < childrenLength; ++i) {\n      txt += showdown.subParser(\"makeMarkdown.node\")(children[i], globals, true);\n    }\n    return txt.trim();\n  });\n  showdown.subParser(\"makeMarkdown.txt\", function(node) {\n    \"use strict\";\n    var txt = node.nodeValue;\n    txt = txt.replace(/ +/g, \" \");\n    txt = txt.replace(/NBSP;/g, \" \");\n    txt = showdown.helper.unescapeHTMLEntities(txt);\n    txt = txt.replace(/([*_~|`])/g, \"\\\\$1\");\n    txt = txt.replace(/^(\\s*)>/g, \"\\\\$1>\");\n    txt = txt.replace(/^#/gm, \"\\\\#\");\n    txt = txt.replace(/^(\\s*)([-=]{3,})(\\s*)$/, \"$1\\\\$2$3\");\n    txt = txt.replace(/^( {0,3}\\d+)\\./gm, \"$1\\\\.\");\n    txt = txt.replace(/^( {0,3})([+-])/gm, \"$1\\\\$2\");\n    txt = txt.replace(/]([\\s]*)\\(/g, \"\\\\]$1\\\\(\");\n    txt = txt.replace(/^ {0,3}\\[([\\S \\t]*?)]:/gm, \"\\\\[$1]:\");\n    return txt;\n  });\n  var root = this;\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      \"use strict\";\n      return showdown;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}).call(this);\n\n\n//# sourceURL=webpack://cms_git/./node_modules/showdown/dist/showdown.js?");

/***/ }),

/***/ "./node_modules/toastify-js/src/toastify.js":
/*!**************************************************!*\
  !*** ./node_modules/toastify-js/src/toastify.js ***!
  \**************************************************/
/***/ (function(module) {

eval("/*!\n * Toastify js 1.12.0\n * https://github.com/apvarun/toastify-js\n * @license MIT licensed\n *\n * Copyright (C) 2018 Varun A P\n */\n(function(root, factory) {\n  if ( true && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Toastify = factory();\n  }\n})(this, function(global) {\n  var Toastify = function(options) {\n    return new Toastify.lib.init(options);\n  }, version = \"1.12.0\";\n  Toastify.defaults = {\n    oldestFirst: true,\n    text: \"Toastify is awesome!\",\n    node: void 0,\n    duration: 3e3,\n    selector: void 0,\n    callback: function() {\n    },\n    destination: void 0,\n    newWindow: false,\n    close: false,\n    gravity: \"toastify-top\",\n    positionLeft: false,\n    position: \"\",\n    backgroundColor: \"\",\n    avatar: \"\",\n    className: \"\",\n    stopOnFocus: true,\n    onClick: function() {\n    },\n    offset: { x: 0, y: 0 },\n    escapeMarkup: true,\n    ariaLive: \"polite\",\n    style: { background: \"\" }\n  };\n  Toastify.lib = Toastify.prototype = {\n    toastify: version,\n    constructor: Toastify,\n    init: function(options) {\n      if (!options) {\n        options = {};\n      }\n      this.options = {};\n      this.toastElement = null;\n      this.options.text = options.text || Toastify.defaults.text;\n      this.options.node = options.node || Toastify.defaults.node;\n      this.options.duration = options.duration === 0 ? 0 : options.duration || Toastify.defaults.duration;\n      this.options.selector = options.selector || Toastify.defaults.selector;\n      this.options.callback = options.callback || Toastify.defaults.callback;\n      this.options.destination = options.destination || Toastify.defaults.destination;\n      this.options.newWindow = options.newWindow || Toastify.defaults.newWindow;\n      this.options.close = options.close || Toastify.defaults.close;\n      this.options.gravity = options.gravity === \"bottom\" ? \"toastify-bottom\" : Toastify.defaults.gravity;\n      this.options.positionLeft = options.positionLeft || Toastify.defaults.positionLeft;\n      this.options.position = options.position || Toastify.defaults.position;\n      this.options.backgroundColor = options.backgroundColor || Toastify.defaults.backgroundColor;\n      this.options.avatar = options.avatar || Toastify.defaults.avatar;\n      this.options.className = options.className || Toastify.defaults.className;\n      this.options.stopOnFocus = options.stopOnFocus === void 0 ? Toastify.defaults.stopOnFocus : options.stopOnFocus;\n      this.options.onClick = options.onClick || Toastify.defaults.onClick;\n      this.options.offset = options.offset || Toastify.defaults.offset;\n      this.options.escapeMarkup = options.escapeMarkup !== void 0 ? options.escapeMarkup : Toastify.defaults.escapeMarkup;\n      this.options.ariaLive = options.ariaLive || Toastify.defaults.ariaLive;\n      this.options.style = options.style || Toastify.defaults.style;\n      if (options.backgroundColor) {\n        this.options.style.background = options.backgroundColor;\n      }\n      return this;\n    },\n    buildToast: function() {\n      if (!this.options) {\n        throw \"Toastify is not initialized\";\n      }\n      var divElement = document.createElement(\"div\");\n      divElement.className = \"toastify on \" + this.options.className;\n      if (!!this.options.position) {\n        divElement.className += \" toastify-\" + this.options.position;\n      } else {\n        if (this.options.positionLeft === true) {\n          divElement.className += \" toastify-left\";\n          console.warn(\"Property `positionLeft` will be depreciated in further versions. Please use `position` instead.\");\n        } else {\n          divElement.className += \" toastify-right\";\n        }\n      }\n      divElement.className += \" \" + this.options.gravity;\n      if (this.options.backgroundColor) {\n        console.warn('DEPRECATION NOTICE: \"backgroundColor\" is being deprecated. Please use the \"style.background\" property.');\n      }\n      for (var property in this.options.style) {\n        divElement.style[property] = this.options.style[property];\n      }\n      if (this.options.ariaLive) {\n        divElement.setAttribute(\"aria-live\", this.options.ariaLive);\n      }\n      if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {\n        divElement.appendChild(this.options.node);\n      } else {\n        if (this.options.escapeMarkup) {\n          divElement.innerText = this.options.text;\n        } else {\n          divElement.innerHTML = this.options.text;\n        }\n        if (this.options.avatar !== \"\") {\n          var avatarElement = document.createElement(\"img\");\n          avatarElement.src = this.options.avatar;\n          avatarElement.className = \"toastify-avatar\";\n          if (this.options.position == \"left\" || this.options.positionLeft === true) {\n            divElement.appendChild(avatarElement);\n          } else {\n            divElement.insertAdjacentElement(\"afterbegin\", avatarElement);\n          }\n        }\n      }\n      if (this.options.close === true) {\n        var closeElement = document.createElement(\"button\");\n        closeElement.type = \"button\";\n        closeElement.setAttribute(\"aria-label\", \"Close\");\n        closeElement.className = \"toast-close\";\n        closeElement.innerHTML = \"&#10006;\";\n        closeElement.addEventListener(\n          \"click\",\n          function(event) {\n            event.stopPropagation();\n            this.removeElement(this.toastElement);\n            window.clearTimeout(this.toastElement.timeOutValue);\n          }.bind(this)\n        );\n        var width = window.innerWidth > 0 ? window.innerWidth : screen.width;\n        if ((this.options.position == \"left\" || this.options.positionLeft === true) && width > 360) {\n          divElement.insertAdjacentElement(\"afterbegin\", closeElement);\n        } else {\n          divElement.appendChild(closeElement);\n        }\n      }\n      if (this.options.stopOnFocus && this.options.duration > 0) {\n        var self = this;\n        divElement.addEventListener(\n          \"mouseover\",\n          function(event) {\n            window.clearTimeout(divElement.timeOutValue);\n          }\n        );\n        divElement.addEventListener(\n          \"mouseleave\",\n          function() {\n            divElement.timeOutValue = window.setTimeout(\n              function() {\n                self.removeElement(divElement);\n              },\n              self.options.duration\n            );\n          }\n        );\n      }\n      if (typeof this.options.destination !== \"undefined\") {\n        divElement.addEventListener(\n          \"click\",\n          function(event) {\n            event.stopPropagation();\n            if (this.options.newWindow === true) {\n              window.open(this.options.destination, \"_blank\");\n            } else {\n              window.location = this.options.destination;\n            }\n          }.bind(this)\n        );\n      }\n      if (typeof this.options.onClick === \"function\" && typeof this.options.destination === \"undefined\") {\n        divElement.addEventListener(\n          \"click\",\n          function(event) {\n            event.stopPropagation();\n            this.options.onClick();\n          }.bind(this)\n        );\n      }\n      if (typeof this.options.offset === \"object\") {\n        var x = getAxisOffsetAValue(\"x\", this.options);\n        var y = getAxisOffsetAValue(\"y\", this.options);\n        var xOffset = this.options.position == \"left\" ? x : \"-\" + x;\n        var yOffset = this.options.gravity == \"toastify-top\" ? y : \"-\" + y;\n        divElement.style.transform = \"translate(\" + xOffset + \",\" + yOffset + \")\";\n      }\n      return divElement;\n    },\n    showToast: function() {\n      this.toastElement = this.buildToast();\n      var rootElement;\n      if (typeof this.options.selector === \"string\") {\n        rootElement = document.getElementById(this.options.selector);\n      } else if (this.options.selector instanceof HTMLElement || typeof ShadowRoot !== \"undefined\" && this.options.selector instanceof ShadowRoot) {\n        rootElement = this.options.selector;\n      } else {\n        rootElement = document.body;\n      }\n      if (!rootElement) {\n        throw \"Root element is not defined\";\n      }\n      var elementToInsert = Toastify.defaults.oldestFirst ? rootElement.firstChild : rootElement.lastChild;\n      rootElement.insertBefore(this.toastElement, elementToInsert);\n      Toastify.reposition();\n      if (this.options.duration > 0) {\n        this.toastElement.timeOutValue = window.setTimeout(\n          function() {\n            this.removeElement(this.toastElement);\n          }.bind(this),\n          this.options.duration\n        );\n      }\n      return this;\n    },\n    hideToast: function() {\n      if (this.toastElement.timeOutValue) {\n        clearTimeout(this.toastElement.timeOutValue);\n      }\n      this.removeElement(this.toastElement);\n    },\n    removeElement: function(toastElement) {\n      toastElement.className = toastElement.className.replace(\" on\", \"\");\n      window.setTimeout(\n        function() {\n          if (this.options.node && this.options.node.parentNode) {\n            this.options.node.parentNode.removeChild(this.options.node);\n          }\n          if (toastElement.parentNode) {\n            toastElement.parentNode.removeChild(toastElement);\n          }\n          this.options.callback.call(toastElement);\n          Toastify.reposition();\n        }.bind(this),\n        400\n      );\n    }\n  };\n  Toastify.reposition = function() {\n    var topLeftOffsetSize = {\n      top: 15,\n      bottom: 15\n    };\n    var topRightOffsetSize = {\n      top: 15,\n      bottom: 15\n    };\n    var offsetSize = {\n      top: 15,\n      bottom: 15\n    };\n    var allToasts = document.getElementsByClassName(\"toastify\");\n    var classUsed;\n    for (var i = 0; i < allToasts.length; i++) {\n      if (containsClass(allToasts[i], \"toastify-top\") === true) {\n        classUsed = \"toastify-top\";\n      } else {\n        classUsed = \"toastify-bottom\";\n      }\n      var height = allToasts[i].offsetHeight;\n      classUsed = classUsed.substr(9, classUsed.length - 1);\n      var offset = 15;\n      var width = window.innerWidth > 0 ? window.innerWidth : screen.width;\n      if (width <= 360) {\n        allToasts[i].style[classUsed] = offsetSize[classUsed] + \"px\";\n        offsetSize[classUsed] += height + offset;\n      } else {\n        if (containsClass(allToasts[i], \"toastify-left\") === true) {\n          allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + \"px\";\n          topLeftOffsetSize[classUsed] += height + offset;\n        } else {\n          allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + \"px\";\n          topRightOffsetSize[classUsed] += height + offset;\n        }\n      }\n    }\n    return this;\n  };\n  function getAxisOffsetAValue(axis, options) {\n    if (options.offset[axis]) {\n      if (isNaN(options.offset[axis])) {\n        return options.offset[axis];\n      } else {\n        return options.offset[axis] + \"px\";\n      }\n    }\n    return \"0px\";\n  }\n  function containsClass(elem, yourClass) {\n    if (!elem || typeof yourClass !== \"string\") {\n      return false;\n    } else if (elem.className && elem.className.trim().split(/\\s+/gi).indexOf(yourClass) > -1) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  Toastify.lib.init.prototype = Toastify.lib;\n  return Toastify;\n});\n\n\n//# sourceURL=webpack://cms_git/./node_modules/toastify-js/src/toastify.js?");

/***/ }),

/***/ "./css/editor.scss":
/*!*************************!*\
  !*** ./css/editor.scss ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_editor_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!../node_modules/postcss-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./editor.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./css/editor.scss\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_editor_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_editor_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_editor_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_editor_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://cms_git/./css/editor.scss?");

/***/ }),

/***/ "./css/style.css":
/*!***********************!*\
  !*** ./css/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!../node_modules/postcss-loader/dist/cjs.js!../node_modules/sass-loader/dist/cjs.js!./style.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./css/style.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://cms_git/./css/style.css?");

/***/ }),

/***/ "./node_modules/toastify-js/src/toastify.css":
/*!***************************************************!*\
  !*** ./node_modules/toastify-js/src/toastify.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_sass_loader_dist_cjs_js_toastify_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!../../postcss-loader/dist/cjs.js!../../sass-loader/dist/cjs.js!./toastify.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./node_modules/toastify-js/src/toastify.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_sass_loader_dist_cjs_js_toastify_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_sass_loader_dist_cjs_js_toastify_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_sass_loader_dist_cjs_js_toastify_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _css_loader_dist_cjs_js_postcss_loader_dist_cjs_js_sass_loader_dist_cjs_js_toastify_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://cms_git/./node_modules/toastify-js/src/toastify.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://cms_git/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://cms_git/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://cms_git/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://cms_git/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://cms_git/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://cms_git/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./node_modules/orderedmap/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/orderedmap/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction OrderedMap(content) {\n  this.content = content;\n}\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key)\n        return i;\n    return -1;\n  },\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? void 0 : this.content[found + 1];\n  },\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey)\n        content[found] = newKey;\n    }\n    return new OrderedMap(content);\n  },\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1)\n      return this;\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content);\n  },\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content));\n  },\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content);\n  },\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content);\n  },\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size)\n      return this;\n    return new OrderedMap(map.content.concat(this.subtract(map).content));\n  },\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size)\n      return this;\n    return new OrderedMap(this.subtract(map).content.concat(map.content));\n  },\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result;\n  },\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) {\n      result[key] = value;\n    });\n    return result;\n  },\n  get size() {\n    return this.content.length >> 1;\n  }\n};\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap)\n    return value;\n  var content = [];\n  if (value)\n    for (var prop in value)\n      content.push(prop, value[prop]);\n  return new OrderedMap(content);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrderedMap);\n\n\n//# sourceURL=webpack://cms_git/./node_modules/orderedmap/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"autoJoin\": () => (/* binding */ autoJoin),\n/* harmony export */   \"baseKeymap\": () => (/* binding */ baseKeymap),\n/* harmony export */   \"chainCommands\": () => (/* binding */ chainCommands),\n/* harmony export */   \"createParagraphNear\": () => (/* binding */ createParagraphNear),\n/* harmony export */   \"deleteSelection\": () => (/* binding */ deleteSelection),\n/* harmony export */   \"exitCode\": () => (/* binding */ exitCode),\n/* harmony export */   \"joinBackward\": () => (/* binding */ joinBackward),\n/* harmony export */   \"joinDown\": () => (/* binding */ joinDown),\n/* harmony export */   \"joinForward\": () => (/* binding */ joinForward),\n/* harmony export */   \"joinUp\": () => (/* binding */ joinUp),\n/* harmony export */   \"lift\": () => (/* binding */ lift),\n/* harmony export */   \"liftEmptyBlock\": () => (/* binding */ liftEmptyBlock),\n/* harmony export */   \"macBaseKeymap\": () => (/* binding */ macBaseKeymap),\n/* harmony export */   \"newlineInCode\": () => (/* binding */ newlineInCode),\n/* harmony export */   \"pcBaseKeymap\": () => (/* binding */ pcBaseKeymap),\n/* harmony export */   \"selectAll\": () => (/* binding */ selectAll),\n/* harmony export */   \"selectNodeBackward\": () => (/* binding */ selectNodeBackward),\n/* harmony export */   \"selectNodeForward\": () => (/* binding */ selectNodeForward),\n/* harmony export */   \"selectParentNode\": () => (/* binding */ selectParentNode),\n/* harmony export */   \"selectTextblockEnd\": () => (/* binding */ selectTextblockEnd),\n/* harmony export */   \"selectTextblockStart\": () => (/* binding */ selectTextblockStart),\n/* harmony export */   \"setBlockType\": () => (/* binding */ setBlockType),\n/* harmony export */   \"splitBlock\": () => (/* binding */ splitBlock),\n/* harmony export */   \"splitBlockKeepMarks\": () => (/* binding */ splitBlockKeepMarks),\n/* harmony export */   \"toggleMark\": () => (/* binding */ toggleMark),\n/* harmony export */   \"wrapIn\": () => (/* binding */ wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\n\nconst deleteSelection = (state, dispatch) => {\n  if (state.selection.empty)\n    return false;\n  if (dispatch)\n    dispatch(state.tr.deleteSelection().scrollIntoView());\n  return true;\n};\nconst joinBackward = (state, dispatch, view) => {\n  let { $cursor } = state.selection;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0))\n    return false;\n  let $cut = findCutBefore($cursor);\n  if (!$cut) {\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n  let before = $cut.nodeBefore;\n  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))\n    return true;\n  if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n    let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(before, \"end\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch)\n      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n    return true;\n  }\n  return false;\n};\nfunction textblockAt(node, side, only = false) {\n  for (let scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild) {\n    if (scan.isTextblock)\n      return true;\n    if (only && scan.childCount != 1)\n      return false;\n  }\n  return false;\n}\nconst selectNodeBackward = (state, dispatch, view) => {\n  let { $head, empty } = state.selection, $cut = $head;\n  if (!empty)\n    return false;\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n      return false;\n    $cut = findCutBefore($head);\n  }\n  let node = $cut && $cut.nodeBefore;\n  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n  return true;\n};\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating)\n    for (let i = $pos.depth - 1; i >= 0; i--) {\n      if ($pos.index(i) > 0)\n        return $pos.doc.resolve($pos.before(i + 1));\n      if ($pos.node(i).type.spec.isolating)\n        break;\n    }\n  return null;\n}\nconst joinForward = (state, dispatch, view) => {\n  let { $cursor } = state.selection;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size))\n    return false;\n  let $cut = findCutAfter($cursor);\n  if (!$cut)\n    return false;\n  let after = $cut.nodeAfter;\n  if (deleteBarrier(state, $cut, dispatch))\n    return true;\n  if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n    let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        let tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(after, \"start\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch)\n      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n    return true;\n  }\n  return false;\n};\nconst selectNodeForward = (state, dispatch, view) => {\n  let { $head, empty } = state.selection, $cut = $head;\n  if (!empty)\n    return false;\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n      return false;\n    $cut = findCutAfter($head);\n  }\n  let node = $cut && $cut.nodeAfter;\n  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n  return true;\n};\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating)\n    for (let i = $pos.depth - 1; i >= 0; i--) {\n      let parent = $pos.node(i);\n      if ($pos.index(i) + 1 < parent.childCount)\n        return $pos.doc.resolve($pos.after(i + 1));\n      if (parent.type.spec.isolating)\n        break;\n    }\n  return null;\n}\nconst joinUp = (state, dispatch) => {\n  let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n  if (nodeSel) {\n    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from))\n      return false;\n    point = sel.from;\n  } else {\n    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n    if (point == null)\n      return false;\n  }\n  if (dispatch) {\n    let tr = state.tr.join(point);\n    if (nodeSel)\n      tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nconst joinDown = (state, dispatch) => {\n  let sel = state.selection, point;\n  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to))\n      return false;\n    point = sel.to;\n  } else {\n    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n    if (point == null)\n      return false;\n  }\n  if (dispatch)\n    dispatch(state.tr.join(point).scrollIntoView());\n  return true;\n};\nconst lift = (state, dispatch) => {\n  let { $from, $to } = state.selection;\n  let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n  if (target == null)\n    return false;\n  if (dispatch)\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\nconst newlineInCode = (state, dispatch) => {\n  let { $head, $anchor } = state.selection;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n  return true;\n};\nfunction defaultBlockAt(match) {\n  for (let i = 0; i < match.edgeCount; i++) {\n    let { type } = match.edge(i);\n    if (type.isTextblock && !type.hasRequiredAttrs())\n      return type;\n  }\n  return null;\n}\nconst exitCode = (state, dispatch) => {\n  let { $head, $anchor } = state.selection;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n    return false;\n  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n  if (!type || !above.canReplaceWith(after, after, type))\n    return false;\n  if (dispatch) {\n    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nconst createParagraphNear = (state, dispatch) => {\n  let sel = state.selection, { $from, $to } = sel;\n  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n    return false;\n  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n  if (!type || !type.isTextblock)\n    return false;\n  if (dispatch) {\n    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    let tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nconst liftEmptyBlock = (state, dispatch) => {\n  let { $cursor } = state.selection;\n  if (!$cursor || $cursor.parent.content.size)\n    return false;\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    let before = $cursor.before();\n    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n      if (dispatch)\n        dispatch(state.tr.split(before).scrollIntoView());\n      return true;\n    }\n  }\n  let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n  if (target == null)\n    return false;\n  if (dispatch)\n    dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\nconst splitBlock = (state, dispatch) => {\n  let { $from, $to } = state.selection;\n  if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n    if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.split($from.pos).scrollIntoView());\n    return true;\n  }\n  if (!$from.parent.isBlock)\n    return false;\n  if (dispatch) {\n    let atEnd = $to.parentOffset == $to.parent.content.size;\n    let tr = state.tr;\n    if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection)\n      tr.deleteSelection();\n    let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    let types = atEnd && deflt ? [{ type: deflt }] : void 0;\n    let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n    if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {\n      if (deflt)\n        types = [{ type: deflt }];\n      can = true;\n    }\n    if (can) {\n      tr.split(tr.mapping.map($from.pos), 1, types);\n      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n        let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n        if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n      }\n    }\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nconst splitBlockKeepMarks = (state, dispatch) => {\n  return splitBlock(state, dispatch && ((tr) => {\n    let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n    if (marks)\n      tr.ensureMarks(marks);\n    dispatch(tr);\n  }));\n};\nconst selectParentNode = (state, dispatch) => {\n  let { $from, to } = state.selection, pos;\n  let same = $from.sharedDepth(to);\n  if (same == 0)\n    return false;\n  pos = $from.before(same);\n  if (dispatch)\n    dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n  return true;\n};\nconst selectAll = (state, dispatch) => {\n  if (dispatch)\n    dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n  return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n  let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n  if (!before || !after || !before.type.compatibleContent(after.type))\n    return false;\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch)\n      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n    return true;\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos)))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());\n  return true;\n}\nfunction deleteBarrier(state, $cut, dispatch) {\n  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n  if (before.type.spec.isolating || after.type.spec.isolating)\n    return false;\n  if (joinMaybeClear(state, $cut, dispatch))\n    return true;\n  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n      for (let i = conn.length - 1; i >= 0; i--)\n        wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n      wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n      let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n      let joinAt = end + 2 * conn.length;\n      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt))\n        tr.join(joinAt);\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  }\n  let selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n  if (target != null && target >= $cut.depth) {\n    if (dispatch)\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    let at = before, wrap = [];\n    for (; ; ) {\n      wrap.push(at);\n      if (at.isTextblock)\n        break;\n      at = at.lastChild;\n    }\n    let afterText = after, afterDepth = 1;\n    for (; !afterText.isTextblock; afterText = afterText.firstChild)\n      afterDepth++;\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n        for (let i = wrap.length - 1; i >= 0; i--)\n          end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n        let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  return false;\n}\nfunction selectTextblockSide(side) {\n  return function(state, dispatch) {\n    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n    let depth = $pos.depth;\n    while ($pos.node(depth).isInline) {\n      if (!depth)\n        return false;\n      depth--;\n    }\n    if (!$pos.node(depth).isTextblock)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n    return true;\n  };\n}\nconst selectTextblockStart = selectTextblockSide(-1);\nconst selectTextblockEnd = selectTextblockSide(1);\nfunction wrapIn(nodeType, attrs = null) {\n  return function(state, dispatch) {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n    if (!wrapping)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n    return true;\n  };\n}\nfunction setBlockType(nodeType, attrs = null) {\n  return function(state, dispatch) {\n    let { from, to } = state.selection;\n    let applicable = false;\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (applicable)\n        return false;\n      if (!node.isTextblock || node.hasMarkup(nodeType, attrs))\n        return;\n      if (node.type == nodeType) {\n        applicable = true;\n      } else {\n        let $pos = state.doc.resolve(pos), index = $pos.index();\n        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n      }\n    });\n    if (!applicable)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());\n    return true;\n  };\n}\nfunction markApplies(doc, ranges, type) {\n  for (let i = 0; i < ranges.length; i++) {\n    let { $from, $to } = ranges[i];\n    let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n    doc.nodesBetween($from.pos, $to.pos, (node) => {\n      if (can)\n        return false;\n      can = node.inlineContent && node.type.allowsMarkType(type);\n    });\n    if (can)\n      return true;\n  }\n  return false;\n}\nfunction toggleMark(markType, attrs = null) {\n  return function(state, dispatch) {\n    let { empty, $cursor, ranges } = state.selection;\n    if (empty && !$cursor || !markApplies(state.doc, ranges, markType))\n      return false;\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks()))\n          dispatch(state.tr.removeStoredMark(markType));\n        else\n          dispatch(state.tr.addStoredMark(markType.create(attrs)));\n      } else {\n        let has = false, tr = state.tr;\n        for (let i = 0; !has && i < ranges.length; i++) {\n          let { $from, $to } = ranges[i];\n          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n        }\n        for (let i = 0; i < ranges.length; i++) {\n          let { $from, $to } = ranges[i];\n          if (has) {\n            tr.removeMark($from.pos, $to.pos, markType);\n          } else {\n            let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n            let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n            let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n            if (from + spaceStart < to) {\n              from += spaceStart;\n              to -= spaceEnd;\n            }\n            tr.addMark(from, to, markType.create(attrs));\n          }\n        }\n        dispatch(tr.scrollIntoView());\n      }\n    }\n    return true;\n  };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return (tr) => {\n    if (!tr.isGeneric)\n      return dispatch(tr);\n    let ranges = [];\n    for (let i = 0; i < tr.mapping.maps.length; i++) {\n      let map = tr.mapping.maps[i];\n      for (let j = 0; j < ranges.length; j++)\n        ranges[j] = map.map(ranges[j]);\n      map.forEach((_s, _e, from, to) => ranges.push(from, to));\n    }\n    let joinable = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from = ranges[i], to = ranges[i + 1];\n      let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n      for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        let after = parent.maybeChild(index);\n        if (!after)\n          break;\n        if (index && joinable.indexOf(pos) == -1) {\n          let before = parent.child(index - 1);\n          if (before.type == after.type && isJoinable(before, after))\n            joinable.push(pos);\n        }\n        pos += after.nodeSize;\n      }\n    }\n    joinable.sort((a, b) => a - b);\n    for (let i = joinable.length - 1; i >= 0; i--) {\n      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i]))\n        tr.join(joinable[i]);\n    }\n    dispatch(tr);\n  };\n}\nfunction autoJoin(command, isJoinable) {\n  let canJoin2 = Array.isArray(isJoinable) ? (node) => isJoinable.indexOf(node.type.name) > -1 : isJoinable;\n  return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin2), view);\n}\nfunction chainCommands(...commands) {\n  return function(state, dispatch, view) {\n    for (let i = 0; i < commands.length; i++)\n      if (commands[i](state, dispatch, view))\n        return true;\n    return false;\n  };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\nconst pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n};\nconst macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n};\nfor (let key in pcBaseKeymap)\n  macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-commands/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-dropcursor/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"dropCursor\": () => (/* binding */ dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n\n\nfunction dropCursor(options = {}) {\n  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n    view(editorView) {\n      return new DropCursorView(editorView, options);\n    }\n  });\n}\nclass DropCursorView {\n  constructor(editorView, options) {\n    this.editorView = editorView;\n    this.cursorPos = null;\n    this.element = null;\n    this.timeout = -1;\n    this.width = options.width || 1;\n    this.color = options.color || \"black\";\n    this.class = options.class;\n    this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map((name) => {\n      let handler = (e) => {\n        this[name](e);\n      };\n      editorView.dom.addEventListener(name, handler);\n      return { name, handler };\n    });\n  }\n  destroy() {\n    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));\n  }\n  update(editorView, prevState) {\n    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n      if (this.cursorPos > editorView.state.doc.content.size)\n        this.setCursor(null);\n      else\n        this.updateOverlay();\n    }\n  }\n  setCursor(pos) {\n    if (pos == this.cursorPos)\n      return;\n    this.cursorPos = pos;\n    if (pos == null) {\n      this.element.parentNode.removeChild(this.element);\n      this.element = null;\n    } else {\n      this.updateOverlay();\n    }\n  }\n  updateOverlay() {\n    let $pos = this.editorView.state.doc.resolve(this.cursorPos), rect;\n    if (!$pos.parent.inlineContent) {\n      let before = $pos.nodeBefore, after = $pos.nodeAfter;\n      if (before || after) {\n        let nodeRect = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0)).getBoundingClientRect();\n        let top = before ? nodeRect.bottom : nodeRect.top;\n        if (before && after)\n          top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;\n        rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };\n      }\n    }\n    if (!rect) {\n      let coords = this.editorView.coordsAtPos(this.cursorPos);\n      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };\n    }\n    let parent = this.editorView.dom.offsetParent;\n    if (!this.element) {\n      this.element = parent.appendChild(document.createElement(\"div\"));\n      if (this.class)\n        this.element.className = this.class;\n      this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none; background-color: \" + this.color;\n    }\n    let parentLeft, parentTop;\n    if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n      parentLeft = -pageXOffset;\n      parentTop = -pageYOffset;\n    } else {\n      let rect2 = parent.getBoundingClientRect();\n      parentLeft = rect2.left - parent.scrollLeft;\n      parentTop = rect2.top - parent.scrollTop;\n    }\n    this.element.style.left = rect.left - parentLeft + \"px\";\n    this.element.style.top = rect.top - parentTop + \"px\";\n    this.element.style.width = rect.right - rect.left + \"px\";\n    this.element.style.height = rect.bottom - rect.top + \"px\";\n  }\n  scheduleRemoval(timeout) {\n    clearTimeout(this.timeout);\n    this.timeout = setTimeout(() => this.setCursor(null), timeout);\n  }\n  dragover(event) {\n    if (!this.editorView.editable)\n      return;\n    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });\n    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);\n    let disableDropCursor = node && node.type.spec.disableDropCursor;\n    let disabled = typeof disableDropCursor == \"function\" ? disableDropCursor(this.editorView, pos) : disableDropCursor;\n    if (pos && !disabled) {\n      let target = pos.pos;\n      if (this.editorView.dragging && this.editorView.dragging.slice) {\n        target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.dropPoint)(this.editorView.state.doc, target, this.editorView.dragging.slice);\n        if (target == null)\n          return this.setCursor(null);\n      }\n      this.setCursor(target);\n      this.scheduleRemoval(5e3);\n    }\n  }\n  dragend() {\n    this.scheduleRemoval(20);\n  }\n  drop() {\n    this.scheduleRemoval(20);\n  }\n  dragleave(event) {\n    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))\n      this.setCursor(null);\n  }\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-dropcursor/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-gapcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GapCursor\": () => (/* binding */ GapCursor),\n/* harmony export */   \"gapCursor\": () => (/* binding */ gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ \"./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-view */ \"./node_modules/prosemirror-view/dist/index.js\");\n\n\n\n\nclass GapCursor extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n  constructor($pos) {\n    super($pos, $pos);\n  }\n  map(doc, mapping) {\n    let $pos = doc.resolve(mapping.map(this.head));\n    return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n  }\n  content() {\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty;\n  }\n  eq(other) {\n    return other instanceof GapCursor && other.head == this.head;\n  }\n  toJSON() {\n    return { type: \"gapcursor\", pos: this.head };\n  }\n  static fromJSON(doc, json) {\n    if (typeof json.pos != \"number\")\n      throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n    return new GapCursor(doc.resolve(json.pos));\n  }\n  getBookmark() {\n    return new GapBookmark(this.anchor);\n  }\n  static valid($pos) {\n    let parent = $pos.parent;\n    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n      return false;\n    let override = parent.type.spec.allowGapCursor;\n    if (override != null)\n      return override;\n    let deflt = parent.contentMatchAt($pos.index()).defaultType;\n    return deflt && deflt.isTextblock;\n  }\n  static findGapCursorFrom($pos, dir, mustMove = false) {\n    search:\n      for (; ; ) {\n        if (!mustMove && GapCursor.valid($pos))\n          return $pos;\n        let pos = $pos.pos, next = null;\n        for (let d = $pos.depth; ; d--) {\n          let parent = $pos.node(d);\n          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n            break;\n          } else if (d == 0) {\n            return null;\n          }\n          pos += dir;\n          let $cur = $pos.doc.resolve(pos);\n          if (GapCursor.valid($cur))\n            return $cur;\n        }\n        for (; ; ) {\n          let inside = dir > 0 ? next.firstChild : next.lastChild;\n          if (!inside) {\n            if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(next)) {\n              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n              mustMove = false;\n              continue search;\n            }\n            break;\n          }\n          next = inside;\n          pos += dir;\n          let $cur = $pos.doc.resolve(pos);\n          if (GapCursor.valid($cur))\n            return $cur;\n        }\n        return null;\n      }\n  }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n  constructor(pos) {\n    this.pos = pos;\n  }\n  map(mapping) {\n    return new GapBookmark(mapping.map(this.pos));\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.pos);\n    return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n  }\n}\nfunction closedBefore($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.index(d), parent = $pos.node(d);\n    if (index == 0) {\n      if (parent.type.spec.isolating)\n        return true;\n      continue;\n    }\n    for (let before = parent.child(index - 1); ; before = before.lastChild) {\n      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)\n        return true;\n      if (before.inlineContent)\n        return false;\n    }\n  }\n  return true;\n}\nfunction closedAfter($pos) {\n  for (let d = $pos.depth; d >= 0; d--) {\n    let index = $pos.indexAfter(d), parent = $pos.node(d);\n    if (index == parent.childCount) {\n      if (parent.type.spec.isolating)\n        return true;\n      continue;\n    }\n    for (let after = parent.child(index); ; after = after.firstChild) {\n      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)\n        return true;\n      if (after.inlineContent)\n        return false;\n    }\n  }\n  return true;\n}\nfunction gapCursor() {\n  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n    props: {\n      decorations: drawGapCursor,\n      createSelectionBetween(_view, $anchor, $head) {\n        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n      },\n      handleClick,\n      handleKeyDown,\n      handleDOMEvents: { beforeinput }\n    }\n  });\n}\nconst handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keydownHandler)({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n  const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n  return function(state, dispatch, view) {\n    let sel = state.selection;\n    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n        return false;\n      mustMove = false;\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n    }\n    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n    if (!$found)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.setSelection(new GapCursor($found)));\n    return true;\n  };\n}\nfunction handleClick(view, pos, event) {\n  if (!view || !view.editable)\n    return false;\n  let $pos = view.state.doc.resolve(pos);\n  if (!GapCursor.valid($pos))\n    return false;\n  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n  if (clickPos && clickPos.inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n    return false;\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n  return true;\n}\nfunction beforeinput(view, event) {\n  if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n    return false;\n  let { $from } = view.state.selection;\n  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n  if (!insert)\n    return false;\n  let frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n  for (let i = insert.length - 1; i >= 0; i--)\n    frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(insert[i].createAndFill(null, frag));\n  let tr = view.state.tr.replace($from.pos, $from.pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(frag, 0, 0));\n  tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve($from.pos + 1)));\n  view.dispatch(tr);\n  return false;\n}\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor))\n    return null;\n  let node = document.createElement(\"div\");\n  node.className = \"ProseMirror-gapcursor\";\n  return prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-gapcursor/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"closeHistory\": () => (/* binding */ closeHistory),\n/* harmony export */   \"history\": () => (/* binding */ history),\n/* harmony export */   \"redo\": () => (/* binding */ redo),\n/* harmony export */   \"redoDepth\": () => (/* binding */ redoDepth),\n/* harmony export */   \"undo\": () => (/* binding */ undo),\n/* harmony export */   \"undoDepth\": () => (/* binding */ undoDepth)\n/* harmony export */ });\n/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ \"./node_modules/rope-sequence/dist/index.es.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\n\nconst max_empty_items = 500;\nclass Branch {\n  constructor(items, eventCount) {\n    this.items = items;\n    this.eventCount = eventCount;\n  }\n  popEvent(state, preserveItems) {\n    if (this.eventCount == 0)\n      return null;\n    let end = this.items.length;\n    for (; ; end--) {\n      let next = this.items.get(end - 1);\n      if (next.selection) {\n        --end;\n        break;\n      }\n    }\n    let remap, mapFrom;\n    if (preserveItems) {\n      remap = this.remapping(end, this.items.length);\n      mapFrom = remap.maps.length;\n    }\n    let transform = state.tr;\n    let selection, remaining;\n    let addAfter = [], addBefore = [];\n    this.items.forEach((item, i) => {\n      if (!item.step) {\n        if (!remap) {\n          remap = this.remapping(end, i + 1);\n          mapFrom = remap.maps.length;\n        }\n        mapFrom--;\n        addBefore.push(item);\n        return;\n      }\n      if (remap) {\n        addBefore.push(new Item(item.map));\n        let step = item.step.map(remap.slice(mapFrom)), map;\n        if (step && transform.maybeStep(step).doc) {\n          map = transform.mapping.maps[transform.mapping.maps.length - 1];\n          addAfter.push(new Item(map, void 0, void 0, addAfter.length + addBefore.length));\n        }\n        mapFrom--;\n        if (map)\n          remap.appendMap(map, mapFrom);\n      } else {\n        transform.maybeStep(item.step);\n      }\n      if (item.selection) {\n        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n        return false;\n      }\n    }, this.items.length, 0);\n    return { remaining, transform, selection };\n  }\n  addTransform(transform, selection, histOptions, preserveItems) {\n    let newItems = [], eventCount = this.eventCount;\n    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n    for (let i = 0; i < transform.steps.length; i++) {\n      let step = transform.steps[i].invert(transform.docs[i]);\n      let item = new Item(transform.mapping.maps[i], step, selection), merged;\n      if (merged = lastItem && lastItem.merge(item)) {\n        item = merged;\n        if (i)\n          newItems.pop();\n        else\n          oldItems = oldItems.slice(0, oldItems.length - 1);\n      }\n      newItems.push(item);\n      if (selection) {\n        eventCount++;\n        selection = void 0;\n      }\n      if (!preserveItems)\n        lastItem = item;\n    }\n    let overflow = eventCount - histOptions.depth;\n    if (overflow > DEPTH_OVERFLOW) {\n      oldItems = cutOffEvents(oldItems, overflow);\n      eventCount -= overflow;\n    }\n    return new Branch(oldItems.append(newItems), eventCount);\n  }\n  remapping(from, to) {\n    let maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping();\n    this.items.forEach((item, i) => {\n      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : void 0;\n      maps.appendMap(item.map, mirrorPos);\n    }, from, to);\n    return maps;\n  }\n  addMaps(array) {\n    if (this.eventCount == 0)\n      return this;\n    return new Branch(this.items.append(array.map((map) => new Item(map))), this.eventCount);\n  }\n  rebased(rebasedTransform, rebasedCount) {\n    if (!this.eventCount)\n      return this;\n    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n    let mapping = rebasedTransform.mapping;\n    let newUntil = rebasedTransform.steps.length;\n    let eventCount = this.eventCount;\n    this.items.forEach((item) => {\n      if (item.selection)\n        eventCount--;\n    }, start);\n    let iRebased = rebasedCount;\n    this.items.forEach((item) => {\n      let pos = mapping.getMirror(--iRebased);\n      if (pos == null)\n        return;\n      newUntil = Math.min(newUntil, pos);\n      let map = mapping.maps[pos];\n      if (item.step) {\n        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n        if (selection)\n          eventCount++;\n        rebasedItems.push(new Item(map, step, selection));\n      } else {\n        rebasedItems.push(new Item(map));\n      }\n    }, start);\n    let newMaps = [];\n    for (let i = rebasedCount; i < newUntil; i++)\n      newMaps.push(new Item(mapping.maps[i]));\n    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n    let branch = new Branch(items, eventCount);\n    if (branch.emptyItemCount() > max_empty_items)\n      branch = branch.compress(this.items.length - rebasedItems.length);\n    return branch;\n  }\n  emptyItemCount() {\n    let count = 0;\n    this.items.forEach((item) => {\n      if (!item.step)\n        count++;\n    });\n    return count;\n  }\n  compress(upto = this.items.length) {\n    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n    let items = [], events = 0;\n    this.items.forEach((item, i) => {\n      if (i >= upto) {\n        items.push(item);\n        if (item.selection)\n          events++;\n      } else if (item.step) {\n        let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n        mapFrom--;\n        if (map)\n          remap.appendMap(map, mapFrom);\n        if (step) {\n          let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n          if (selection)\n            events++;\n          let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n          if (merged = items.length && items[last].merge(newItem))\n            items[last] = merged;\n          else\n            items.push(newItem);\n        }\n      } else if (item.map) {\n        mapFrom--;\n      }\n    }, this.items.length, 0);\n    return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(items.reverse()), events);\n  }\n}\nBranch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty, 0);\nfunction cutOffEvents(items, n) {\n  let cutPoint;\n  items.forEach((item, i) => {\n    if (item.selection && n-- == 0) {\n      cutPoint = i;\n      return false;\n    }\n  });\n  return items.slice(cutPoint);\n}\nclass Item {\n  constructor(map, step, selection, mirrorOffset) {\n    this.map = map;\n    this.step = step;\n    this.selection = selection;\n    this.mirrorOffset = mirrorOffset;\n  }\n  merge(other) {\n    if (this.step && other.step && !other.selection) {\n      let step = other.step.merge(this.step);\n      if (step)\n        return new Item(step.getMap().invert(), step, this.selection);\n    }\n  }\n}\nclass HistoryState {\n  constructor(done, undone, prevRanges, prevTime) {\n    this.done = done;\n    this.undone = undone;\n    this.prevRanges = prevRanges;\n    this.prevTime = prevTime;\n  }\n}\nconst DEPTH_OVERFLOW = 20;\nfunction applyTransaction(history2, state, tr, options) {\n  let historyTr = tr.getMeta(historyKey), rebased;\n  if (historyTr)\n    return historyTr.historyState;\n  if (tr.getMeta(closeHistoryKey))\n    history2 = new HistoryState(history2.done, history2.undone, null, 0);\n  let appended = tr.getMeta(\"appendedTransaction\");\n  if (tr.steps.length == 0) {\n    return history2;\n  } else if (appended && appended.getMeta(historyKey)) {\n    if (appended.getMeta(historyKey).redo)\n      return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime);\n    else\n      return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime);\n  } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n    let newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));\n    let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);\n  } else if (rebased = tr.getMeta(\"rebased\")) {\n    return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);\n  } else {\n    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);\n  }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n  if (!prevRanges)\n    return false;\n  if (!transform.docChanged)\n    return true;\n  let adjacent = false;\n  transform.mapping.maps[0].forEach((start, end) => {\n    for (let i = 0; i < prevRanges.length; i += 2)\n      if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n        adjacent = true;\n  });\n  return adjacent;\n}\nfunction rangesFor(map) {\n  let result = [];\n  map.forEach((_from, _to, from, to) => result.push(from, to));\n  return result;\n}\nfunction mapRanges(ranges, mapping) {\n  if (!ranges)\n    return null;\n  let result = [];\n  for (let i = 0; i < ranges.length; i += 2) {\n    let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n    if (from <= to)\n      result.push(from, to);\n  }\n  return result;\n}\nfunction histTransaction(history2, state, dispatch, redo2) {\n  let preserveItems = mustPreserveItems(state);\n  let histOptions = historyKey.get(state).spec.config;\n  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);\n  if (!pop)\n    return;\n  let selection = pop.selection.resolve(pop.transform.doc);\n  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);\n  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\nfunction mustPreserveItems(state) {\n  let plugins = state.plugins;\n  if (cachedPreserveItemsPlugins != plugins) {\n    cachedPreserveItems = false;\n    cachedPreserveItemsPlugins = plugins;\n    for (let i = 0; i < plugins.length; i++)\n      if (plugins[i].spec.historyPreserveItems) {\n        cachedPreserveItems = true;\n        break;\n      }\n  }\n  return cachedPreserveItems;\n}\nfunction closeHistory(tr) {\n  return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"history\");\nconst closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"closeHistory\");\nfunction history(config = {}) {\n  config = {\n    depth: config.depth || 100,\n    newGroupDelay: config.newGroupDelay || 500\n  };\n  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n    key: historyKey,\n    state: {\n      init() {\n        return new HistoryState(Branch.empty, Branch.empty, null, 0);\n      },\n      apply(tr, hist, state) {\n        return applyTransaction(hist, state, tr, config);\n      }\n    },\n    config,\n    props: {\n      handleDOMEvents: {\n        beforeinput(view, e) {\n          let inputType = e.inputType;\n          let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n          if (!command)\n            return false;\n          e.preventDefault();\n          return command(view.state, view.dispatch);\n        }\n      }\n    }\n  });\n}\nconst undo = (state, dispatch) => {\n  let hist = historyKey.getState(state);\n  if (!hist || hist.done.eventCount == 0)\n    return false;\n  if (dispatch)\n    histTransaction(hist, state, dispatch, false);\n  return true;\n};\nconst redo = (state, dispatch) => {\n  let hist = historyKey.getState(state);\n  if (!hist || hist.undone.eventCount == 0)\n    return false;\n  if (dispatch)\n    histTransaction(hist, state, dispatch, true);\n  return true;\n};\nfunction undoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.done.eventCount : 0;\n}\nfunction redoDepth(state) {\n  let hist = historyKey.getState(state);\n  return hist ? hist.undone.eventCount : 0;\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-history/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-keymap/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"keydownHandler\": () => (/* binding */ keydownHandler),\n/* harmony export */   \"keymap\": () => (/* binding */ keymap)\n/* harmony export */ });\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ \"./node_modules/w3c-keyname/index.es.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n  if (result == \"Space\")\n    result = \" \";\n  let alt, ctrl, shift, meta;\n  for (let i = 0; i < parts.length - 1; i++) {\n    let mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod))\n      meta = true;\n    else if (/^a(lt)?$/i.test(mod))\n      alt = true;\n    else if (/^(c|ctrl|control)$/i.test(mod))\n      ctrl = true;\n    else if (/^s(hift)?$/i.test(mod))\n      shift = true;\n    else if (/^mod$/i.test(mod)) {\n      if (mac)\n        meta = true;\n      else\n        ctrl = true;\n    } else\n      throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n  if (alt)\n    result = \"Alt-\" + result;\n  if (ctrl)\n    result = \"Ctrl-\" + result;\n  if (meta)\n    result = \"Meta-\" + result;\n  if (shift)\n    result = \"Shift-\" + result;\n  return result;\n}\nfunction normalize(map) {\n  let copy = /* @__PURE__ */ Object.create(null);\n  for (let prop in map)\n    copy[normalizeKeyName(prop)] = map[prop];\n  return copy;\n}\nfunction modifiers(name, event, shift) {\n  if (event.altKey)\n    name = \"Alt-\" + name;\n  if (event.ctrlKey)\n    name = \"Ctrl-\" + name;\n  if (event.metaKey)\n    name = \"Meta-\" + name;\n  if (shift !== false && event.shiftKey)\n    name = \"Shift-\" + name;\n  return name;\n}\nfunction keymap(bindings) {\n  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n}\nfunction keydownHandler(bindings) {\n  let map = normalize(bindings);\n  return function(view, event) {\n    let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event), isChar = name.length == 1 && name != \" \", baseName;\n    let direct = map[modifiers(name, event, !isChar)];\n    if (direct && direct(view.state, view.dispatch, view))\n      return true;\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {\n      let fromCode = map[modifiers(baseName, event, true)];\n      if (fromCode && fromCode(view.state, view.dispatch, view))\n        return true;\n    } else if (isChar && event.shiftKey) {\n      let withShift = map[modifiers(name, event, true)];\n      if (withShift && withShift(view.state, view.dispatch, view))\n        return true;\n    }\n    return false;\n  };\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-keymap/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ContentMatch\": () => (/* binding */ ContentMatch),\n/* harmony export */   \"DOMParser\": () => (/* binding */ DOMParser),\n/* harmony export */   \"DOMSerializer\": () => (/* binding */ DOMSerializer),\n/* harmony export */   \"Fragment\": () => (/* binding */ Fragment),\n/* harmony export */   \"Mark\": () => (/* binding */ Mark),\n/* harmony export */   \"MarkType\": () => (/* binding */ MarkType),\n/* harmony export */   \"Node\": () => (/* binding */ Node),\n/* harmony export */   \"NodeRange\": () => (/* binding */ NodeRange),\n/* harmony export */   \"NodeType\": () => (/* binding */ NodeType),\n/* harmony export */   \"ReplaceError\": () => (/* binding */ ReplaceError),\n/* harmony export */   \"ResolvedPos\": () => (/* binding */ ResolvedPos),\n/* harmony export */   \"Schema\": () => (/* binding */ Schema),\n/* harmony export */   \"Slice\": () => (/* binding */ Slice)\n/* harmony export */ });\n/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ \"./node_modules/orderedmap/dist/index.js\");\n\nfunction findDiffStart(a, b, pos) {\n  for (let i = 0; ; i++) {\n    if (i == a.childCount || i == b.childCount)\n      return a.childCount == b.childCount ? null : pos;\n    let childA = a.child(i), childB = b.child(i);\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n    if (!childA.sameMarkup(childB))\n      return pos;\n    if (childA.isText && childA.text != childB.text) {\n      for (let j = 0; childA.text[j] == childB.text[j]; j++)\n        pos++;\n      return pos;\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null)\n        return inner;\n    }\n    pos += childA.nodeSize;\n  }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n  for (let iA = a.childCount, iB = b.childCount; ; ) {\n    if (iA == 0 || iB == 0)\n      return iA == iB ? null : { a: posA, b: posB };\n    let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n    if (!childA.sameMarkup(childB))\n      return { a: posA, b: posB };\n    if (childA.isText && childA.text != childB.text) {\n      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n      return { a: posA, b: posB };\n    }\n    if (childA.content.size || childB.content.size) {\n      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner)\n        return inner;\n    }\n    posA -= size;\n    posB -= size;\n  }\n}\nclass Fragment {\n  constructor(content, size) {\n    this.content = content;\n    this.size = size || 0;\n    if (size == null)\n      for (let i = 0; i < content.length; i++)\n        this.size += content[i].nodeSize;\n  }\n  nodesBetween(from, to, f, nodeStart = 0, parent) {\n    for (let i = 0, pos = 0; pos < to; i++) {\n      let child = this.content[i], end = pos + child.nodeSize;\n      if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n        let start = pos + 1;\n        child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n      }\n      pos = end;\n    }\n  }\n  descendants(f) {\n    this.nodesBetween(0, this.size, f);\n  }\n  textBetween(from, to, blockSeparator, leafText) {\n    let text = \"\", separated = true;\n    this.nodesBetween(from, to, (node, pos) => {\n      if (node.isText) {\n        text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n        separated = !blockSeparator;\n      } else if (node.isLeaf) {\n        if (leafText) {\n          text += typeof leafText === \"function\" ? leafText(node) : leafText;\n        } else if (node.type.spec.leafText) {\n          text += node.type.spec.leafText(node);\n        }\n        separated = !blockSeparator;\n      } else if (!separated && node.isBlock) {\n        text += blockSeparator;\n        separated = true;\n      }\n    }, 0);\n    return text;\n  }\n  append(other) {\n    if (!other.size)\n      return this;\n    if (!this.size)\n      return other;\n    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n    if (last.isText && last.sameMarkup(first)) {\n      content[content.length - 1] = last.withText(last.text + first.text);\n      i = 1;\n    }\n    for (; i < other.content.length; i++)\n      content.push(other.content[i]);\n    return new Fragment(content, this.size + other.size);\n  }\n  cut(from, to = this.size) {\n    if (from == 0 && to == this.size)\n      return this;\n    let result = [], size = 0;\n    if (to > from)\n      for (let i = 0, pos = 0; pos < to; i++) {\n        let child = this.content[i], end = pos + child.nodeSize;\n        if (end > from) {\n          if (pos < from || end > to) {\n            if (child.isText)\n              child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n            else\n              child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n          result.push(child);\n          size += child.nodeSize;\n        }\n        pos = end;\n      }\n    return new Fragment(result, size);\n  }\n  cutByIndex(from, to) {\n    if (from == to)\n      return Fragment.empty;\n    if (from == 0 && to == this.content.length)\n      return this;\n    return new Fragment(this.content.slice(from, to));\n  }\n  replaceChild(index, node) {\n    let current = this.content[index];\n    if (current == node)\n      return this;\n    let copy2 = this.content.slice();\n    let size = this.size + node.nodeSize - current.nodeSize;\n    copy2[index] = node;\n    return new Fragment(copy2, size);\n  }\n  addToStart(node) {\n    return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n  }\n  addToEnd(node) {\n    return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n  }\n  eq(other) {\n    if (this.content.length != other.content.length)\n      return false;\n    for (let i = 0; i < this.content.length; i++)\n      if (!this.content[i].eq(other.content[i]))\n        return false;\n    return true;\n  }\n  get firstChild() {\n    return this.content.length ? this.content[0] : null;\n  }\n  get lastChild() {\n    return this.content.length ? this.content[this.content.length - 1] : null;\n  }\n  get childCount() {\n    return this.content.length;\n  }\n  child(index) {\n    let found2 = this.content[index];\n    if (!found2)\n      throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n    return found2;\n  }\n  maybeChild(index) {\n    return this.content[index] || null;\n  }\n  forEach(f) {\n    for (let i = 0, p = 0; i < this.content.length; i++) {\n      let child = this.content[i];\n      f(child, p, i);\n      p += child.nodeSize;\n    }\n  }\n  findDiffStart(other, pos = 0) {\n    return findDiffStart(this, other, pos);\n  }\n  findDiffEnd(other, pos = this.size, otherPos = other.size) {\n    return findDiffEnd(this, other, pos, otherPos);\n  }\n  findIndex(pos, round = -1) {\n    if (pos == 0)\n      return retIndex(0, pos);\n    if (pos == this.size)\n      return retIndex(this.content.length, pos);\n    if (pos > this.size || pos < 0)\n      throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n    for (let i = 0, curPos = 0; ; i++) {\n      let cur = this.child(i), end = curPos + cur.nodeSize;\n      if (end >= pos) {\n        if (end == pos || round > 0)\n          return retIndex(i + 1, end);\n        return retIndex(i, curPos);\n      }\n      curPos = end;\n    }\n  }\n  toString() {\n    return \"<\" + this.toStringInner() + \">\";\n  }\n  toStringInner() {\n    return this.content.join(\", \");\n  }\n  toJSON() {\n    return this.content.length ? this.content.map((n) => n.toJSON()) : null;\n  }\n  static fromJSON(schema, value) {\n    if (!value)\n      return Fragment.empty;\n    if (!Array.isArray(value))\n      throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n    return new Fragment(value.map(schema.nodeFromJSON));\n  }\n  static fromArray(array) {\n    if (!array.length)\n      return Fragment.empty;\n    let joined, size = 0;\n    for (let i = 0; i < array.length; i++) {\n      let node = array[i];\n      size += node.nodeSize;\n      if (i && node.isText && array[i - 1].sameMarkup(node)) {\n        if (!joined)\n          joined = array.slice(0, i);\n        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n      } else if (joined) {\n        joined.push(node);\n      }\n    }\n    return new Fragment(joined || array, size);\n  }\n  static from(nodes) {\n    if (!nodes)\n      return Fragment.empty;\n    if (nodes instanceof Fragment)\n      return nodes;\n    if (Array.isArray(nodes))\n      return this.fromArray(nodes);\n    if (nodes.attrs)\n      return new Fragment([nodes], nodes.nodeSize);\n    throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n  }\n}\nFragment.empty = new Fragment([], 0);\nconst found = { index: 0, offset: 0 };\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n}\nfunction compareDeep(a, b) {\n  if (a === b)\n    return true;\n  if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\"))\n    return false;\n  let array = Array.isArray(a);\n  if (Array.isArray(b) != array)\n    return false;\n  if (array) {\n    if (a.length != b.length)\n      return false;\n    for (let i = 0; i < a.length; i++)\n      if (!compareDeep(a[i], b[i]))\n        return false;\n  } else {\n    for (let p in a)\n      if (!(p in b) || !compareDeep(a[p], b[p]))\n        return false;\n    for (let p in b)\n      if (!(p in a))\n        return false;\n  }\n  return true;\n}\nclass Mark {\n  constructor(type, attrs) {\n    this.type = type;\n    this.attrs = attrs;\n  }\n  addToSet(set) {\n    let copy2, placed = false;\n    for (let i = 0; i < set.length; i++) {\n      let other = set[i];\n      if (this.eq(other))\n        return set;\n      if (this.type.excludes(other.type)) {\n        if (!copy2)\n          copy2 = set.slice(0, i);\n      } else if (other.type.excludes(this.type)) {\n        return set;\n      } else {\n        if (!placed && other.type.rank > this.type.rank) {\n          if (!copy2)\n            copy2 = set.slice(0, i);\n          copy2.push(this);\n          placed = true;\n        }\n        if (copy2)\n          copy2.push(other);\n      }\n    }\n    if (!copy2)\n      copy2 = set.slice();\n    if (!placed)\n      copy2.push(this);\n    return copy2;\n  }\n  removeFromSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return set.slice(0, i).concat(set.slice(i + 1));\n    return set;\n  }\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (this.eq(set[i]))\n        return true;\n    return false;\n  }\n  eq(other) {\n    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n  }\n  toJSON() {\n    let obj = { type: this.type.name };\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs;\n      break;\n    }\n    return obj;\n  }\n  static fromJSON(schema, json) {\n    if (!json)\n      throw new RangeError(\"Invalid input for Mark.fromJSON\");\n    let type = schema.marks[json.type];\n    if (!type)\n      throw new RangeError(`There is no mark type ${json.type} in this schema`);\n    return type.create(json.attrs);\n  }\n  static sameSet(a, b) {\n    if (a == b)\n      return true;\n    if (a.length != b.length)\n      return false;\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].eq(b[i]))\n        return false;\n    return true;\n  }\n  static setFrom(marks) {\n    if (!marks || Array.isArray(marks) && marks.length == 0)\n      return Mark.none;\n    if (marks instanceof Mark)\n      return [marks];\n    let copy2 = marks.slice();\n    copy2.sort((a, b) => a.type.rank - b.type.rank);\n    return copy2;\n  }\n}\nMark.none = [];\nclass ReplaceError extends Error {\n}\nclass Slice {\n  constructor(content, openStart, openEnd) {\n    this.content = content;\n    this.openStart = openStart;\n    this.openEnd = openEnd;\n  }\n  get size() {\n    return this.content.size - this.openStart - this.openEnd;\n  }\n  insertAt(pos, fragment) {\n    let content = insertInto(this.content, pos + this.openStart, fragment);\n    return content && new Slice(content, this.openStart, this.openEnd);\n  }\n  removeBetween(from, to) {\n    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n  }\n  eq(other) {\n    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n  }\n  toString() {\n    return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n  }\n  toJSON() {\n    if (!this.content.size)\n      return null;\n    let json = { content: this.content.toJSON() };\n    if (this.openStart > 0)\n      json.openStart = this.openStart;\n    if (this.openEnd > 0)\n      json.openEnd = this.openEnd;\n    return json;\n  }\n  static fromJSON(schema, json) {\n    if (!json)\n      return Slice.empty;\n    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n    if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n      throw new RangeError(\"Invalid input for Slice.fromJSON\");\n    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n  }\n  static maxOpen(fragment, openIsolating = true) {\n    let openStart = 0, openEnd = 0;\n    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)\n      openStart++;\n    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)\n      openEnd++;\n    return new Slice(fragment, openStart, openEnd);\n  }\n}\nSlice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n  let { index, offset } = content.findIndex(from), child = content.maybeChild(index);\n  let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText)\n      throw new RangeError(\"Removing non-flat range\");\n    return content.cut(0, from).append(content.cut(to));\n  }\n  if (index != indexTo)\n    throw new RangeError(\"Removing non-flat range\");\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n  let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert))\n      return null;\n    return content.cut(0, dist).append(insert).append(content.cut(dist));\n  }\n  let inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction replace($from, $to, slice) {\n  if (slice.openStart > $from.depth)\n    throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n    throw new ReplaceError(\"Inconsistent open depths\");\n  return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n  let index = $from.index(depth), node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    let inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth));\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n    let parent = $from.parent, content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n  } else {\n    let { start, end } = prepareSliceForReplace(slice, $from);\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  }\n}\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type))\n    throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n  let node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\nfunction addNode(child, target) {\n  let last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n    target[last] = child.withText(target[last].text + child.text);\n  else\n    target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n  let node = ($end || $start).node(depth);\n  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (let i = startIndex; i < endIndex; i++)\n    addNode(node.child(i), target);\n  if ($end && $end.depth == depth && $end.textOffset)\n    addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n  if (!node.type.validContent(content))\n    throw new ReplaceError(\"Invalid content for node \" + node.type.name);\n  return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n  let content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart)\n      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n    addRange($start, $end, depth, content);\n    if (openEnd)\n      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n  let content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    let type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n  let extra = $along.depth - slice.openStart, parent = $along.node(extra);\n  let node = parent.copy(slice.content);\n  for (let i = extra - 1; i >= 0; i--)\n    node = $along.node(i).copy(Fragment.from(node));\n  return {\n    start: node.resolveNoCache(slice.openStart + extra),\n    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n  };\n}\nclass ResolvedPos {\n  constructor(pos, path, parentOffset) {\n    this.pos = pos;\n    this.path = path;\n    this.parentOffset = parentOffset;\n    this.depth = path.length / 3 - 1;\n  }\n  resolveDepth(val) {\n    if (val == null)\n      return this.depth;\n    if (val < 0)\n      return this.depth + val;\n    return val;\n  }\n  get parent() {\n    return this.node(this.depth);\n  }\n  get doc() {\n    return this.node(0);\n  }\n  node(depth) {\n    return this.path[this.resolveDepth(depth) * 3];\n  }\n  index(depth) {\n    return this.path[this.resolveDepth(depth) * 3 + 1];\n  }\n  indexAfter(depth) {\n    depth = this.resolveDepth(depth);\n    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n  }\n  start(depth) {\n    depth = this.resolveDepth(depth);\n    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n  }\n  end(depth) {\n    depth = this.resolveDepth(depth);\n    return this.start(depth) + this.node(depth).content.size;\n  }\n  before(depth) {\n    depth = this.resolveDepth(depth);\n    if (!depth)\n      throw new RangeError(\"There is no position before the top-level node\");\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n  }\n  after(depth) {\n    depth = this.resolveDepth(depth);\n    if (!depth)\n      throw new RangeError(\"There is no position after the top-level node\");\n    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n  }\n  get textOffset() {\n    return this.pos - this.path[this.path.length - 1];\n  }\n  get nodeAfter() {\n    let parent = this.parent, index = this.index(this.depth);\n    if (index == parent.childCount)\n      return null;\n    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n    return dOff ? parent.child(index).cut(dOff) : child;\n  }\n  get nodeBefore() {\n    let index = this.index(this.depth);\n    let dOff = this.pos - this.path[this.path.length - 1];\n    if (dOff)\n      return this.parent.child(index).cut(0, dOff);\n    return index == 0 ? null : this.parent.child(index - 1);\n  }\n  posAtIndex(index, depth) {\n    depth = this.resolveDepth(depth);\n    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    for (let i = 0; i < index; i++)\n      pos += node.child(i).nodeSize;\n    return pos;\n  }\n  marks() {\n    let parent = this.parent, index = this.index();\n    if (parent.content.size == 0)\n      return Mark.none;\n    if (this.textOffset)\n      return parent.child(index).marks;\n    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n    if (!main) {\n      let tmp = main;\n      main = other;\n      other = tmp;\n    }\n    let marks = main.marks;\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n        marks = marks[i--].removeFromSet(marks);\n    return marks;\n  }\n  marksAcross($end) {\n    let after = this.parent.maybeChild(this.index());\n    if (!after || !after.isInline)\n      return null;\n    let marks = after.marks, next = $end.parent.maybeChild($end.index());\n    for (var i = 0; i < marks.length; i++)\n      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n        marks = marks[i--].removeFromSet(marks);\n    return marks;\n  }\n  sharedDepth(pos) {\n    for (let depth = this.depth; depth > 0; depth--)\n      if (this.start(depth) <= pos && this.end(depth) >= pos)\n        return depth;\n    return 0;\n  }\n  blockRange(other = this, pred) {\n    if (other.pos < this.pos)\n      return other.blockRange(this);\n    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n        return new NodeRange(this, other, d);\n    return null;\n  }\n  sameParent(other) {\n    return this.pos - this.parentOffset == other.pos - other.parentOffset;\n  }\n  max(other) {\n    return other.pos > this.pos ? other : this;\n  }\n  min(other) {\n    return other.pos < this.pos ? other : this;\n  }\n  toString() {\n    let str = \"\";\n    for (let i = 1; i <= this.depth; i++)\n      str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n    return str + \":\" + this.parentOffset;\n  }\n  static resolve(doc2, pos) {\n    if (!(pos >= 0 && pos <= doc2.content.size))\n      throw new RangeError(\"Position \" + pos + \" out of range\");\n    let path = [];\n    let start = 0, parentOffset = pos;\n    for (let node = doc2; ; ) {\n      let { index, offset } = node.content.findIndex(parentOffset);\n      let rem = parentOffset - offset;\n      path.push(node, index, start + offset);\n      if (!rem)\n        break;\n      node = node.child(index);\n      if (node.isText)\n        break;\n      parentOffset = rem - 1;\n      start += offset + 1;\n    }\n    return new ResolvedPos(pos, path, parentOffset);\n  }\n  static resolveCached(doc2, pos) {\n    for (let i = 0; i < resolveCache.length; i++) {\n      let cached = resolveCache[i];\n      if (cached.pos == pos && cached.doc == doc2)\n        return cached;\n    }\n    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);\n    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n    return result;\n  }\n}\nlet resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;\nclass NodeRange {\n  constructor($from, $to, depth) {\n    this.$from = $from;\n    this.$to = $to;\n    this.depth = depth;\n  }\n  get start() {\n    return this.$from.before(this.depth + 1);\n  }\n  get end() {\n    return this.$to.after(this.depth + 1);\n  }\n  get parent() {\n    return this.$from.node(this.depth);\n  }\n  get startIndex() {\n    return this.$from.index(this.depth);\n  }\n  get endIndex() {\n    return this.$to.indexAfter(this.depth);\n  }\n}\nconst emptyAttrs = /* @__PURE__ */ Object.create(null);\nclass Node {\n  constructor(type, attrs, content, marks = Mark.none) {\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.content = content || Fragment.empty;\n  }\n  get nodeSize() {\n    return this.isLeaf ? 1 : 2 + this.content.size;\n  }\n  get childCount() {\n    return this.content.childCount;\n  }\n  child(index) {\n    return this.content.child(index);\n  }\n  maybeChild(index) {\n    return this.content.maybeChild(index);\n  }\n  forEach(f) {\n    this.content.forEach(f);\n  }\n  nodesBetween(from, to, f, startPos = 0) {\n    this.content.nodesBetween(from, to, f, startPos, this);\n  }\n  descendants(f) {\n    this.nodesBetween(0, this.content.size, f);\n  }\n  get textContent() {\n    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n  }\n  textBetween(from, to, blockSeparator, leafText) {\n    return this.content.textBetween(from, to, blockSeparator, leafText);\n  }\n  get firstChild() {\n    return this.content.firstChild;\n  }\n  get lastChild() {\n    return this.content.lastChild;\n  }\n  eq(other) {\n    return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n  }\n  sameMarkup(other) {\n    return this.hasMarkup(other.type, other.attrs, other.marks);\n  }\n  hasMarkup(type, attrs, marks) {\n    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n  }\n  copy(content = null) {\n    if (content == this.content)\n      return this;\n    return new Node(this.type, this.attrs, content, this.marks);\n  }\n  mark(marks) {\n    return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n  }\n  cut(from, to = this.content.size) {\n    if (from == 0 && to == this.content.size)\n      return this;\n    return this.copy(this.content.cut(from, to));\n  }\n  slice(from, to = this.content.size, includeParents = false) {\n    if (from == to)\n      return Slice.empty;\n    let $from = this.resolve(from), $to = this.resolve(to);\n    let depth = includeParents ? 0 : $from.sharedDepth(to);\n    let start = $from.start(depth), node = $from.node(depth);\n    let content = node.content.cut($from.pos - start, $to.pos - start);\n    return new Slice(content, $from.depth - depth, $to.depth - depth);\n  }\n  replace(from, to, slice) {\n    return replace(this.resolve(from), this.resolve(to), slice);\n  }\n  nodeAt(pos) {\n    for (let node = this; ; ) {\n      let { index, offset } = node.content.findIndex(pos);\n      node = node.maybeChild(index);\n      if (!node)\n        return null;\n      if (offset == pos || node.isText)\n        return node;\n      pos -= offset + 1;\n    }\n  }\n  childAfter(pos) {\n    let { index, offset } = this.content.findIndex(pos);\n    return { node: this.content.maybeChild(index), index, offset };\n  }\n  childBefore(pos) {\n    if (pos == 0)\n      return { node: null, index: 0, offset: 0 };\n    let { index, offset } = this.content.findIndex(pos);\n    if (offset < pos)\n      return { node: this.content.child(index), index, offset };\n    let node = this.content.child(index - 1);\n    return { node, index: index - 1, offset: offset - node.nodeSize };\n  }\n  resolve(pos) {\n    return ResolvedPos.resolveCached(this, pos);\n  }\n  resolveNoCache(pos) {\n    return ResolvedPos.resolve(this, pos);\n  }\n  rangeHasMark(from, to, type) {\n    let found2 = false;\n    if (to > from)\n      this.nodesBetween(from, to, (node) => {\n        if (type.isInSet(node.marks))\n          found2 = true;\n        return !found2;\n      });\n    return found2;\n  }\n  get isBlock() {\n    return this.type.isBlock;\n  }\n  get isTextblock() {\n    return this.type.isTextblock;\n  }\n  get inlineContent() {\n    return this.type.inlineContent;\n  }\n  get isInline() {\n    return this.type.isInline;\n  }\n  get isText() {\n    return this.type.isText;\n  }\n  get isLeaf() {\n    return this.type.isLeaf;\n  }\n  get isAtom() {\n    return this.type.isAtom;\n  }\n  toString() {\n    if (this.type.spec.toDebugString)\n      return this.type.spec.toDebugString(this);\n    let name = this.type.name;\n    if (this.content.size)\n      name += \"(\" + this.content.toStringInner() + \")\";\n    return wrapMarks(this.marks, name);\n  }\n  contentMatchAt(index) {\n    let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n    if (!match)\n      throw new Error(\"Called contentMatchAt on a node with invalid content\");\n    return match;\n  }\n  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n    let one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n    let two = one && one.matchFragment(this.content, to);\n    if (!two || !two.validEnd)\n      return false;\n    for (let i = start; i < end; i++)\n      if (!this.type.allowsMarks(replacement.child(i).marks))\n        return false;\n    return true;\n  }\n  canReplaceWith(from, to, type, marks) {\n    if (marks && !this.type.allowsMarks(marks))\n      return false;\n    let start = this.contentMatchAt(from).matchType(type);\n    let end = start && start.matchFragment(this.content, to);\n    return end ? end.validEnd : false;\n  }\n  canAppend(other) {\n    if (other.content.size)\n      return this.canReplace(this.childCount, this.childCount, other.content);\n    else\n      return this.type.compatibleContent(other.type);\n  }\n  check() {\n    if (!this.type.validContent(this.content))\n      throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`);\n    let copy2 = Mark.none;\n    for (let i = 0; i < this.marks.length; i++)\n      copy2 = this.marks[i].addToSet(copy2);\n    if (!Mark.sameSet(copy2, this.marks))\n      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);\n    this.content.forEach((node) => node.check());\n  }\n  toJSON() {\n    let obj = { type: this.type.name };\n    for (let _ in this.attrs) {\n      obj.attrs = this.attrs;\n      break;\n    }\n    if (this.content.size)\n      obj.content = this.content.toJSON();\n    if (this.marks.length)\n      obj.marks = this.marks.map((n) => n.toJSON());\n    return obj;\n  }\n  static fromJSON(schema, json) {\n    if (!json)\n      throw new RangeError(\"Invalid input for Node.fromJSON\");\n    let marks = null;\n    if (json.marks) {\n      if (!Array.isArray(json.marks))\n        throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n      marks = json.marks.map(schema.markFromJSON);\n    }\n    if (json.type == \"text\") {\n      if (typeof json.text != \"string\")\n        throw new RangeError(\"Invalid text node in JSON\");\n      return schema.text(json.text, marks);\n    }\n    let content = Fragment.fromJSON(schema, json.content);\n    return schema.nodeType(json.type).create(json.attrs, content, marks);\n  }\n}\nNode.prototype.text = void 0;\nclass TextNode extends Node {\n  constructor(type, attrs, content, marks) {\n    super(type, attrs, null, marks);\n    if (!content)\n      throw new RangeError(\"Empty text nodes are not allowed\");\n    this.text = content;\n  }\n  toString() {\n    if (this.type.spec.toDebugString)\n      return this.type.spec.toDebugString(this);\n    return wrapMarks(this.marks, JSON.stringify(this.text));\n  }\n  get textContent() {\n    return this.text;\n  }\n  textBetween(from, to) {\n    return this.text.slice(from, to);\n  }\n  get nodeSize() {\n    return this.text.length;\n  }\n  mark(marks) {\n    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n  }\n  withText(text) {\n    if (text == this.text)\n      return this;\n    return new TextNode(this.type, this.attrs, text, this.marks);\n  }\n  cut(from = 0, to = this.text.length) {\n    if (from == 0 && to == this.text.length)\n      return this;\n    return this.withText(this.text.slice(from, to));\n  }\n  eq(other) {\n    return this.sameMarkup(other) && this.text == other.text;\n  }\n  toJSON() {\n    let base = super.toJSON();\n    base.text = this.text;\n    return base;\n  }\n}\nfunction wrapMarks(marks, str) {\n  for (let i = marks.length - 1; i >= 0; i--)\n    str = marks[i].type.name + \"(\" + str + \")\";\n  return str;\n}\nclass ContentMatch {\n  constructor(validEnd) {\n    this.validEnd = validEnd;\n    this.next = [];\n    this.wrapCache = [];\n  }\n  static parse(string, nodeTypes) {\n    let stream = new TokenStream(string, nodeTypes);\n    if (stream.next == null)\n      return ContentMatch.empty;\n    let expr = parseExpr(stream);\n    if (stream.next)\n      stream.err(\"Unexpected trailing text\");\n    let match = dfa(nfa(expr));\n    checkForDeadEnds(match, stream);\n    return match;\n  }\n  matchType(type) {\n    for (let i = 0; i < this.next.length; i++)\n      if (this.next[i].type == type)\n        return this.next[i].next;\n    return null;\n  }\n  matchFragment(frag, start = 0, end = frag.childCount) {\n    let cur = this;\n    for (let i = start; cur && i < end; i++)\n      cur = cur.matchType(frag.child(i).type);\n    return cur;\n  }\n  get inlineContent() {\n    return this.next.length && this.next[0].type.isInline;\n  }\n  get defaultType() {\n    for (let i = 0; i < this.next.length; i++) {\n      let { type } = this.next[i];\n      if (!(type.isText || type.hasRequiredAttrs()))\n        return type;\n    }\n    return null;\n  }\n  compatible(other) {\n    for (let i = 0; i < this.next.length; i++)\n      for (let j = 0; j < other.next.length; j++)\n        if (this.next[i].type == other.next[j].type)\n          return true;\n    return false;\n  }\n  fillBefore(after, toEnd = false, startIndex = 0) {\n    let seen = [this];\n    function search(match, types) {\n      let finished = match.matchFragment(after, startIndex);\n      if (finished && (!toEnd || finished.validEnd))\n        return Fragment.from(types.map((tp) => tp.createAndFill()));\n      for (let i = 0; i < match.next.length; i++) {\n        let { type, next } = match.next[i];\n        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n          seen.push(next);\n          let found2 = search(next, types.concat(type));\n          if (found2)\n            return found2;\n        }\n      }\n      return null;\n    }\n    return search(this, []);\n  }\n  findWrapping(target) {\n    for (let i = 0; i < this.wrapCache.length; i += 2)\n      if (this.wrapCache[i] == target)\n        return this.wrapCache[i + 1];\n    let computed = this.computeWrapping(target);\n    this.wrapCache.push(target, computed);\n    return computed;\n  }\n  computeWrapping(target) {\n    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];\n    while (active.length) {\n      let current = active.shift(), match = current.match;\n      if (match.matchType(target)) {\n        let result = [];\n        for (let obj = current; obj.type; obj = obj.via)\n          result.push(obj.type);\n        return result.reverse();\n      }\n      for (let i = 0; i < match.next.length; i++) {\n        let { type, next } = match.next[i];\n        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n          active.push({ match: type.contentMatch, type, via: current });\n          seen[type.name] = true;\n        }\n      }\n    }\n    return null;\n  }\n  get edgeCount() {\n    return this.next.length;\n  }\n  edge(n) {\n    if (n >= this.next.length)\n      throw new RangeError(`There's no ${n}th edge in this content match`);\n    return this.next[n];\n  }\n  toString() {\n    let seen = [];\n    function scan(m) {\n      seen.push(m);\n      for (let i = 0; i < m.next.length; i++)\n        if (seen.indexOf(m.next[i].next) == -1)\n          scan(m.next[i].next);\n    }\n    scan(this);\n    return seen.map((m, i) => {\n      let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n      for (let i2 = 0; i2 < m.next.length; i2++)\n        out += (i2 ? \", \" : \"\") + m.next[i2].type.name + \"->\" + seen.indexOf(m.next[i2].next);\n      return out;\n    }).join(\"\\n\");\n  }\n}\nContentMatch.empty = new ContentMatch(true);\nclass TokenStream {\n  constructor(string, nodeTypes) {\n    this.string = string;\n    this.nodeTypes = nodeTypes;\n    this.inline = null;\n    this.pos = 0;\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n    if (this.tokens[this.tokens.length - 1] == \"\")\n      this.tokens.pop();\n    if (this.tokens[0] == \"\")\n      this.tokens.shift();\n  }\n  get next() {\n    return this.tokens[this.pos];\n  }\n  eat(tok) {\n    return this.next == tok && (this.pos++ || true);\n  }\n  err(str) {\n    throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n  }\n}\nfunction parseExpr(stream) {\n  let exprs = [];\n  do {\n    exprs.push(parseExprSeq(stream));\n  } while (stream.eat(\"|\"));\n  return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n}\nfunction parseExprSeq(stream) {\n  let exprs = [];\n  do {\n    exprs.push(parseExprSubscript(stream));\n  } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n  return exprs.length == 1 ? exprs[0] : { type: \"seq\", exprs };\n}\nfunction parseExprSubscript(stream) {\n  let expr = parseExprAtom(stream);\n  for (; ; ) {\n    if (stream.eat(\"+\"))\n      expr = { type: \"plus\", expr };\n    else if (stream.eat(\"*\"))\n      expr = { type: \"star\", expr };\n    else if (stream.eat(\"?\"))\n      expr = { type: \"opt\", expr };\n    else if (stream.eat(\"{\"))\n      expr = parseExprRange(stream, expr);\n    else\n      break;\n  }\n  return expr;\n}\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next))\n    stream.err(\"Expected number, got '\" + stream.next + \"'\");\n  let result = Number(stream.next);\n  stream.pos++;\n  return result;\n}\nfunction parseExprRange(stream, expr) {\n  let min = parseNum(stream), max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\")\n      max = parseNum(stream);\n    else\n      max = -1;\n  }\n  if (!stream.eat(\"}\"))\n    stream.err(\"Unclosed braced range\");\n  return { type: \"range\", min, max, expr };\n}\nfunction resolveName(stream, name) {\n  let types = stream.nodeTypes, type = types[name];\n  if (type)\n    return [type];\n  let result = [];\n  for (let typeName in types) {\n    let type2 = types[typeName];\n    if (type2.groups.indexOf(name) > -1)\n      result.push(type2);\n  }\n  if (result.length == 0)\n    stream.err(\"No node type or group '\" + name + \"' found\");\n  return result;\n}\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    let expr = parseExpr(stream);\n    if (!stream.eat(\")\"))\n      stream.err(\"Missing closing paren\");\n    return expr;\n  } else if (!/\\W/.test(stream.next)) {\n    let exprs = resolveName(stream, stream.next).map((type) => {\n      if (stream.inline == null)\n        stream.inline = type.isInline;\n      else if (stream.inline != type.isInline)\n        stream.err(\"Mixing inline and block content\");\n      return { type: \"name\", value: type };\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\nfunction nfa(expr) {\n  let nfa2 = [[]];\n  connect(compile(expr, 0), node());\n  return nfa2;\n  function node() {\n    return nfa2.push([]) - 1;\n  }\n  function edge(from, to, term) {\n    let edge2 = { term, to };\n    nfa2[from].push(edge2);\n    return edge2;\n  }\n  function connect(edges, to) {\n    edges.forEach((edge2) => edge2.to = to);\n  }\n  function compile(expr2, from) {\n    if (expr2.type == \"choice\") {\n      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);\n    } else if (expr2.type == \"seq\") {\n      for (let i = 0; ; i++) {\n        let next = compile(expr2.exprs[i], from);\n        if (i == expr2.exprs.length - 1)\n          return next;\n        connect(next, from = node());\n      }\n    } else if (expr2.type == \"star\") {\n      let loop = node();\n      edge(from, loop);\n      connect(compile(expr2.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr2.type == \"plus\") {\n      let loop = node();\n      connect(compile(expr2.expr, from), loop);\n      connect(compile(expr2.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr2.type == \"opt\") {\n      return [edge(from)].concat(compile(expr2.expr, from));\n    } else if (expr2.type == \"range\") {\n      let cur = from;\n      for (let i = 0; i < expr2.min; i++) {\n        let next = node();\n        connect(compile(expr2.expr, cur), next);\n        cur = next;\n      }\n      if (expr2.max == -1) {\n        connect(compile(expr2.expr, cur), cur);\n      } else {\n        for (let i = expr2.min; i < expr2.max; i++) {\n          let next = node();\n          edge(cur, next);\n          connect(compile(expr2.expr, cur), next);\n          cur = next;\n        }\n      }\n      return [edge(cur)];\n    } else if (expr2.type == \"name\") {\n      return [edge(from, void 0, expr2.value)];\n    } else {\n      throw new Error(\"Unknown expr type\");\n    }\n  }\n}\nfunction cmp(a, b) {\n  return b - a;\n}\nfunction nullFrom(nfa2, node) {\n  let result = [];\n  scan(node);\n  return result.sort(cmp);\n  function scan(node2) {\n    let edges = nfa2[node2];\n    if (edges.length == 1 && !edges[0].term)\n      return scan(edges[0].to);\n    result.push(node2);\n    for (let i = 0; i < edges.length; i++) {\n      let { term, to } = edges[i];\n      if (!term && result.indexOf(to) == -1)\n        scan(to);\n    }\n  }\n}\nfunction dfa(nfa2) {\n  let labeled = /* @__PURE__ */ Object.create(null);\n  return explore(nullFrom(nfa2, 0));\n  function explore(states) {\n    let out = [];\n    states.forEach((node) => {\n      nfa2[node].forEach(({ term, to }) => {\n        if (!term)\n          return;\n        let set;\n        for (let i = 0; i < out.length; i++)\n          if (out[i][0] == term)\n            set = out[i][1];\n        nullFrom(nfa2, to).forEach((node2) => {\n          if (!set)\n            out.push([term, set = []]);\n          if (set.indexOf(node2) == -1)\n            set.push(node2);\n        });\n      });\n    });\n    let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);\n    for (let i = 0; i < out.length; i++) {\n      let states2 = out[i][1].sort(cmp);\n      state.next.push({ type: out[i][0], next: labeled[states2.join(\",\")] || explore(states2) });\n    }\n    return state;\n  }\n}\nfunction checkForDeadEnds(match, stream) {\n  for (let i = 0, work = [match]; i < work.length; i++) {\n    let state = work[i], dead = !state.validEnd, nodes = [];\n    for (let j = 0; j < state.next.length; j++) {\n      let { type, next } = state.next[j];\n      nodes.push(type.name);\n      if (dead && !(type.isText || type.hasRequiredAttrs()))\n        dead = false;\n      if (work.indexOf(next) == -1)\n        work.push(next);\n    }\n    if (dead)\n      stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n  }\n}\nfunction defaultAttrs(attrs) {\n  let defaults = /* @__PURE__ */ Object.create(null);\n  for (let attrName in attrs) {\n    let attr = attrs[attrName];\n    if (!attr.hasDefault)\n      return null;\n    defaults[attrName] = attr.default;\n  }\n  return defaults;\n}\nfunction computeAttrs(attrs, value) {\n  let built = /* @__PURE__ */ Object.create(null);\n  for (let name in attrs) {\n    let given = value && value[name];\n    if (given === void 0) {\n      let attr = attrs[name];\n      if (attr.hasDefault)\n        given = attr.default;\n      else\n        throw new RangeError(\"No value supplied for attribute \" + name);\n    }\n    built[name] = given;\n  }\n  return built;\n}\nfunction initAttrs(attrs) {\n  let result = /* @__PURE__ */ Object.create(null);\n  if (attrs)\n    for (let name in attrs)\n      result[name] = new Attribute(attrs[name]);\n  return result;\n}\nclass NodeType {\n  constructor(name, schema, spec) {\n    this.name = name;\n    this.schema = schema;\n    this.spec = spec;\n    this.markSet = null;\n    this.groups = spec.group ? spec.group.split(\" \") : [];\n    this.attrs = initAttrs(spec.attrs);\n    this.defaultAttrs = defaultAttrs(this.attrs);\n    this.contentMatch = null;\n    this.inlineContent = null;\n    this.isBlock = !(spec.inline || name == \"text\");\n    this.isText = name == \"text\";\n  }\n  get isInline() {\n    return !this.isBlock;\n  }\n  get isTextblock() {\n    return this.isBlock && this.inlineContent;\n  }\n  get isLeaf() {\n    return this.contentMatch == ContentMatch.empty;\n  }\n  get isAtom() {\n    return this.isLeaf || !!this.spec.atom;\n  }\n  get whitespace() {\n    return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n  }\n  hasRequiredAttrs() {\n    for (let n in this.attrs)\n      if (this.attrs[n].isRequired)\n        return true;\n    return false;\n  }\n  compatibleContent(other) {\n    return this == other || this.contentMatch.compatible(other.contentMatch);\n  }\n  computeAttrs(attrs) {\n    if (!attrs && this.defaultAttrs)\n      return this.defaultAttrs;\n    else\n      return computeAttrs(this.attrs, attrs);\n  }\n  create(attrs = null, content, marks) {\n    if (this.isText)\n      throw new Error(\"NodeType.create can't construct text nodes\");\n    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n  }\n  createChecked(attrs = null, content, marks) {\n    content = Fragment.from(content);\n    if (!this.validContent(content))\n      throw new RangeError(\"Invalid content for node \" + this.name);\n    return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n  }\n  createAndFill(attrs = null, content, marks) {\n    attrs = this.computeAttrs(attrs);\n    content = Fragment.from(content);\n    if (content.size) {\n      let before = this.contentMatch.fillBefore(content);\n      if (!before)\n        return null;\n      content = before.append(content);\n    }\n    let matched = this.contentMatch.matchFragment(content);\n    let after = matched && matched.fillBefore(Fragment.empty, true);\n    if (!after)\n      return null;\n    return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n  }\n  validContent(content) {\n    let result = this.contentMatch.matchFragment(content);\n    if (!result || !result.validEnd)\n      return false;\n    for (let i = 0; i < content.childCount; i++)\n      if (!this.allowsMarks(content.child(i).marks))\n        return false;\n    return true;\n  }\n  allowsMarkType(markType) {\n    return this.markSet == null || this.markSet.indexOf(markType) > -1;\n  }\n  allowsMarks(marks) {\n    if (this.markSet == null)\n      return true;\n    for (let i = 0; i < marks.length; i++)\n      if (!this.allowsMarkType(marks[i].type))\n        return false;\n    return true;\n  }\n  allowedMarks(marks) {\n    if (this.markSet == null)\n      return marks;\n    let copy2;\n    for (let i = 0; i < marks.length; i++) {\n      if (!this.allowsMarkType(marks[i].type)) {\n        if (!copy2)\n          copy2 = marks.slice(0, i);\n      } else if (copy2) {\n        copy2.push(marks[i]);\n      }\n    }\n    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;\n  }\n  static compile(nodes, schema) {\n    let result = /* @__PURE__ */ Object.create(null);\n    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));\n    let topType = schema.spec.topNode || \"doc\";\n    if (!result[topType])\n      throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n    if (!result.text)\n      throw new RangeError(\"Every schema needs a 'text' type\");\n    for (let _ in result.text.attrs)\n      throw new RangeError(\"The text node type should not have attributes\");\n    return result;\n  }\n}\nclass Attribute {\n  constructor(options) {\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n    this.default = options.default;\n  }\n  get isRequired() {\n    return !this.hasDefault;\n  }\n}\nclass MarkType {\n  constructor(name, rank, schema, spec) {\n    this.name = name;\n    this.rank = rank;\n    this.schema = schema;\n    this.spec = spec;\n    this.attrs = initAttrs(spec.attrs);\n    this.excluded = null;\n    let defaults = defaultAttrs(this.attrs);\n    this.instance = defaults ? new Mark(this, defaults) : null;\n  }\n  create(attrs = null) {\n    if (!attrs && this.instance)\n      return this.instance;\n    return new Mark(this, computeAttrs(this.attrs, attrs));\n  }\n  static compile(marks, schema) {\n    let result = /* @__PURE__ */ Object.create(null), rank = 0;\n    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));\n    return result;\n  }\n  removeFromSet(set) {\n    for (var i = 0; i < set.length; i++)\n      if (set[i].type == this) {\n        set = set.slice(0, i).concat(set.slice(i + 1));\n        i--;\n      }\n    return set;\n  }\n  isInSet(set) {\n    for (let i = 0; i < set.length; i++)\n      if (set[i].type == this)\n        return set[i];\n  }\n  excludes(other) {\n    return this.excluded.indexOf(other) > -1;\n  }\n}\nclass Schema {\n  constructor(spec) {\n    this.cached = /* @__PURE__ */ Object.create(null);\n    this.spec = {\n      nodes: orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.nodes),\n      marks: orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.marks || {}),\n      topNode: spec.topNode\n    };\n    this.nodes = NodeType.compile(this.spec.nodes, this);\n    this.marks = MarkType.compile(this.spec.marks, this);\n    let contentExprCache = /* @__PURE__ */ Object.create(null);\n    for (let prop in this.nodes) {\n      if (prop in this.marks)\n        throw new RangeError(prop + \" can not be both a node and a mark\");\n      let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n      type.inlineContent = type.contentMatch.inlineContent;\n      type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n    }\n    for (let prop in this.marks) {\n      let type = this.marks[prop], excl = type.spec.excludes;\n      type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n    }\n    this.nodeFromJSON = this.nodeFromJSON.bind(this);\n    this.markFromJSON = this.markFromJSON.bind(this);\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n    this.cached.wrappings = /* @__PURE__ */ Object.create(null);\n  }\n  node(type, attrs = null, content, marks) {\n    if (typeof type == \"string\")\n      type = this.nodeType(type);\n    else if (!(type instanceof NodeType))\n      throw new RangeError(\"Invalid node type: \" + type);\n    else if (type.schema != this)\n      throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n    return type.createChecked(attrs, content, marks);\n  }\n  text(text, marks) {\n    let type = this.nodes.text;\n    return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));\n  }\n  mark(type, attrs) {\n    if (typeof type == \"string\")\n      type = this.marks[type];\n    return type.create(attrs);\n  }\n  nodeFromJSON(json) {\n    return Node.fromJSON(this, json);\n  }\n  markFromJSON(json) {\n    return Mark.fromJSON(this, json);\n  }\n  nodeType(name) {\n    let found2 = this.nodes[name];\n    if (!found2)\n      throw new RangeError(\"Unknown node type: \" + name);\n    return found2;\n  }\n}\nfunction gatherMarks(schema, marks) {\n  let found2 = [];\n  for (let i = 0; i < marks.length; i++) {\n    let name = marks[i], mark = schema.marks[name], ok = mark;\n    if (mark) {\n      found2.push(mark);\n    } else {\n      for (let prop in schema.marks) {\n        let mark2 = schema.marks[prop];\n        if (name == \"_\" || mark2.spec.group && mark2.spec.group.split(\" \").indexOf(name) > -1)\n          found2.push(ok = mark2);\n      }\n    }\n    if (!ok)\n      throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n  }\n  return found2;\n}\nclass DOMParser {\n  constructor(schema, rules) {\n    this.schema = schema;\n    this.rules = rules;\n    this.tags = [];\n    this.styles = [];\n    rules.forEach((rule) => {\n      if (rule.tag)\n        this.tags.push(rule);\n      else if (rule.style)\n        this.styles.push(rule);\n    });\n    this.normalizeLists = !this.tags.some((r) => {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node)\n        return false;\n      let node = schema.nodes[r.node];\n      return node.contentMatch.matchType(node);\n    });\n  }\n  parse(dom, options = {}) {\n    let context = new ParseContext(this, options, false);\n    context.addAll(dom, options.from, options.to);\n    return context.finish();\n  }\n  parseSlice(dom, options = {}) {\n    let context = new ParseContext(this, options, true);\n    context.addAll(dom, options.from, options.to);\n    return Slice.maxOpen(context.finish());\n  }\n  matchTag(dom, context, after) {\n    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n      let rule = this.tags[i];\n      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(dom);\n          if (result === false)\n            continue;\n          rule.attrs = result || void 0;\n        }\n        return rule;\n      }\n    }\n  }\n  matchStyle(prop, value, context, after) {\n    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n      let rule = this.styles[i], style = rule.style;\n      if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))\n        continue;\n      if (rule.getAttrs) {\n        let result = rule.getAttrs(value);\n        if (result === false)\n          continue;\n        rule.attrs = result || void 0;\n      }\n      return rule;\n    }\n  }\n  static schemaRules(schema) {\n    let result = [];\n    function insert(rule) {\n      let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n      for (; i < result.length; i++) {\n        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n        if (nextPriority < priority)\n          break;\n      }\n      result.splice(i, 0, rule);\n    }\n    for (let name in schema.marks) {\n      let rules = schema.marks[name].spec.parseDOM;\n      if (rules)\n        rules.forEach((rule) => {\n          insert(rule = copy(rule));\n          rule.mark = name;\n        });\n    }\n    for (let name in schema.nodes) {\n      let rules = schema.nodes[name].spec.parseDOM;\n      if (rules)\n        rules.forEach((rule) => {\n          insert(rule = copy(rule));\n          rule.node = name;\n        });\n    }\n    return result;\n  }\n  static fromSchema(schema) {\n    return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n  }\n}\nconst blockTags = {\n  address: true,\n  article: true,\n  aside: true,\n  blockquote: true,\n  canvas: true,\n  dd: true,\n  div: true,\n  dl: true,\n  fieldset: true,\n  figcaption: true,\n  figure: true,\n  footer: true,\n  form: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  header: true,\n  hgroup: true,\n  hr: true,\n  li: true,\n  noscript: true,\n  ol: true,\n  output: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tfoot: true,\n  ul: true\n};\nconst ignoreTags = {\n  head: true,\n  noscript: true,\n  object: true,\n  script: true,\n  style: true,\n  title: true\n};\nconst listTags = { ol: true, ul: true };\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null)\n    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nclass NodeContext {\n  constructor(type, attrs, marks, pendingMarks, solid, match, options) {\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.pendingMarks = pendingMarks;\n    this.solid = solid;\n    this.options = options;\n    this.content = [];\n    this.activeMarks = Mark.none;\n    this.stashMarks = [];\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  }\n  findWrapping(node) {\n    if (!this.match) {\n      if (!this.type)\n        return [];\n      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n      if (fill) {\n        this.match = this.type.contentMatch.matchFragment(fill);\n      } else {\n        let start = this.type.contentMatch, wrap;\n        if (wrap = start.findWrapping(node.type)) {\n          this.match = start;\n          return wrap;\n        } else {\n          return null;\n        }\n      }\n    }\n    return this.match.findWrapping(node.type);\n  }\n  finish(openEnd) {\n    if (!(this.options & OPT_PRESERVE_WS)) {\n      let last = this.content[this.content.length - 1], m;\n      if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n        let text = last;\n        if (last.text.length == m[0].length)\n          this.content.pop();\n        else\n          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n      }\n    }\n    let content = Fragment.from(this.content);\n    if (!openEnd && this.match)\n      content = content.append(this.match.fillBefore(Fragment.empty, true));\n    return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n  }\n  popFromStashMark(mark) {\n    for (let i = this.stashMarks.length - 1; i >= 0; i--)\n      if (mark.eq(this.stashMarks[i]))\n        return this.stashMarks.splice(i, 1)[0];\n  }\n  applyPending(nextType) {\n    for (let i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n      let mark = pending[i];\n      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {\n        this.activeMarks = mark.addToSet(this.activeMarks);\n        this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n      }\n    }\n  }\n  inlineContext(node) {\n    if (this.type)\n      return this.type.inlineContent;\n    if (this.content.length)\n      return this.content[0].isInline;\n    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n  }\n}\nclass ParseContext {\n  constructor(parser, options, isOpen) {\n    this.parser = parser;\n    this.options = options;\n    this.isOpen = isOpen;\n    this.open = 0;\n    let topNode = options.topNode, topContext;\n    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n    if (topNode)\n      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n    else if (isOpen)\n      topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);\n    else\n      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);\n    this.nodes = [topContext];\n    this.find = options.findPositions;\n    this.needsBlock = false;\n  }\n  get top() {\n    return this.nodes[this.open];\n  }\n  addDOM(dom) {\n    if (dom.nodeType == 3) {\n      this.addTextNode(dom);\n    } else if (dom.nodeType == 1) {\n      let style = dom.getAttribute(\"style\");\n      let marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;\n      if (marks != null)\n        for (let i = 0; i < marks.length; i++)\n          this.addPendingMark(marks[i]);\n      this.addElement(dom);\n      if (marks != null)\n        for (let i = 0; i < marks.length; i++)\n          this.removePendingMark(marks[i], top);\n    }\n  }\n  addTextNode(dom) {\n    let value = dom.nodeValue;\n    let top = this.top;\n    if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n      if (!(top.options & OPT_PRESERVE_WS)) {\n        value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n        if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n          let nodeBefore = top.content[top.content.length - 1];\n          let domNodeBefore = dom.previousSibling;\n          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == \"BR\" || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text))\n            value = value.slice(1);\n        }\n      } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n        value = value.replace(/\\r?\\n|\\r/g, \" \");\n      } else {\n        value = value.replace(/\\r\\n?/g, \"\\n\");\n      }\n      if (value)\n        this.insertNode(this.parser.schema.text(value));\n      this.findInText(dom);\n    } else {\n      this.findInside(dom);\n    }\n  }\n  addElement(dom, matchAfter) {\n    let name = dom.nodeName.toLowerCase(), ruleID;\n    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)\n      normalizeList(dom);\n    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n      this.findInside(dom);\n      this.ignoreFallback(dom);\n    } else if (!rule || rule.skip || rule.closeParent) {\n      if (rule && rule.closeParent)\n        this.open = Math.max(0, this.open - 1);\n      else if (rule && rule.skip.nodeType)\n        dom = rule.skip;\n      let sync, top = this.top, oldNeedsBlock = this.needsBlock;\n      if (blockTags.hasOwnProperty(name)) {\n        sync = true;\n        if (!top.type)\n          this.needsBlock = true;\n      } else if (!dom.firstChild) {\n        this.leafFallback(dom);\n        return;\n      }\n      this.addAll(dom);\n      if (sync)\n        this.sync(top);\n      this.needsBlock = oldNeedsBlock;\n    } else {\n      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);\n    }\n  }\n  leafFallback(dom) {\n    if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n      this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"));\n  }\n  ignoreFallback(dom) {\n    if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n      this.findPlace(this.parser.schema.text(\"-\"));\n  }\n  readStyles(styles) {\n    let marks = Mark.none;\n    style:\n      for (let i = 0; i < styles.length; i += 2) {\n        for (let after = void 0; ; ) {\n          let rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n          if (!rule)\n            continue style;\n          if (rule.ignore)\n            return null;\n          marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n          if (rule.consuming === false)\n            after = rule;\n          else\n            break;\n        }\n      }\n    return marks;\n  }\n  addElementByRule(dom, rule, continueAfter) {\n    let sync, nodeType, mark;\n    if (rule.node) {\n      nodeType = this.parser.schema.nodes[rule.node];\n      if (!nodeType.isLeaf) {\n        sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);\n      } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n        this.leafFallback(dom);\n      }\n    } else {\n      let markType = this.parser.schema.marks[rule.mark];\n      mark = markType.create(rule.attrs);\n      this.addPendingMark(mark);\n    }\n    let startIn = this.top;\n    if (nodeType && nodeType.isLeaf) {\n      this.findInside(dom);\n    } else if (continueAfter) {\n      this.addElement(dom, continueAfter);\n    } else if (rule.getContent) {\n      this.findInside(dom);\n      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node));\n    } else {\n      let contentDOM = dom;\n      if (typeof rule.contentElement == \"string\")\n        contentDOM = dom.querySelector(rule.contentElement);\n      else if (typeof rule.contentElement == \"function\")\n        contentDOM = rule.contentElement(dom);\n      else if (rule.contentElement)\n        contentDOM = rule.contentElement;\n      this.findAround(dom, contentDOM, true);\n      this.addAll(contentDOM);\n    }\n    if (sync && this.sync(startIn))\n      this.open--;\n    if (mark)\n      this.removePendingMark(mark, startIn);\n  }\n  addAll(parent, startIndex, endIndex) {\n    let index = startIndex || 0;\n    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n      this.findAtPoint(parent, index);\n      this.addDOM(dom);\n    }\n    this.findAtPoint(parent, index);\n  }\n  findPlace(node) {\n    let route, sync;\n    for (let depth = this.open; depth >= 0; depth--) {\n      let cx = this.nodes[depth];\n      let found2 = cx.findWrapping(node);\n      if (found2 && (!route || route.length > found2.length)) {\n        route = found2;\n        sync = cx;\n        if (!found2.length)\n          break;\n      }\n      if (cx.solid)\n        break;\n    }\n    if (!route)\n      return false;\n    this.sync(sync);\n    for (let i = 0; i < route.length; i++)\n      this.enterInner(route[i], null, false);\n    return true;\n  }\n  insertNode(node) {\n    if (node.isInline && this.needsBlock && !this.top.type) {\n      let block = this.textblockFromContext();\n      if (block)\n        this.enterInner(block);\n    }\n    if (this.findPlace(node)) {\n      this.closeExtra();\n      let top = this.top;\n      top.applyPending(node.type);\n      if (top.match)\n        top.match = top.match.matchType(node.type);\n      let marks = top.activeMarks;\n      for (let i = 0; i < node.marks.length; i++)\n        if (!top.type || top.type.allowsMarkType(node.marks[i].type))\n          marks = node.marks[i].addToSet(marks);\n      top.content.push(node.mark(marks));\n      return true;\n    }\n    return false;\n  }\n  enter(type, attrs, preserveWS) {\n    let ok = this.findPlace(type.create(attrs));\n    if (ok)\n      this.enterInner(type, attrs, true, preserveWS);\n    return ok;\n  }\n  enterInner(type, attrs = null, solid = false, preserveWS) {\n    this.closeExtra();\n    let top = this.top;\n    top.applyPending(type);\n    top.match = top.match && top.match.matchType(type);\n    let options = wsOptionsFor(type, preserveWS, top.options);\n    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)\n      options |= OPT_OPEN_LEFT;\n    this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n    this.open++;\n  }\n  closeExtra(openEnd = false) {\n    let i = this.nodes.length - 1;\n    if (i > this.open) {\n      for (; i > this.open; i--)\n        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n      this.nodes.length = this.open + 1;\n    }\n  }\n  finish() {\n    this.open = 0;\n    this.closeExtra(this.isOpen);\n    return this.nodes[0].finish(this.isOpen || this.options.topOpen);\n  }\n  sync(to) {\n    for (let i = this.open; i >= 0; i--)\n      if (this.nodes[i] == to) {\n        this.open = i;\n        return true;\n      }\n    return false;\n  }\n  get currentPos() {\n    this.closeExtra();\n    let pos = 0;\n    for (let i = this.open; i >= 0; i--) {\n      let content = this.nodes[i].content;\n      for (let j = content.length - 1; j >= 0; j--)\n        pos += content[j].nodeSize;\n      if (i)\n        pos++;\n    }\n    return pos;\n  }\n  findAtPoint(parent, offset) {\n    if (this.find)\n      for (let i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == parent && this.find[i].offset == offset)\n          this.find[i].pos = this.currentPos;\n      }\n  }\n  findInside(parent) {\n    if (this.find)\n      for (let i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n          this.find[i].pos = this.currentPos;\n      }\n  }\n  findAround(parent, content, before) {\n    if (parent != content && this.find)\n      for (let i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n          let pos = content.compareDocumentPosition(this.find[i].node);\n          if (pos & (before ? 2 : 4))\n            this.find[i].pos = this.currentPos;\n        }\n      }\n  }\n  findInText(textNode) {\n    if (this.find)\n      for (let i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == textNode)\n          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n      }\n  }\n  matchesContext(context) {\n    if (context.indexOf(\"|\") > -1)\n      return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n    let parts = context.split(\"/\");\n    let option = this.options.context;\n    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n    let match = (i, depth) => {\n      for (; i >= 0; i--) {\n        let part = parts[i];\n        if (part == \"\") {\n          if (i == parts.length - 1 || i == 0)\n            continue;\n          for (; depth >= minDepth; depth--)\n            if (match(i - 1, depth))\n              return true;\n          return false;\n        } else {\n          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n          if (!next || next.name != part && next.groups.indexOf(part) == -1)\n            return false;\n          depth--;\n        }\n      }\n      return true;\n    };\n    return match(parts.length - 1, this.open);\n  }\n  textblockFromContext() {\n    let $context = this.options.context;\n    if ($context)\n      for (let d = $context.depth; d >= 0; d--) {\n        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n        if (deflt && deflt.isTextblock && deflt.defaultAttrs)\n          return deflt;\n      }\n    for (let name in this.parser.schema.nodes) {\n      let type = this.parser.schema.nodes[name];\n      if (type.isTextblock && type.defaultAttrs)\n        return type;\n    }\n  }\n  addPendingMark(mark) {\n    let found2 = findSameMarkInSet(mark, this.top.pendingMarks);\n    if (found2)\n      this.top.stashMarks.push(found2);\n    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n  }\n  removePendingMark(mark, upto) {\n    for (let depth = this.open; depth >= 0; depth--) {\n      let level = this.nodes[depth];\n      let found2 = level.pendingMarks.lastIndexOf(mark);\n      if (found2 > -1) {\n        level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n      } else {\n        level.activeMarks = mark.removeFromSet(level.activeMarks);\n        let stashMark = level.popFromStashMark(mark);\n        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))\n          level.activeMarks = stashMark.addToSet(level.activeMarks);\n      }\n      if (level == upto)\n        break;\n    }\n  }\n}\nfunction normalizeList(dom) {\n  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction parseStyles(style) {\n  let re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g, m, result = [];\n  while (m = re.exec(style))\n    result.push(m[1], m[2].trim());\n  return result;\n}\nfunction copy(obj) {\n  let copy2 = {};\n  for (let prop in obj)\n    copy2[prop] = obj[prop];\n  return copy2;\n}\nfunction markMayApply(markType, nodeType) {\n  let nodes = nodeType.schema.nodes;\n  for (let name in nodes) {\n    let parent = nodes[name];\n    if (!parent.allowsMarkType(markType))\n      continue;\n    let seen = [], scan = (match) => {\n      seen.push(match);\n      for (let i = 0; i < match.edgeCount; i++) {\n        let { type, next } = match.edge(i);\n        if (type == nodeType)\n          return true;\n        if (seen.indexOf(next) < 0 && scan(next))\n          return true;\n      }\n    };\n    if (scan(parent.contentMatch))\n      return true;\n  }\n}\nfunction findSameMarkInSet(mark, set) {\n  for (let i = 0; i < set.length; i++) {\n    if (mark.eq(set[i]))\n      return set[i];\n  }\n}\nclass DOMSerializer {\n  constructor(nodes, marks) {\n    this.nodes = nodes;\n    this.marks = marks;\n  }\n  serializeFragment(fragment, options = {}, target) {\n    if (!target)\n      target = doc(options).createDocumentFragment();\n    let top = target, active = [];\n    fragment.forEach((node) => {\n      if (active.length || node.marks.length) {\n        let keep = 0, rendered = 0;\n        while (keep < active.length && rendered < node.marks.length) {\n          let next = node.marks[rendered];\n          if (!this.marks[next.type.name]) {\n            rendered++;\n            continue;\n          }\n          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)\n            break;\n          keep++;\n          rendered++;\n        }\n        while (keep < active.length)\n          top = active.pop()[1];\n        while (rendered < node.marks.length) {\n          let add = node.marks[rendered++];\n          let markDOM = this.serializeMark(add, node.isInline, options);\n          if (markDOM) {\n            active.push([add, top]);\n            top.appendChild(markDOM.dom);\n            top = markDOM.contentDOM || markDOM.dom;\n          }\n        }\n      }\n      top.appendChild(this.serializeNodeInner(node, options));\n    });\n    return target;\n  }\n  serializeNodeInner(node, options) {\n    let { dom, contentDOM } = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));\n    if (contentDOM) {\n      if (node.isLeaf)\n        throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n      this.serializeFragment(node.content, options, contentDOM);\n    }\n    return dom;\n  }\n  serializeNode(node, options = {}) {\n    let dom = this.serializeNodeInner(node, options);\n    for (let i = node.marks.length - 1; i >= 0; i--) {\n      let wrap = this.serializeMark(node.marks[i], node.isInline, options);\n      if (wrap) {\n        (wrap.contentDOM || wrap.dom).appendChild(dom);\n        dom = wrap.dom;\n      }\n    }\n    return dom;\n  }\n  serializeMark(mark, inline, options = {}) {\n    let toDOM = this.marks[mark.type.name];\n    return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));\n  }\n  static renderSpec(doc2, structure, xmlNS = null) {\n    if (typeof structure == \"string\")\n      return { dom: doc2.createTextNode(structure) };\n    if (structure.nodeType != null)\n      return { dom: structure };\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure;\n    let tagName = structure[0], space = tagName.indexOf(\" \");\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space);\n      tagName = tagName.slice(space + 1);\n    }\n    let contentDOM;\n    let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);\n    let attrs = structure[1], start = 1;\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2;\n      for (let name in attrs)\n        if (attrs[name] != null) {\n          let space2 = name.indexOf(\" \");\n          if (space2 > 0)\n            dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);\n          else\n            dom.setAttribute(name, attrs[name]);\n        }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i];\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\");\n        return { dom, contentDOM: dom };\n      } else {\n        let { dom: inner, contentDOM: innerContent } = DOMSerializer.renderSpec(doc2, child, xmlNS);\n        dom.appendChild(inner);\n        if (innerContent) {\n          if (contentDOM)\n            throw new RangeError(\"Multiple content holes\");\n          contentDOM = innerContent;\n        }\n      }\n    }\n    return { dom, contentDOM };\n  }\n  static fromSchema(schema) {\n    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n  }\n  static nodesFromSchema(schema) {\n    let result = gatherToDOM(schema.nodes);\n    if (!result.text)\n      result.text = (node) => node.text;\n    return result;\n  }\n  static marksFromSchema(schema) {\n    return gatherToDOM(schema.marks);\n  }\n}\nfunction gatherToDOM(obj) {\n  let result = {};\n  for (let name in obj) {\n    let toDOM = obj[name].spec.toDOM;\n    if (toDOM)\n      result[name] = toDOM;\n  }\n  return result;\n}\nfunction doc(options) {\n  return options.document || window.document;\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-model/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-schema-list/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addListNodes\": () => (/* binding */ addListNodes),\n/* harmony export */   \"bulletList\": () => (/* binding */ bulletList),\n/* harmony export */   \"liftListItem\": () => (/* binding */ liftListItem),\n/* harmony export */   \"listItem\": () => (/* binding */ listItem),\n/* harmony export */   \"orderedList\": () => (/* binding */ orderedList),\n/* harmony export */   \"sinkListItem\": () => (/* binding */ sinkListItem),\n/* harmony export */   \"splitListItem\": () => (/* binding */ splitListItem),\n/* harmony export */   \"wrapInList\": () => (/* binding */ wrapInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n\n\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\nconst orderedList = {\n  attrs: { order: { default: 1 } },\n  parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n    return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n  } }],\n  toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n  }\n};\nconst bulletList = {\n  parseDOM: [{ tag: \"ul\" }],\n  toDOM() {\n    return ulDOM;\n  }\n};\nconst listItem = {\n  parseDOM: [{ tag: \"li\" }],\n  toDOM() {\n    return liDOM;\n  },\n  defining: true\n};\nfunction add(obj, props) {\n  let copy = {};\n  for (let prop in obj)\n    copy[prop] = obj[prop];\n  for (let prop in props)\n    copy[prop] = props[prop];\n  return copy;\n}\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n    bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n    list_item: add(listItem, { content: itemContent })\n  });\n}\nfunction wrapInList(listType, attrs = null) {\n  return function(state, dispatch) {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), doJoin = false, outerRange = range;\n    if (!range)\n      return false;\n    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n      if ($from.index(range.depth - 1) == 0)\n        return false;\n      let $insert = state.doc.resolve(range.start - 2);\n      outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($insert, $insert, range.depth);\n      if (range.endIndex < range.parent.childCount)\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n      doJoin = true;\n    }\n    let wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(outerRange, listType, attrs, range);\n    if (!wrap)\n      return false;\n    if (dispatch)\n      dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n    return true;\n  };\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n  for (let i = wrappers.length - 1; i >= 0; i--)\n    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n  let found = 0;\n  for (let i = 0; i < wrappers.length; i++)\n    if (wrappers[i].type == listType)\n      found = i + 1;\n  let splitDepth = wrappers.length - found;\n  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n  for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n    if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n    splitPos += parent.child(i).nodeSize;\n  }\n  return tr;\n}\nfunction splitListItem(itemType) {\n  return function(state, dispatch) {\n    let { $from, $to, node } = state.selection;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to))\n      return false;\n    let grandParent = $from.node(-1);\n    if (grandParent.type != itemType)\n      return false;\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1)\n        return false;\n      if (dispatch) {\n        let wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n          wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(wrap));\n        let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n        wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.createAndFill()));\n        let start = $from.before($from.depth - (depthBefore - 1));\n        let tr2 = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(wrap, 4 - depthBefore, 0));\n        let sel = -1;\n        tr2.doc.nodesBetween(start, tr2.doc.content.size, (node2, pos) => {\n          if (sel > -1)\n            return false;\n          if (node2.isTextblock && node2.content.size == 0)\n            sel = pos + 1;\n        });\n        if (sel > -1)\n          tr2.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr2.doc.resolve(sel)));\n        dispatch(tr2.scrollIntoView());\n      }\n      return true;\n    }\n    let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    let tr = state.tr.delete($from.pos, $to.pos);\n    let types = nextType ? [null, { type: nextType }] : void 0;\n    if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, $from.pos, 2, types))\n      return false;\n    if (dispatch)\n      dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\nfunction liftListItem(itemType) {\n  return function(state, dispatch) {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);\n    if (!range)\n      return false;\n    if (!dispatch)\n      return true;\n    if ($from.node(range.depth - 1).type == itemType)\n      return liftToOuterList(state, dispatch, itemType, range);\n    else\n      return liftOutOfList(state, dispatch, range);\n  };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n  if (end < endOfList) {\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n  const target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.liftTarget)(range);\n  if (target == null)\n    return false;\n  tr.lift(range, target);\n  let after = tr.mapping.map(end, -1) - 1;\n  if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, after))\n    tr.join(after);\n  dispatch(tr.scrollIntoView());\n  return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n  let tr = state.tr, list = range.parent;\n  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr.delete(pos - 1, pos + 1);\n  }\n  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n    return false;\n  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n  let parent = $start.node(-1), indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list))))\n    return false;\n  let start = $start.pos, end = start + item.nodeSize;\n  tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))).append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true;\n}\nfunction sinkListItem(itemType) {\n  return function(state, dispatch) {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);\n    if (!range)\n      return false;\n    let startIndex = range.startIndex;\n    if (startIndex == 0)\n      return false;\n    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType)\n      return false;\n    if (dispatch) {\n      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      let inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(nestedBefore ? itemType.create() : null);\n      let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n      let before = range.start, after = range.end;\n      dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n    }\n    return true;\n  };\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-schema-list/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AllSelection\": () => (/* binding */ AllSelection),\n/* harmony export */   \"EditorState\": () => (/* binding */ EditorState),\n/* harmony export */   \"NodeSelection\": () => (/* binding */ NodeSelection),\n/* harmony export */   \"Plugin\": () => (/* binding */ Plugin),\n/* harmony export */   \"PluginKey\": () => (/* binding */ PluginKey),\n/* harmony export */   \"Selection\": () => (/* binding */ Selection),\n/* harmony export */   \"SelectionRange\": () => (/* binding */ SelectionRange),\n/* harmony export */   \"TextSelection\": () => (/* binding */ TextSelection),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n\n\nconst classesById = /* @__PURE__ */ Object.create(null);\nclass Selection {\n  constructor($anchor, $head, ranges) {\n    this.$anchor = $anchor;\n    this.$head = $head;\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  }\n  get anchor() {\n    return this.$anchor.pos;\n  }\n  get head() {\n    return this.$head.pos;\n  }\n  get from() {\n    return this.$from.pos;\n  }\n  get to() {\n    return this.$to.pos;\n  }\n  get $from() {\n    return this.ranges[0].$from;\n  }\n  get $to() {\n    return this.ranges[0].$to;\n  }\n  get empty() {\n    let ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++)\n      if (ranges[i].$from.pos != ranges[i].$to.pos)\n        return false;\n    return true;\n  }\n  content() {\n    return this.$from.doc.slice(this.from, this.to, true);\n  }\n  replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    let lastNode = content.content.lastChild, lastParent = null;\n    for (let i = 0; i < content.openEnd; i++) {\n      lastParent = lastNode;\n      lastNode = lastNode.lastChild;\n    }\n    let mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);\n      if (i == 0)\n        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n    }\n  }\n  replaceWith(tr, node) {\n    let mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      let from = mapping.map($from.pos), to = mapping.map($to.pos);\n      if (i) {\n        tr.deleteRange(from, to);\n      } else {\n        tr.replaceRangeWith(from, to, node);\n        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n      }\n    }\n  }\n  static findFrom($pos, dir, textOnly = false) {\n    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n    if (inner)\n      return inner;\n    for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n      let found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n      if (found)\n        return found;\n    }\n    return null;\n  }\n  static near($pos, bias = 1) {\n    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n  }\n  static atStart(doc) {\n    return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n  }\n  static atEnd(doc) {\n    return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n  }\n  static fromJSON(doc, json) {\n    if (!json || !json.type)\n      throw new RangeError(\"Invalid input for Selection.fromJSON\");\n    let cls = classesById[json.type];\n    if (!cls)\n      throw new RangeError(`No selection type ${json.type} defined`);\n    return cls.fromJSON(doc, json);\n  }\n  static jsonID(id, selectionClass) {\n    if (id in classesById)\n      throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n    classesById[id] = selectionClass;\n    selectionClass.prototype.jsonID = id;\n    return selectionClass;\n  }\n  getBookmark() {\n    return TextSelection.between(this.$anchor, this.$head).getBookmark();\n  }\n}\nSelection.prototype.visible = true;\nclass SelectionRange {\n  constructor($from, $to) {\n    this.$from = $from;\n    this.$to = $to;\n  }\n}\nlet warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n    warnedAboutTextSelection = true;\n    console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n  }\n}\nclass TextSelection extends Selection {\n  constructor($anchor, $head = $anchor) {\n    checkTextSelection($anchor);\n    checkTextSelection($head);\n    super($anchor, $head);\n  }\n  get $cursor() {\n    return this.$anchor.pos == this.$head.pos ? this.$head : null;\n  }\n  map(doc, mapping) {\n    let $head = doc.resolve(mapping.map(this.head));\n    if (!$head.parent.inlineContent)\n      return Selection.near($head);\n    let $anchor = doc.resolve(mapping.map(this.anchor));\n    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n  }\n  replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    super.replace(tr, content);\n    if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n      let marks = this.$from.marksAcross(this.$to);\n      if (marks)\n        tr.ensureMarks(marks);\n    }\n  }\n  eq(other) {\n    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n  }\n  getBookmark() {\n    return new TextBookmark(this.anchor, this.head);\n  }\n  toJSON() {\n    return { type: \"text\", anchor: this.anchor, head: this.head };\n  }\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n      throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchor, head = anchor) {\n    let $anchor = doc.resolve(anchor);\n    return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n  }\n  static between($anchor, $head, bias) {\n    let dPos = $anchor.pos - $head.pos;\n    if (!bias || dPos)\n      bias = dPos >= 0 ? 1 : -1;\n    if (!$head.parent.inlineContent) {\n      let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n      if (found)\n        $head = found.$head;\n      else\n        return Selection.near($head, bias);\n    }\n    if (!$anchor.parent.inlineContent) {\n      if (dPos == 0) {\n        $anchor = $head;\n      } else {\n        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n        if ($anchor.pos < $head.pos != dPos < 0)\n          $anchor = $head;\n      }\n    }\n    return new TextSelection($anchor, $head);\n  }\n}\nSelection.jsonID(\"text\", TextSelection);\nclass TextBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n  }\n}\nclass NodeSelection extends Selection {\n  constructor($pos) {\n    let node = $pos.nodeAfter;\n    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    super($pos, $end);\n    this.node = node;\n  }\n  map(doc, mapping) {\n    let { deleted, pos } = mapping.mapResult(this.anchor);\n    let $pos = doc.resolve(pos);\n    if (deleted)\n      return Selection.near($pos);\n    return new NodeSelection($pos);\n  }\n  content() {\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0);\n  }\n  eq(other) {\n    return other instanceof NodeSelection && other.anchor == this.anchor;\n  }\n  toJSON() {\n    return { type: \"node\", anchor: this.anchor };\n  }\n  getBookmark() {\n    return new NodeBookmark(this.anchor);\n  }\n  static fromJSON(doc, json) {\n    if (typeof json.anchor != \"number\")\n      throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n    return new NodeSelection(doc.resolve(json.anchor));\n  }\n  static create(doc, from) {\n    return new NodeSelection(doc.resolve(from));\n  }\n  static isSelectable(node) {\n    return !node.isText && node.type.spec.selectable !== false;\n  }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nclass NodeBookmark {\n  constructor(anchor) {\n    this.anchor = anchor;\n  }\n  map(mapping) {\n    let { deleted, pos } = mapping.mapResult(this.anchor);\n    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n  }\n  resolve(doc) {\n    let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n    if (node && NodeSelection.isSelectable(node))\n      return new NodeSelection($pos);\n    return Selection.near($pos);\n  }\n}\nclass AllSelection extends Selection {\n  constructor(doc) {\n    super(doc.resolve(0), doc.resolve(doc.content.size));\n  }\n  replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n      tr.delete(0, tr.doc.content.size);\n      let sel = Selection.atStart(tr.doc);\n      if (!sel.eq(tr.selection))\n        tr.setSelection(sel);\n    } else {\n      super.replace(tr, content);\n    }\n  }\n  toJSON() {\n    return { type: \"all\" };\n  }\n  static fromJSON(doc) {\n    return new AllSelection(doc);\n  }\n  map(doc) {\n    return new AllSelection(doc);\n  }\n  eq(other) {\n    return other instanceof AllSelection;\n  }\n  getBookmark() {\n    return AllBookmark;\n  }\n}\nSelection.jsonID(\"all\", AllSelection);\nconst AllBookmark = {\n  map() {\n    return this;\n  },\n  resolve(doc) {\n    return new AllSelection(doc);\n  }\n};\nfunction findSelectionIn(doc, node, pos, index, dir, text = false) {\n  if (node.inlineContent)\n    return TextSelection.create(doc, pos);\n  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    let child = node.child(i);\n    if (!child.isAtom) {\n      let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner)\n        return inner;\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n    }\n    pos += child.nodeSize * dir;\n  }\n  return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  let last = tr.steps.length - 1;\n  if (last < startLen)\n    return;\n  let step = tr.steps[last];\n  if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep))\n    return;\n  let map = tr.mapping.maps[last], end;\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end == null)\n      end = newTo;\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\nclass Transaction extends prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform {\n  constructor(state) {\n    super(state.doc);\n    this.curSelectionFor = 0;\n    this.updated = 0;\n    this.meta = /* @__PURE__ */ Object.create(null);\n    this.time = Date.now();\n    this.curSelection = state.selection;\n    this.storedMarks = state.storedMarks;\n  }\n  get selection() {\n    if (this.curSelectionFor < this.steps.length) {\n      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n      this.curSelectionFor = this.steps.length;\n    }\n    return this.curSelection;\n  }\n  setSelection(selection) {\n    if (selection.$from.doc != this.doc)\n      throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n    this.curSelection = selection;\n    this.curSelectionFor = this.steps.length;\n    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n    this.storedMarks = null;\n    return this;\n  }\n  get selectionSet() {\n    return (this.updated & UPDATED_SEL) > 0;\n  }\n  setStoredMarks(marks) {\n    this.storedMarks = marks;\n    this.updated |= UPDATED_MARKS;\n    return this;\n  }\n  ensureMarks(marks) {\n    if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n      this.setStoredMarks(marks);\n    return this;\n  }\n  addStoredMark(mark) {\n    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n  }\n  removeStoredMark(mark) {\n    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n  }\n  get storedMarksSet() {\n    return (this.updated & UPDATED_MARKS) > 0;\n  }\n  addStep(step, doc) {\n    super.addStep(step, doc);\n    this.updated = this.updated & ~UPDATED_MARKS;\n    this.storedMarks = null;\n  }\n  setTime(time) {\n    this.time = time;\n    return this;\n  }\n  replaceSelection(slice) {\n    this.selection.replace(this, slice);\n    return this;\n  }\n  replaceSelectionWith(node, inheritMarks = true) {\n    let selection = this.selection;\n    if (inheritMarks)\n      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none));\n    selection.replaceWith(this, node);\n    return this;\n  }\n  deleteSelection() {\n    this.selection.replace(this);\n    return this;\n  }\n  insertText(text, from, to) {\n    let schema = this.doc.type.schema;\n    if (from == null) {\n      if (!text)\n        return this.deleteSelection();\n      return this.replaceSelectionWith(schema.text(text), true);\n    } else {\n      if (to == null)\n        to = from;\n      to = to == null ? from : to;\n      if (!text)\n        return this.deleteRange(from, to);\n      let marks = this.storedMarks;\n      if (!marks) {\n        let $from = this.doc.resolve(from);\n        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n      }\n      this.replaceRangeWith(from, to, schema.text(text, marks));\n      if (!this.selection.empty)\n        this.setSelection(Selection.near(this.selection.$to));\n      return this;\n    }\n  }\n  setMeta(key, value) {\n    this.meta[typeof key == \"string\" ? key : key.key] = value;\n    return this;\n  }\n  getMeta(key) {\n    return this.meta[typeof key == \"string\" ? key : key.key];\n  }\n  get isGeneric() {\n    for (let _ in this.meta)\n      return false;\n    return true;\n  }\n  scrollIntoView() {\n    this.updated |= UPDATED_SCROLL;\n    return this;\n  }\n  get scrolledIntoView() {\n    return (this.updated & UPDATED_SCROLL) > 0;\n  }\n}\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self);\n}\nclass FieldDesc {\n  constructor(name, desc, self) {\n    this.name = name;\n    this.init = bind(desc.init, self);\n    this.apply = bind(desc.apply, self);\n  }\n}\nconst baseFields = [\n  new FieldDesc(\"doc\", {\n    init(config) {\n      return config.doc || config.schema.topNodeType.createAndFill();\n    },\n    apply(tr) {\n      return tr.doc;\n    }\n  }),\n  new FieldDesc(\"selection\", {\n    init(config, instance) {\n      return config.selection || Selection.atStart(instance.doc);\n    },\n    apply(tr) {\n      return tr.selection;\n    }\n  }),\n  new FieldDesc(\"storedMarks\", {\n    init(config) {\n      return config.storedMarks || null;\n    },\n    apply(tr, _marks, _old, state) {\n      return state.selection.$cursor ? tr.storedMarks : null;\n    }\n  }),\n  new FieldDesc(\"scrollToSelection\", {\n    init() {\n      return 0;\n    },\n    apply(tr, prev) {\n      return tr.scrolledIntoView ? prev + 1 : prev;\n    }\n  })\n];\nclass Configuration {\n  constructor(schema, plugins) {\n    this.schema = schema;\n    this.plugins = [];\n    this.pluginsByKey = /* @__PURE__ */ Object.create(null);\n    this.fields = baseFields.slice();\n    if (plugins)\n      plugins.forEach((plugin) => {\n        if (this.pluginsByKey[plugin.key])\n          throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n        this.plugins.push(plugin);\n        this.pluginsByKey[plugin.key] = plugin;\n        if (plugin.spec.state)\n          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n      });\n  }\n}\nclass EditorState {\n  constructor(config) {\n    this.config = config;\n  }\n  get schema() {\n    return this.config.schema;\n  }\n  get plugins() {\n    return this.config.plugins;\n  }\n  apply(tr) {\n    return this.applyTransaction(tr).state;\n  }\n  filterTransaction(tr, ignore = -1) {\n    for (let i = 0; i < this.config.plugins.length; i++)\n      if (i != ignore) {\n        let plugin = this.config.plugins[i];\n        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n          return false;\n      }\n    return true;\n  }\n  applyTransaction(rootTr) {\n    if (!this.filterTransaction(rootTr))\n      return { state: this, transactions: [] };\n    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n    for (; ; ) {\n      let haveNew = false;\n      for (let i = 0; i < this.config.plugins.length; i++) {\n        let plugin = this.config.plugins[i];\n        if (plugin.spec.appendTransaction) {\n          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n          if (tr && newState.filterTransaction(tr, i)) {\n            tr.setMeta(\"appendedTransaction\", rootTr);\n            if (!seen) {\n              seen = [];\n              for (let j = 0; j < this.config.plugins.length; j++)\n                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n            }\n            trs.push(tr);\n            newState = newState.applyInner(tr);\n            haveNew = true;\n          }\n          if (seen)\n            seen[i] = { state: newState, n: trs.length };\n        }\n      }\n      if (!haveNew)\n        return { state: newState, transactions: trs };\n    }\n  }\n  applyInner(tr) {\n    if (!tr.before.eq(this.doc))\n      throw new RangeError(\"Applying a mismatched transaction\");\n    let newInstance = new EditorState(this.config), fields = this.config.fields;\n    for (let i = 0; i < fields.length; i++) {\n      let field = fields[i];\n      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n    }\n    return newInstance;\n  }\n  get tr() {\n    return new Transaction(this);\n  }\n  static create(config) {\n    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n    let instance = new EditorState($config);\n    for (let i = 0; i < $config.fields.length; i++)\n      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n    return instance;\n  }\n  reconfigure(config) {\n    let $config = new Configuration(this.schema, config.plugins);\n    let fields = $config.fields, instance = new EditorState($config);\n    for (let i = 0; i < fields.length; i++) {\n      let name = fields[i].name;\n      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n    }\n    return instance;\n  }\n  toJSON(pluginFields) {\n    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n    if (this.storedMarks)\n      result.storedMarks = this.storedMarks.map((m) => m.toJSON());\n    if (pluginFields && typeof pluginFields == \"object\")\n      for (let prop in pluginFields) {\n        if (prop == \"doc\" || prop == \"selection\")\n          throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n        let plugin = pluginFields[prop], state = plugin.spec.state;\n        if (state && state.toJSON)\n          result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n      }\n    return result;\n  }\n  static fromJSON(config, json, pluginFields) {\n    if (!json)\n      throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n    if (!config.schema)\n      throw new RangeError(\"Required config field 'schema' missing\");\n    let $config = new Configuration(config.schema, config.plugins);\n    let instance = new EditorState($config);\n    $config.fields.forEach((field) => {\n      if (field.name == \"doc\") {\n        instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);\n      } else if (field.name == \"selection\") {\n        instance.selection = Selection.fromJSON(instance.doc, json.selection);\n      } else if (field.name == \"storedMarks\") {\n        if (json.storedMarks)\n          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n      } else {\n        if (pluginFields)\n          for (let prop in pluginFields) {\n            let plugin = pluginFields[prop], state = plugin.spec.state;\n            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {\n              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n              return;\n            }\n          }\n        instance[field.name] = field.init(config, instance);\n      }\n    });\n    return instance;\n  }\n}\nfunction bindProps(obj, self, target) {\n  for (let prop in obj) {\n    let val = obj[prop];\n    if (val instanceof Function)\n      val = val.bind(self);\n    else if (prop == \"handleDOMEvents\")\n      val = bindProps(val, self, {});\n    target[prop] = val;\n  }\n  return target;\n}\nclass Plugin {\n  constructor(spec) {\n    this.spec = spec;\n    this.props = {};\n    if (spec.props)\n      bindProps(spec.props, this, this.props);\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n  }\n  getState(state) {\n    return state[this.key];\n  }\n}\nconst keys = /* @__PURE__ */ Object.create(null);\nfunction createKey(name) {\n  if (name in keys)\n    return name + \"$\" + ++keys[name];\n  keys[name] = 0;\n  return name + \"$\";\n}\nclass PluginKey {\n  constructor(name = \"key\") {\n    this.key = createKey(name);\n  }\n  get(state) {\n    return state.config.pluginsByKey[this.key];\n  }\n  getState(state) {\n    return state[this.key];\n  }\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-state/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-transform/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddMarkStep\": () => (/* binding */ AddMarkStep),\n/* harmony export */   \"AddNodeMarkStep\": () => (/* binding */ AddNodeMarkStep),\n/* harmony export */   \"AttrStep\": () => (/* binding */ AttrStep),\n/* harmony export */   \"MapResult\": () => (/* binding */ MapResult),\n/* harmony export */   \"Mapping\": () => (/* binding */ Mapping),\n/* harmony export */   \"RemoveMarkStep\": () => (/* binding */ RemoveMarkStep),\n/* harmony export */   \"RemoveNodeMarkStep\": () => (/* binding */ RemoveNodeMarkStep),\n/* harmony export */   \"ReplaceAroundStep\": () => (/* binding */ ReplaceAroundStep),\n/* harmony export */   \"ReplaceStep\": () => (/* binding */ ReplaceStep),\n/* harmony export */   \"Step\": () => (/* binding */ Step),\n/* harmony export */   \"StepMap\": () => (/* binding */ StepMap),\n/* harmony export */   \"StepResult\": () => (/* binding */ StepResult),\n/* harmony export */   \"Transform\": () => (/* binding */ Transform),\n/* harmony export */   \"TransformError\": () => (/* binding */ TransformError),\n/* harmony export */   \"canJoin\": () => (/* binding */ canJoin),\n/* harmony export */   \"canSplit\": () => (/* binding */ canSplit),\n/* harmony export */   \"dropPoint\": () => (/* binding */ dropPoint),\n/* harmony export */   \"findWrapping\": () => (/* binding */ findWrapping),\n/* harmony export */   \"insertPoint\": () => (/* binding */ insertPoint),\n/* harmony export */   \"joinPoint\": () => (/* binding */ joinPoint),\n/* harmony export */   \"liftTarget\": () => (/* binding */ liftTarget),\n/* harmony export */   \"replaceStep\": () => (/* binding */ replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n\nconst lower16 = 65535;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) {\n  return index + offset * factor16;\n}\nfunction recoverIndex(value) {\n  return value & lower16;\n}\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n}\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\nclass MapResult {\n  constructor(pos, delInfo, recover) {\n    this.pos = pos;\n    this.delInfo = delInfo;\n    this.recover = recover;\n  }\n  get deleted() {\n    return (this.delInfo & DEL_SIDE) > 0;\n  }\n  get deletedBefore() {\n    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n  }\n  get deletedAfter() {\n    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n  }\n  get deletedAcross() {\n    return (this.delInfo & DEL_ACROSS) > 0;\n  }\n}\nclass StepMap {\n  constructor(ranges, inverted = false) {\n    this.ranges = ranges;\n    this.inverted = inverted;\n    if (!ranges.length && StepMap.empty)\n      return StepMap.empty;\n  }\n  recover(value) {\n    let diff = 0, index = recoverIndex(value);\n    if (!this.inverted)\n      for (let i = 0; i < index; i++)\n        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n    return this.ranges[index * 3] + diff + recoverOffset(value);\n  }\n  mapResult(pos, assoc = 1) {\n    return this._map(pos, assoc, false);\n  }\n  map(pos, assoc = 1) {\n    return this._map(pos, assoc, true);\n  }\n  _map(pos, assoc, simple) {\n    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0);\n      if (start > pos)\n        break;\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n      if (pos <= end) {\n        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n        let result = start + diff + (side < 0 ? 0 : newSize);\n        if (simple)\n          return result;\n        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n        if (assoc < 0 ? pos != start : pos != end)\n          del |= DEL_SIDE;\n        return new MapResult(result, del, recover);\n      }\n      diff += newSize - oldSize;\n    }\n    return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n  }\n  touches(pos, recover) {\n    let diff = 0, index = recoverIndex(recover);\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n    for (let i = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i] - (this.inverted ? diff : 0);\n      if (start > pos)\n        break;\n      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n      if (pos <= end && i == index * 3)\n        return true;\n      diff += this.ranges[i + newIndex] - oldSize;\n    }\n    return false;\n  }\n  forEach(f) {\n    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n      diff += newSize - oldSize;\n    }\n  }\n  invert() {\n    return new StepMap(this.ranges, !this.inverted);\n  }\n  toString() {\n    return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n  }\n  static offset(n) {\n    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n  }\n}\nStepMap.empty = new StepMap([]);\nclass Mapping {\n  constructor(maps = [], mirror, from = 0, to = maps.length) {\n    this.maps = maps;\n    this.mirror = mirror;\n    this.from = from;\n    this.to = to;\n  }\n  slice(from = 0, to = this.maps.length) {\n    return new Mapping(this.maps, this.mirror, from, to);\n  }\n  copy() {\n    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n  }\n  appendMap(map, mirrors) {\n    this.to = this.maps.push(map);\n    if (mirrors != null)\n      this.setMirror(this.maps.length - 1, mirrors);\n  }\n  appendMapping(mapping) {\n    for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n      let mirr = mapping.getMirror(i);\n      this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);\n    }\n  }\n  getMirror(n) {\n    if (this.mirror) {\n      for (let i = 0; i < this.mirror.length; i++)\n        if (this.mirror[i] == n)\n          return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n  }\n  setMirror(n, m) {\n    if (!this.mirror)\n      this.mirror = [];\n    this.mirror.push(n, m);\n  }\n  appendMappingInverted(mapping) {\n    for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n      let mirr = mapping.getMirror(i);\n      this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);\n    }\n  }\n  invert() {\n    let inverse = new Mapping();\n    inverse.appendMappingInverted(this);\n    return inverse;\n  }\n  map(pos, assoc = 1) {\n    if (this.mirror)\n      return this._map(pos, assoc, true);\n    for (let i = this.from; i < this.to; i++)\n      pos = this.maps[i].map(pos, assoc);\n    return pos;\n  }\n  mapResult(pos, assoc = 1) {\n    return this._map(pos, assoc, false);\n  }\n  _map(pos, assoc, simple) {\n    let delInfo = 0;\n    for (let i = this.from; i < this.to; i++) {\n      let map = this.maps[i], result = map.mapResult(pos, assoc);\n      if (result.recover != null) {\n        let corr = this.getMirror(i);\n        if (corr != null && corr > i && corr < this.to) {\n          i = corr;\n          pos = this.maps[corr].recover(result.recover);\n          continue;\n        }\n      }\n      delInfo |= result.delInfo;\n      pos = result.pos;\n    }\n    return simple ? pos : new MapResult(pos, delInfo, null);\n  }\n}\nconst stepsByID = /* @__PURE__ */ Object.create(null);\nclass Step {\n  getMap() {\n    return StepMap.empty;\n  }\n  merge(other) {\n    return null;\n  }\n  static fromJSON(schema, json) {\n    if (!json || !json.stepType)\n      throw new RangeError(\"Invalid input for Step.fromJSON\");\n    let type = stepsByID[json.stepType];\n    if (!type)\n      throw new RangeError(`No step type ${json.stepType} defined`);\n    return type.fromJSON(schema, json);\n  }\n  static jsonID(id, stepClass) {\n    if (id in stepsByID)\n      throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n    stepsByID[id] = stepClass;\n    stepClass.prototype.jsonID = id;\n    return stepClass;\n  }\n}\nclass StepResult {\n  constructor(doc, failed) {\n    this.doc = doc;\n    this.failed = failed;\n  }\n  static ok(doc) {\n    return new StepResult(doc, null);\n  }\n  static fail(message) {\n    return new StepResult(null, message);\n  }\n  static fromReplace(doc, from, to, slice) {\n    try {\n      return StepResult.ok(doc.replace(from, to, slice));\n    } catch (e) {\n      if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError)\n        return StepResult.fail(e.message);\n      throw e;\n    }\n  }\n}\nfunction mapFragment(fragment, f, parent) {\n  let mapped = [];\n  for (let i = 0; i < fragment.childCount; i++) {\n    let child = fragment.child(i);\n    if (child.content.size)\n      child = child.copy(mapFragment(child.content, f, child));\n    if (child.isInline)\n      child = f(child, parent, i);\n    mapped.push(child);\n  }\n  return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);\n}\nclass AddMarkStep extends Step {\n  constructor(from, to, mark) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.mark = mark;\n  }\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n    let parent = $from.node($from.sharedDepth(this.to));\n    let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node, parent2) => {\n      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))\n        return node;\n      return node.mark(this.mark.addToSet(node.marks));\n    }, parent), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice);\n  }\n  invert() {\n    return new RemoveMarkStep(this.from, this.to, this.mark);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos)\n      return null;\n    return new AddMarkStep(from.pos, to.pos, this.mark);\n  }\n  merge(other) {\n    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)\n      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    return null;\n  }\n  toJSON() {\n    return {\n      stepType: \"addMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n  }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\nclass RemoveMarkStep extends Step {\n  constructor(from, to, mark) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.mark = mark;\n  }\n  apply(doc) {\n    let oldSlice = doc.slice(this.from, this.to);\n    let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node) => {\n      return node.mark(this.mark.removeFromSet(node.marks));\n    }, doc), oldSlice.openStart, oldSlice.openEnd);\n    return StepResult.fromReplace(doc, this.from, this.to, slice);\n  }\n  invert() {\n    return new AddMarkStep(this.from, this.to, this.mark);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deleted && to.deleted || from.pos >= to.pos)\n      return null;\n    return new RemoveMarkStep(from.pos, to.pos, this.mark);\n  }\n  merge(other) {\n    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)\n      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n    return null;\n  }\n  toJSON() {\n    return {\n      stepType: \"removeMark\",\n      mark: this.mark.toJSON(),\n      from: this.from,\n      to: this.to\n    };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n  }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\nclass AddNodeMarkStep extends Step {\n  constructor(pos, mark) {\n    super();\n    this.pos = pos;\n    this.mark = mark;\n  }\n  apply(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (!node)\n      return StepResult.fail(\"No node at mark step's position\");\n    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  invert(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (node) {\n      let newSet = this.mark.addToSet(node.marks);\n      if (newSet.length == node.marks.length) {\n        for (let i = 0; i < node.marks.length; i++)\n          if (!node.marks[i].isInSet(newSet))\n            return new AddNodeMarkStep(this.pos, node.marks[i]);\n        return new AddNodeMarkStep(this.pos, this.mark);\n      }\n    }\n    return new RemoveNodeMarkStep(this.pos, this.mark);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n  }\n  toJSON() {\n    return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.pos != \"number\")\n      throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n  }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\nclass RemoveNodeMarkStep extends Step {\n  constructor(pos, mark) {\n    super();\n    this.pos = pos;\n    this.mark = mark;\n  }\n  apply(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (!node)\n      return StepResult.fail(\"No node at mark step's position\");\n    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  invert(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (!node || !this.mark.isInSet(node.marks))\n      return this;\n    return new AddNodeMarkStep(this.pos, this.mark);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n  }\n  toJSON() {\n    return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.pos != \"number\")\n      throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n  }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\nclass ReplaceStep extends Step {\n  constructor(from, to, slice, structure = false) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.slice = slice;\n    this.structure = structure;\n  }\n  apply(doc) {\n    if (this.structure && contentBetween(doc, this.from, this.to))\n      return StepResult.fail(\"Structure replace would overwrite content\");\n    return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n  }\n  getMap() {\n    return new StepMap([this.from, this.to - this.from, this.slice.size]);\n  }\n  invert(doc) {\n    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    if (from.deletedAcross && to.deletedAcross)\n      return null;\n    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n  }\n  merge(other) {\n    if (!(other instanceof ReplaceStep) || other.structure || this.structure)\n      return null;\n    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n      let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n      let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n      return new ReplaceStep(other.from, this.to, slice, this.structure);\n    } else {\n      return null;\n    }\n  }\n  toJSON() {\n    let json = { stepType: \"replace\", from: this.from, to: this.to };\n    if (this.slice.size)\n      json.slice = this.slice.toJSON();\n    if (this.structure)\n      json.structure = true;\n    return json;\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n    return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);\n  }\n}\nStep.jsonID(\"replace\", ReplaceStep);\nclass ReplaceAroundStep extends Step {\n  constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {\n    super();\n    this.from = from;\n    this.to = to;\n    this.gapFrom = gapFrom;\n    this.gapTo = gapTo;\n    this.slice = slice;\n    this.insert = insert;\n    this.structure = structure;\n  }\n  apply(doc) {\n    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to)))\n      return StepResult.fail(\"Structure gap-replace would overwrite content\");\n    let gap = doc.slice(this.gapFrom, this.gapTo);\n    if (gap.openStart || gap.openEnd)\n      return StepResult.fail(\"Gap is not a flat range\");\n    let inserted = this.slice.insertAt(this.insert, gap.content);\n    if (!inserted)\n      return StepResult.fail(\"Content does not fit in gap\");\n    return StepResult.fromReplace(doc, this.from, this.to, inserted);\n  }\n  getMap() {\n    return new StepMap([\n      this.from,\n      this.gapFrom - this.from,\n      this.insert,\n      this.gapTo,\n      this.to - this.gapTo,\n      this.slice.size - this.insert\n    ]);\n  }\n  invert(doc) {\n    let gap = this.gapTo - this.gapFrom;\n    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n  }\n  map(mapping) {\n    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);\n    if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)\n      return null;\n    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n  }\n  toJSON() {\n    let json = {\n      stepType: \"replaceAround\",\n      from: this.from,\n      to: this.to,\n      gapFrom: this.gapFrom,\n      gapTo: this.gapTo,\n      insert: this.insert\n    };\n    if (this.slice.size)\n      json.slice = this.slice.toJSON();\n    if (this.structure)\n      json.structure = true;\n    return json;\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n      throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n  }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n  let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n  if (dist > 0) {\n    let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n    while (dist > 0) {\n      if (!next || next.isLeaf)\n        return true;\n      next = next.firstChild;\n      dist--;\n    }\n  }\n  return false;\n}\nfunction addMark(tr, from, to, mark) {\n  let removed = [], added = [];\n  let removing, adding;\n  tr.doc.nodesBetween(from, to, (node, pos, parent) => {\n    if (!node.isInline)\n      return;\n    let marks = node.marks;\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n      let newSet = mark.addToSet(marks);\n      for (let i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i]))\n            removing.to = end;\n          else\n            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n        }\n      }\n      if (adding && adding.to == start)\n        adding.to = end;\n      else\n        added.push(adding = new AddMarkStep(start, end, mark));\n    }\n  });\n  removed.forEach((s) => tr.step(s));\n  added.forEach((s) => tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n  let matched = [], step = 0;\n  tr.doc.nodesBetween(from, to, (node, pos) => {\n    if (!node.isInline)\n      return;\n    step++;\n    let toRemove = null;\n    if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {\n      let set = node.marks, found;\n      while (found = mark.isInSet(set)) {\n        (toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks))\n        toRemove = [mark];\n    } else {\n      toRemove = node.marks;\n    }\n    if (toRemove && toRemove.length) {\n      let end = Math.min(pos + node.nodeSize, to);\n      for (let i = 0; i < toRemove.length; i++) {\n        let style = toRemove[i], found;\n        for (let j = 0; j < matched.length; j++) {\n          let m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style))\n            found = m;\n        }\n        if (found) {\n          found.to = end;\n          found.step = step;\n        } else {\n          matched.push({ style, from: Math.max(pos, from), to: end, step });\n        }\n      }\n    }\n  });\n  matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch) {\n  let node = tr.doc.nodeAt(pos);\n  let delSteps = [], cur = pos + 1;\n  for (let i = 0; i < node.childCount; i++) {\n    let child = node.child(i), end = cur + child.nodeSize;\n    let allowed = match.matchType(child.type);\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));\n    } else {\n      match = allowed;\n      for (let j = 0; j < child.marks.length; j++)\n        if (!parentType.allowsMarkType(child.marks[j].type))\n          tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n    }\n    cur = end;\n  }\n  if (!match.validEnd) {\n    let fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));\n  }\n  for (let i = delSteps.length - 1; i >= 0; i--)\n    tr.step(delSteps[i]);\n}\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n}\nfunction liftTarget(range) {\n  let parent = range.parent;\n  let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n  for (let depth = range.depth; ; --depth) {\n    let node = range.$from.node(depth);\n    let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n    if (depth < range.depth && node.canReplace(index, endIndex, content))\n      return depth;\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n      break;\n  }\n  return null;\n}\nfunction lift(tr, range, target) {\n  let { $from, $to, depth } = range;\n  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n  let start = gapStart, end = gapEnd;\n  let before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    }\n  let after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;\n  for (let d = depth, splitting = false; d > target; d--)\n    if (splitting || $to.after(d + 1) < $to.end(d)) {\n      splitting = true;\n      after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    }\n  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\nfunction findWrapping(range, nodeType, attrs = null, innerRange = range) {\n  let around = findWrappingOutside(range, nodeType);\n  let inner = around && findWrappingInside(innerRange, nodeType);\n  if (!inner)\n    return null;\n  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) {\n  return { type, attrs: null };\n}\nfunction findWrappingOutside(range, type) {\n  let { parent, startIndex, endIndex } = range;\n  let around = parent.contentMatchAt(startIndex).findWrapping(type);\n  if (!around)\n    return null;\n  let outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n  let { parent, startIndex, endIndex } = range;\n  let inner = parent.child(startIndex);\n  let inside = type.contentMatch.findWrapping(inner.type);\n  if (!inside)\n    return null;\n  let lastType = inside.length ? inside[inside.length - 1] : type;\n  let innerMatch = lastType.contentMatch;\n  for (let i = startIndex; innerMatch && i < endIndex; i++)\n    innerMatch = innerMatch.matchType(parent.child(i).type);\n  if (!innerMatch || !innerMatch.validEnd)\n    return null;\n  return inside;\n}\nfunction wrap(tr, range, wrappers) {\n  let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n  for (let i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      let match = wrappers[i].type.contentMatch.matchFragment(content);\n      if (!match || !match.validEnd)\n        throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n    }\n    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n  let start = range.start, end = range.end;\n  tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n  if (!type.isTextblock)\n    throw new RangeError(\"Type given to setBlockType should be a textblock\");\n  let mapFrom = tr.steps.length;\n  tr.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);\n      let mapping = tr.mapping.slice(mapFrom);\n      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false;\n    }\n  });\n}\nfunction canChangeType(doc, pos, type) {\n  let $pos = doc.resolve(pos), index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n}\nfunction setNodeMarkup(tr, pos, type, attrs, marks) {\n  let node = tr.doc.nodeAt(pos);\n  if (!node)\n    throw new RangeError(\"No node at given position\");\n  if (!type)\n    type = node.type;\n  let newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf)\n    return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n  if (!type.validContent(node.content))\n    throw new RangeError(\"Invalid content for node type \" + type.name);\n  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));\n}\nfunction canSplit(doc, pos, depth = 1, typesAfter) {\n  let $pos = doc.resolve(pos), base = $pos.depth - depth;\n  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n    return false;\n  for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    let node = $pos.node(d), index2 = $pos.index(d);\n    if (node.type.spec.isolating)\n      return false;\n    let rest = node.content.cutByIndex(index2, node.childCount);\n    let after = typesAfter && typesAfter[i] || node;\n    if (after != node)\n      rest = rest.replaceChild(0, after.type.create(after.attrs));\n    if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))\n      return false;\n  }\n  let index = $pos.indexAfter(base);\n  let baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n  let $pos = tr.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));\n    let typeAfter = typesAfter && typesAfter[i];\n    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n  tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));\n}\nfunction canJoin(doc, pos) {\n  let $pos = doc.resolve(pos), index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\nfunction joinable(a, b) {\n  return !!(a && b && !a.isLeaf && a.canAppend(b));\n}\nfunction joinPoint(doc, pos, dir = -1) {\n  let $pos = doc.resolve(pos);\n  for (let d = $pos.depth; ; d--) {\n    let before, after, index = $pos.index(d);\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1))\n      return pos;\n    if (d == 0)\n      break;\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\nfunction join(tr, pos, depth) {\n  let step = new ReplaceStep(pos - depth, pos + depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true);\n  tr.step(step);\n}\nfunction insertPoint(doc, pos, nodeType) {\n  let $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n    return pos;\n  if ($pos.parentOffset == 0)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.index(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType))\n        return $pos.before(d + 1);\n      if (index > 0)\n        return null;\n    }\n  if ($pos.parentOffset == $pos.parent.content.size)\n    for (let d = $pos.depth - 1; d >= 0; d--) {\n      let index = $pos.indexAfter(d);\n      if ($pos.node(d).canReplaceWith(index, index, nodeType))\n        return $pos.after(d + 1);\n      if (index < $pos.node(d).childCount)\n        return null;\n    }\n  return null;\n}\nfunction dropPoint(doc, pos, slice) {\n  let $pos = doc.resolve(pos);\n  if (!slice.content.size)\n    return pos;\n  let content = slice.content;\n  for (let i = 0; i < slice.openStart; i++)\n    content = content.firstChild.content;\n  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (let d = $pos.depth; d >= 0; d--) {\n      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      let parent = $pos.node(d), fits = false;\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n      if (fits)\n        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n    }\n  }\n  return null;\n}\nfunction replaceStep(doc, from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n  if (from == to && !slice.size)\n    return null;\n  let $from = doc.resolve(from), $to = doc.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    return new ReplaceStep(from, to, slice);\n  return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\nclass Fitter {\n  constructor($from, $to, unplaced) {\n    this.$from = $from;\n    this.$to = $to;\n    this.unplaced = unplaced;\n    this.frontier = [];\n    this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let i = 0; i <= $from.depth; i++) {\n      let node = $from.node(i);\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      });\n    }\n    for (let i = $from.depth; i > 0; i--)\n      this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i).copy(this.placed));\n  }\n  get depth() {\n    return this.frontier.length - 1;\n  }\n  fit() {\n    while (this.unplaced.size) {\n      let fit = this.findFittable();\n      if (fit)\n        this.placeNodes(fit);\n      else\n        this.openMore() || this.dropNode();\n    }\n    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n    if (!$to)\n      return null;\n    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n    while (openStart && openEnd && content.childCount == 1) {\n      content = content.firstChild.content;\n      openStart--;\n      openEnd--;\n    }\n    let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n    if (moveInline > -1)\n      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n    if (slice.size || $from.pos != this.$to.pos)\n      return new ReplaceStep($from.pos, $to.pos, slice);\n    return null;\n  }\n  findFittable() {\n    for (let pass = 1; pass <= 2; pass++) {\n      for (let sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n        let fragment, parent = null;\n        if (sliceDepth) {\n          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n          fragment = parent.content;\n        } else {\n          fragment = this.unplaced.content;\n        }\n        let first = fragment.firstChild;\n        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;\n          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type)))\n            return { sliceDepth, frontierDepth, parent, inject };\n          else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))\n            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };\n          if (parent && match.matchType(parent.type))\n            break;\n        }\n      }\n    }\n  }\n  openMore() {\n    let { content, openStart, openEnd } = this.unplaced;\n    let inner = contentAt(content, openStart);\n    if (!inner.childCount || inner.firstChild.isLeaf)\n      return false;\n    this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n    return true;\n  }\n  dropNode() {\n    let { content, openStart, openEnd } = this.unplaced;\n    let inner = contentAt(content, openStart);\n    if (inner.childCount <= 1 && openStart > 0) {\n      let openAtEnd = content.size - openStart <= openStart + inner.size;\n      this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n    } else {\n      this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n    }\n  }\n  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {\n    while (this.depth > frontierDepth)\n      this.closeFrontierNode();\n    if (wrap2)\n      for (let i = 0; i < wrap2.length; i++)\n        this.openFrontierNode(wrap2[i]);\n    let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n    let openStart = slice.openStart - sliceDepth;\n    let taken = 0, add = [];\n    let { match, type } = this.frontier[frontierDepth];\n    if (inject) {\n      for (let i = 0; i < inject.childCount; i++)\n        add.push(inject.child(i));\n      match = match.matchFragment(inject);\n    }\n    let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);\n    while (taken < fragment.childCount) {\n      let next = fragment.child(taken), matches = match.matchType(next.type);\n      if (!matches)\n        break;\n      taken++;\n      if (taken > 1 || openStart == 0 || next.content.size) {\n        match = matches;\n        add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n      }\n    }\n    let toEnd = taken == fragment.childCount;\n    if (!toEnd)\n      openEndCount = -1;\n    this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));\n    this.frontier[frontierDepth].match = match;\n    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n      this.closeFrontierNode();\n    for (let i = 0, cur = fragment; i < openEndCount; i++) {\n      let node = cur.lastChild;\n      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n      cur = node.content;\n    }\n    this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n  }\n  mustMoveInline() {\n    if (!this.$to.parent.isTextblock)\n      return -1;\n    let top = this.frontier[this.depth], level;\n    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)\n      return -1;\n    let { depth } = this.$to, after = this.$to.after(depth);\n    while (depth > 1 && after == this.$to.end(--depth))\n      ++after;\n    return after;\n  }\n  findCloseLevel($to) {\n    scan:\n      for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n        let { match, type } = this.frontier[i];\n        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n        let fit = contentAfterFits($to, i, type, match, dropInner);\n        if (!fit)\n          continue;\n        for (let d = i - 1; d >= 0; d--) {\n          let { match: match2, type: type2 } = this.frontier[d];\n          let matches = contentAfterFits($to, d, type2, match2, true);\n          if (!matches || matches.childCount)\n            continue scan;\n        }\n        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n      }\n  }\n  close($to) {\n    let close = this.findCloseLevel($to);\n    if (!close)\n      return null;\n    while (this.depth > close.depth)\n      this.closeFrontierNode();\n    if (close.fit.childCount)\n      this.placed = addToFragment(this.placed, close.depth, close.fit);\n    $to = close.move;\n    for (let d = close.depth + 1; d <= $to.depth; d++) {\n      let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n      this.openFrontierNode(node.type, node.attrs, add);\n    }\n    return $to;\n  }\n  openFrontierNode(type, attrs = null, content) {\n    let top = this.frontier[this.depth];\n    top.match = top.match.matchType(type);\n    this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));\n    this.frontier.push({ type, match: type.contentMatch });\n  }\n  closeFrontierNode() {\n    let open = this.frontier.pop();\n    let add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    if (add.childCount)\n      this.placed = addToFragment(this.placed, this.frontier.length, add);\n  }\n}\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0)\n    return fragment.cutByIndex(count, fragment.childCount);\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0)\n    return fragment.append(content);\n  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n  for (let i = 0; i < depth; i++)\n    fragment = fragment.firstChild.content;\n  return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0)\n    return node;\n  let frag = node.content;\n  if (openStart > 1)\n    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0)\n      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n  }\n  return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type))\n    return null;\n  let fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n  for (let i = start; i < fragment.childCount; i++)\n    if (!type.allowsMarks(fragment.child(i).marks))\n      return true;\n  return false;\n}\nfunction definesContent(type) {\n  return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n  if (!slice.size)\n    return tr.deleteRange(from, to);\n  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice))\n    return tr.step(new ReplaceStep(from, to, slice));\n  let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n  if (targetDepths[targetDepths.length - 1] == 0)\n    targetDepths.pop();\n  let preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    let spec = $from.node(d).type.spec;\n    if (spec.defining || spec.definingAsContext || spec.isolating)\n      break;\n    if (targetDepths.indexOf(d) > -1)\n      preferredTarget = d;\n    else if ($from.before(d) == pos)\n      targetDepths.splice(1, 0, -d);\n  }\n  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n  let leftNodes = [], preferredDepth = slice.openStart;\n  for (let content = slice.content, i = 0; ; i++) {\n    let node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart)\n      break;\n    content = node.content;\n  }\n  for (let d = preferredDepth - 1; d >= 0; d--) {\n    let type = leftNodes[d].type, def = definesContent(type);\n    if (def && $from.node(preferredTargetIndex).type != type)\n      preferredDepth = d;\n    else if (def || !type.isTextblock)\n      break;\n  }\n  for (let j = slice.openStart; j >= 0; j--) {\n    let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    let insert = leftNodes[openDepth];\n    if (!insert)\n      continue;\n    for (let i = 0; i < targetDepths.length; i++) {\n      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n      if (targetDepth < 0) {\n        expand = false;\n        targetDepth = -targetDepth;\n      }\n      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n    }\n  }\n  let startSteps = tr.steps.length;\n  for (let i = targetDepths.length - 1; i >= 0; i--) {\n    tr.replace(from, to, slice);\n    if (tr.steps.length > startSteps)\n      break;\n    let depth = targetDepths[i];\n    if (depth < 0)\n      continue;\n    from = $from.before(depth);\n    to = $to.after(depth);\n  }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    let first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n  if (depth > newOpen) {\n    let match = parent.contentMatchAt(0);\n    let start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n  }\n  return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n    let point = insertPoint(tr.doc, from, node.type);\n    if (point != null)\n      from = to = point;\n  }\n  tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n  let covered = coveredDepths($from, $to);\n  for (let i = 0; i < covered.length; i++) {\n    let depth = covered[i], last = i == covered.length - 1;\n    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)\n      return tr.delete($from.start(depth), $to.end(depth));\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n      return tr.delete($from.before(depth), $to.after(depth));\n  }\n  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n      return tr.delete($from.before(d), to);\n  }\n  tr.delete(from, to);\n}\nfunction coveredDepths($from, $to) {\n  let result = [], minDepth = Math.min($from.depth, $to.depth);\n  for (let d = minDepth; d >= 0; d--) {\n    let start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)\n      break;\n    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)\n      result.push(d);\n  }\n  return result;\n}\nclass AttrStep extends Step {\n  constructor(pos, attr, value) {\n    super();\n    this.pos = pos;\n    this.attr = attr;\n    this.value = value;\n  }\n  apply(doc) {\n    let node = doc.nodeAt(this.pos);\n    if (!node)\n      return StepResult.fail(\"No node at attribute step's position\");\n    let attrs = /* @__PURE__ */ Object.create(null);\n    for (let name in node.attrs)\n      attrs[name] = node.attrs[name];\n    attrs[this.attr] = this.value;\n    let updated = node.type.create(attrs, null, node.marks);\n    return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n  }\n  getMap() {\n    return StepMap.empty;\n  }\n  invert(doc) {\n    return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n  }\n  map(mapping) {\n    let pos = mapping.mapResult(this.pos, 1);\n    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n  }\n  toJSON() {\n    return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n  }\n  static fromJSON(schema, json) {\n    if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n      throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n    return new AttrStep(json.pos, json.attr, json.value);\n  }\n}\nStep.jsonID(\"attr\", AttrStep);\nlet TransformError = class extends Error {\n};\nTransformError = function TransformError2(message) {\n  let err = Error.call(this, message);\n  err.__proto__ = TransformError2.prototype;\n  return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\nclass Transform {\n  constructor(doc) {\n    this.doc = doc;\n    this.steps = [];\n    this.docs = [];\n    this.mapping = new Mapping();\n  }\n  get before() {\n    return this.docs.length ? this.docs[0] : this.doc;\n  }\n  step(step) {\n    let result = this.maybeStep(step);\n    if (result.failed)\n      throw new TransformError(result.failed);\n    return this;\n  }\n  maybeStep(step) {\n    let result = step.apply(this.doc);\n    if (!result.failed)\n      this.addStep(step, result.doc);\n    return result;\n  }\n  get docChanged() {\n    return this.steps.length > 0;\n  }\n  addStep(step, doc) {\n    this.docs.push(this.doc);\n    this.steps.push(step);\n    this.mapping.appendMap(step.getMap());\n    this.doc = doc;\n  }\n  replace(from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    let step = replaceStep(this.doc, from, to, slice);\n    if (step)\n      this.step(step);\n    return this;\n  }\n  replaceWith(from, to, content) {\n    return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));\n  }\n  delete(from, to) {\n    return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);\n  }\n  insert(pos, content) {\n    return this.replaceWith(pos, pos, content);\n  }\n  replaceRange(from, to, slice) {\n    replaceRange(this, from, to, slice);\n    return this;\n  }\n  replaceRangeWith(from, to, node) {\n    replaceRangeWith(this, from, to, node);\n    return this;\n  }\n  deleteRange(from, to) {\n    deleteRange(this, from, to);\n    return this;\n  }\n  lift(range, target) {\n    lift(this, range, target);\n    return this;\n  }\n  join(pos, depth = 1) {\n    join(this, pos, depth);\n    return this;\n  }\n  wrap(range, wrappers) {\n    wrap(this, range, wrappers);\n    return this;\n  }\n  setBlockType(from, to = from, type, attrs = null) {\n    setBlockType(this, from, to, type, attrs);\n    return this;\n  }\n  setNodeMarkup(pos, type, attrs = null, marks = []) {\n    setNodeMarkup(this, pos, type, attrs, marks);\n    return this;\n  }\n  setNodeAttribute(pos, attr, value) {\n    this.step(new AttrStep(pos, attr, value));\n    return this;\n  }\n  addNodeMark(pos, mark) {\n    this.step(new AddNodeMarkStep(pos, mark));\n    return this;\n  }\n  removeNodeMark(pos, mark) {\n    if (!(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark)) {\n      let node = this.doc.nodeAt(pos);\n      if (!node)\n        throw new RangeError(\"No node at position \" + pos);\n      mark = mark.isInSet(node.marks);\n      if (!mark)\n        return this;\n    }\n    this.step(new RemoveNodeMarkStep(pos, mark));\n    return this;\n  }\n  split(pos, depth = 1, typesAfter) {\n    split(this, pos, depth, typesAfter);\n    return this;\n  }\n  addMark(from, to, mark) {\n    addMark(this, from, to, mark);\n    return this;\n  }\n  removeMark(from, to, mark) {\n    removeMark(this, from, to, mark);\n    return this;\n  }\n  clearIncompatible(pos, parentType, match) {\n    clearIncompatible(this, pos, parentType, match);\n    return this;\n  }\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-transform/dist/index.js?");

/***/ }),

/***/ "./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Decoration\": () => (/* binding */ Decoration),\n/* harmony export */   \"DecorationSet\": () => (/* binding */ DecorationSet),\n/* harmony export */   \"EditorView\": () => (/* binding */ EditorView),\n/* harmony export */   \"__endComposition\": () => (/* binding */ __endComposition),\n/* harmony export */   \"__parseFromClipboard\": () => (/* binding */ __parseFromClipboard),\n/* harmony export */   \"__serializeForClipboard\": () => (/* binding */ __serializeForClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\nconst domIndex = function(node) {\n  for (var index = 0; ; index++) {\n    node = node.previousSibling;\n    if (!node)\n      return index;\n  }\n};\nconst parentNode = function(node) {\n  let parent = node.assignedSlot || node.parentNode;\n  return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\nconst textRange = function(node, from, to) {\n  let range = reusedRange || (reusedRange = document.createRange());\n  range.setEnd(node, to == null ? node.nodeValue.length : to);\n  range.setStart(node, from || 0);\n  return range;\n};\nconst isEquivalentPosition = function(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (; ; ) {\n    if (node == targetNode && off == targetOff)\n      return true;\n    if (off == (dir < 0 ? 0 : nodeSize(node))) {\n      let parent = node.parentNode;\n      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n        return false;\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      if (node.contentEditable == \"false\")\n        return false;\n      off = dir < 0 ? nodeSize(node) : 0;\n    } else {\n      return false;\n    }\n  }\n}\nfunction nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isOnEdge(node, offset, parent) {\n  for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {\n    if (node == parent)\n      return true;\n    let index = domIndex(node);\n    node = node.parentNode;\n    if (!node)\n      return false;\n    atStart = atStart && index == 0;\n    atEnd = atEnd && index == nodeSize(node);\n  }\n}\nfunction hasBlockDesc(dom) {\n  let desc;\n  for (let cur = dom; cur; cur = cur.parentNode)\n    if (desc = cur.pmViewDesc)\n      break;\n  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\nconst selectionCollapsed = function(domSel) {\n  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n  let event = document.createEvent(\"Event\");\n  event.initEvent(\"keydown\", true, true);\n  event.keyCode = keyCode;\n  event.key = event.code = key;\n  return event;\n}\nfunction deepActiveElement(doc2) {\n  let elt = doc2.activeElement;\n  while (elt && elt.shadowRoot)\n    elt = elt.shadowRoot.activeElement;\n  return elt;\n}\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = nav && nav.userAgent || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\nfunction windowRect(doc2) {\n  return {\n    left: 0,\n    right: doc2.documentElement.clientWidth,\n    top: 0,\n    bottom: doc2.documentElement.clientHeight\n  };\n}\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n  let rect = node.getBoundingClientRect();\n  let scaleX = rect.width / node.offsetWidth || 1;\n  let scaleY = rect.height / node.offsetHeight || 1;\n  return {\n    left: rect.left,\n    right: rect.left + node.clientWidth * scaleX,\n    top: rect.top,\n    bottom: rect.top + node.clientHeight * scaleY\n  };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n  let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n  let doc2 = view.dom.ownerDocument;\n  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {\n    if (!parent)\n      break;\n    if (parent.nodeType != 1)\n      continue;\n    let elt = parent;\n    let atTop = elt == doc2.body;\n    let bounding = atTop ? windowRect(doc2) : clientRect(elt);\n    let moveX = 0, moveY = 0;\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n      moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n      moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n    else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n      moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n    if (moveX || moveY) {\n      if (atTop) {\n        doc2.defaultView.scrollBy(moveX, moveY);\n      } else {\n        let startX = elt.scrollLeft, startY = elt.scrollTop;\n        if (moveY)\n          elt.scrollTop += moveY;\n        if (moveX)\n          elt.scrollLeft += moveX;\n        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };\n      }\n    }\n    if (atTop)\n      break;\n  }\n}\nfunction storeScrollPos(view) {\n  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n  let refDOM, refTop;\n  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {\n    let dom = view.root.elementFromPoint(x, y);\n    if (!dom || dom == view.dom || !view.dom.contains(dom))\n      continue;\n    let localRect = dom.getBoundingClientRect();\n    if (localRect.top >= startY - 20) {\n      refDOM = dom;\n      refTop = localRect.top;\n      break;\n    }\n  }\n  return { refDOM, refTop, stack: scrollStack(view.dom) };\n}\nfunction scrollStack(dom) {\n  let stack = [], doc2 = dom.ownerDocument;\n  for (let cur = dom; cur; cur = parentNode(cur)) {\n    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });\n    if (dom == doc2)\n      break;\n  }\n  return stack;\n}\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n  for (let i = 0; i < stack.length; i++) {\n    let { dom, top, left } = stack[i];\n    if (dom.scrollTop != top + dTop)\n      dom.scrollTop = top + dTop;\n    if (dom.scrollLeft != left)\n      dom.scrollLeft = left;\n  }\n}\nlet preventScrollSupported = null;\nfunction focusPreventScroll(dom) {\n  if (dom.setActive)\n    return dom.setActive();\n  if (preventScrollSupported)\n    return dom.focus(preventScrollSupported);\n  let stored = scrollStack(dom);\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = { preventScroll: true };\n      return true;\n    }\n  } : void 0);\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n    restoreScrollStack(stored, 0);\n  }\n}\nfunction findOffsetInNode(node, coords) {\n  let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n  let rowBot = coords.top, rowTop = coords.top;\n  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    let rects;\n    if (child.nodeType == 1)\n      rects = child.getClientRects();\n    else if (child.nodeType == 3)\n      rects = textRange(child).getClientRects();\n    else\n      continue;\n    for (let i = 0; i < rects.length; i++) {\n      let rect = rects[i];\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot);\n        rowTop = Math.min(rect.top, rowTop);\n        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n        if (dx < dxClosest) {\n          closest = child;\n          dxClosest = dx;\n          coordsClosest = dx && closest.nodeType == 3 ? {\n            left: rect.right < coords.left ? rect.right : rect.left,\n            top: coords.top\n          } : coords;\n          if (child.nodeType == 1 && dx)\n            offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n          continue;\n        }\n      }\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))\n        offset = childIndex + 1;\n    }\n  }\n  if (closest && closest.nodeType == 3)\n    return findOffsetInText(closest, coordsClosest);\n  if (!closest || dxClosest && closest.nodeType == 1)\n    return { node, offset };\n  return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n  let len = node.nodeValue.length;\n  let range = document.createRange();\n  for (let i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    let rect = singleRect(range, 1);\n    if (rect.top == rect.bottom)\n      continue;\n    if (inRect(coords, rect))\n      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n  }\n  return { node, offset: 0 };\n}\nfunction inRect(coords, rect) {\n  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n  let parent = dom.parentNode;\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n    return parent;\n  return dom;\n}\nfunction posFromElement(view, elt, coords) {\n  let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n  if (node.nodeType == 1 && !node.firstChild) {\n    let rect = node.getBoundingClientRect();\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n  }\n  return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n  let outside = -1;\n  for (let cur = node; ; ) {\n    if (cur == view.dom)\n      break;\n    let desc = view.docView.nearestDesc(cur, true);\n    if (!desc)\n      return null;\n    if (desc.node.isBlock && desc.parent) {\n      let rect = desc.dom.getBoundingClientRect();\n      if (rect.left > coords.left || rect.top > coords.top)\n        outside = desc.posBefore;\n      else if (rect.right < coords.left || rect.bottom < coords.top)\n        outside = desc.posAfter;\n      else\n        break;\n    }\n    cur = desc.dom.parentNode;\n  }\n  return outside > -1 ? outside : view.docView.posFromDOM(node, offset, 1);\n}\nfunction elementFromPoint(element, coords, box) {\n  let len = element.childNodes.length;\n  if (len && box.top < box.bottom) {\n    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {\n      let child = element.childNodes[i];\n      if (child.nodeType == 1) {\n        let rects = child.getClientRects();\n        for (let j = 0; j < rects.length; j++) {\n          let rect = rects[j];\n          if (inRect(coords, rect))\n            return elementFromPoint(child, coords, rect);\n        }\n      }\n      if ((i = (i + 1) % len) == startI)\n        break;\n    }\n  }\n  return element;\n}\nfunction posAtCoords(view, coords) {\n  let doc2 = view.dom.ownerDocument, node, offset = 0;\n  if (doc2.caretPositionFromPoint) {\n    try {\n      let pos2 = doc2.caretPositionFromPoint(coords.left, coords.top);\n      if (pos2)\n        ({ offsetNode: node, offset } = pos2);\n    } catch (_) {\n    }\n  }\n  if (!node && doc2.caretRangeFromPoint) {\n    let range = doc2.caretRangeFromPoint(coords.left, coords.top);\n    if (range)\n      ({ startContainer: node, startOffset: offset } = range);\n  }\n  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);\n  let pos;\n  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n    let box = view.dom.getBoundingClientRect();\n    if (!inRect(coords, box))\n      return null;\n    elt = elementFromPoint(view.dom, coords, box);\n    if (!elt)\n      return null;\n  }\n  if (safari) {\n    for (let p = elt; node && p; p = parentNode(p))\n      if (p.draggable)\n        node = void 0;\n  }\n  elt = targetKludge(elt, coords);\n  if (node) {\n    if (gecko && node.nodeType == 1) {\n      offset = Math.min(offset, node.childNodes.length);\n      if (offset < node.childNodes.length) {\n        let next = node.childNodes[offset], box;\n        if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)\n          offset++;\n      }\n    }\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)\n      pos = view.state.doc.content.size;\n    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n      pos = posFromCaret(view, node, offset, coords);\n  }\n  if (pos == null)\n    pos = posFromElement(view, elt, coords);\n  let desc = view.docView.nearestDesc(elt, true);\n  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };\n}\nfunction singleRect(target, bias) {\n  let rects = target.getClientRects();\n  return !rects.length ? target.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\nfunction coordsAtPos(view, pos, side) {\n  let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n  let supportEmptyRange = webkit || gecko;\n  if (node.nodeType == 3) {\n    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n      let rect = singleRect(textRange(node, offset, offset), side);\n      if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n        let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n        if (rectBefore.top == rect.top) {\n          let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n          if (rectAfter.top != rect.top)\n            return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n        }\n      }\n      return rect;\n    } else {\n      let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n      if (side < 0 && !offset) {\n        to++;\n        takeSide = -1;\n      } else if (side >= 0 && offset == node.nodeValue.length) {\n        from--;\n        takeSide = 1;\n      } else if (side < 0) {\n        from--;\n      } else {\n        to++;\n      }\n      return flattenV(singleRect(textRange(node, from, to), 1), takeSide < 0);\n    }\n  }\n  let $dom = view.state.doc.resolve(pos - (atom || 0));\n  if (!$dom.parent.inlineContent) {\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n      let before = node.childNodes[offset - 1];\n      if (before.nodeType == 1)\n        return flattenH(before.getBoundingClientRect(), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n      let after = node.childNodes[offset];\n      if (after.nodeType == 1)\n        return flattenH(after.getBoundingClientRect(), true);\n    }\n    return flattenH(node.getBoundingClientRect(), side >= 0);\n  }\n  if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n    let before = node.childNodes[offset - 1];\n    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n    if (target)\n      return flattenV(singleRect(target, 1), false);\n  }\n  if (atom == null && offset < nodeSize(node)) {\n    let after = node.childNodes[offset];\n    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)\n      after = after.nextSibling;\n    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n    if (target)\n      return flattenV(singleRect(target, -1), true);\n  }\n  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n  if (rect.width == 0)\n    return rect;\n  let x = left ? rect.left : rect.right;\n  return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n}\nfunction flattenH(rect, top) {\n  if (rect.height == 0)\n    return rect;\n  let y = top ? rect.top : rect.bottom;\n  return { top: y, bottom: y, left: rect.left, right: rect.right };\n}\nfunction withFlushedState(view, state, f) {\n  let viewState = view.state, active = view.root.activeElement;\n  if (viewState != state)\n    view.updateState(state);\n  if (active != view.dom)\n    view.focus();\n  try {\n    return f();\n  } finally {\n    if (viewState != state)\n      view.updateState(viewState);\n    if (active != view.dom && active)\n      active.focus();\n  }\n}\nfunction endOfTextblockVertical(view, state, dir) {\n  let sel = state.selection;\n  let $pos = dir == \"up\" ? sel.$from : sel.$to;\n  return withFlushedState(view, state, () => {\n    let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n    for (; ; ) {\n      let nearest = view.docView.nearestDesc(dom, true);\n      if (!nearest)\n        break;\n      if (nearest.node.isBlock) {\n        dom = nearest.dom;\n        break;\n      }\n      dom = nearest.dom.parentNode;\n    }\n    let coords = coordsAtPos(view, $pos.pos, 1);\n    for (let child = dom.firstChild; child; child = child.nextSibling) {\n      let boxes;\n      if (child.nodeType == 1)\n        boxes = child.getClientRects();\n      else if (child.nodeType == 3)\n        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n      else\n        continue;\n      for (let i = 0; i < boxes.length; i++) {\n        let box = boxes[i];\n        if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n          return false;\n      }\n    }\n    return true;\n  });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n  let { $head } = state.selection;\n  if (!$head.parent.isTextblock)\n    return false;\n  let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n  let sel = view.domSelection();\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n    return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n  return withFlushedState(view, state, () => {\n    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n    let oldBidiLevel = sel.caretBidiLevel;\n    sel.modify(\"move\", dir, \"character\");\n    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n    try {\n      sel.collapse(anchorNode, anchorOffset);\n      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)\n        sel.extend(oldNode, oldOff);\n    } catch (_) {\n    }\n    if (oldBidiLevel != null)\n      sel.caretBidiLevel = oldBidiLevel;\n    return result;\n  });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir)\n    return cachedResult;\n  cachedState = state;\n  cachedDir = dir;\n  return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n}\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\nclass ViewDesc {\n  constructor(parent, children, dom, contentDOM) {\n    this.parent = parent;\n    this.children = children;\n    this.dom = dom;\n    this.contentDOM = contentDOM;\n    this.dirty = NOT_DIRTY;\n    dom.pmViewDesc = this;\n  }\n  matchesWidget(widget) {\n    return false;\n  }\n  matchesMark(mark) {\n    return false;\n  }\n  matchesNode(node, outerDeco, innerDeco) {\n    return false;\n  }\n  matchesHack(nodeName) {\n    return false;\n  }\n  parseRule() {\n    return null;\n  }\n  stopEvent(event) {\n    return false;\n  }\n  get size() {\n    let size = 0;\n    for (let i = 0; i < this.children.length; i++)\n      size += this.children[i].size;\n    return size;\n  }\n  get border() {\n    return 0;\n  }\n  destroy() {\n    this.parent = void 0;\n    if (this.dom.pmViewDesc == this)\n      this.dom.pmViewDesc = void 0;\n    for (let i = 0; i < this.children.length; i++)\n      this.children[i].destroy();\n  }\n  posBeforeChild(child) {\n    for (let i = 0, pos = this.posAtStart; ; i++) {\n      let cur = this.children[i];\n      if (cur == child)\n        return pos;\n      pos += cur.size;\n    }\n  }\n  get posBefore() {\n    return this.parent.posBeforeChild(this);\n  }\n  get posAtStart() {\n    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n  }\n  get posAfter() {\n    return this.posBefore + this.size;\n  }\n  get posAtEnd() {\n    return this.posAtStart + this.size - 2 * this.border;\n  }\n  localPosFromDOM(dom, offset, bias) {\n    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n      if (bias < 0) {\n        let domBefore, desc;\n        if (dom == this.contentDOM) {\n          domBefore = dom.childNodes[offset - 1];\n        } else {\n          while (dom.parentNode != this.contentDOM)\n            dom = dom.parentNode;\n          domBefore = dom.previousSibling;\n        }\n        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))\n          domBefore = domBefore.previousSibling;\n        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n      } else {\n        let domAfter, desc;\n        if (dom == this.contentDOM) {\n          domAfter = dom.childNodes[offset];\n        } else {\n          while (dom.parentNode != this.contentDOM)\n            dom = dom.parentNode;\n          domAfter = dom.nextSibling;\n        }\n        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))\n          domAfter = domAfter.nextSibling;\n        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n      }\n    }\n    let atEnd;\n    if (dom == this.dom && this.contentDOM) {\n      atEnd = offset > domIndex(this.contentDOM);\n    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n    } else if (this.dom.firstChild) {\n      if (offset == 0)\n        for (let search = dom; ; search = search.parentNode) {\n          if (search == this.dom) {\n            atEnd = false;\n            break;\n          }\n          if (search.previousSibling)\n            break;\n        }\n      if (atEnd == null && offset == dom.childNodes.length)\n        for (let search = dom; ; search = search.parentNode) {\n          if (search == this.dom) {\n            atEnd = true;\n            break;\n          }\n          if (search.nextSibling)\n            break;\n        }\n    }\n    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n  }\n  nearestDesc(dom, onlyNodes = false) {\n    for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n      let desc = this.getDesc(cur), nodeDOM;\n      if (desc && (!onlyNodes || desc.node)) {\n        if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))\n          first = false;\n        else\n          return desc;\n      }\n    }\n  }\n  getDesc(dom) {\n    let desc = dom.pmViewDesc;\n    for (let cur = desc; cur; cur = cur.parent)\n      if (cur == this)\n        return desc;\n  }\n  posFromDOM(dom, offset, bias) {\n    for (let scan = dom; scan; scan = scan.parentNode) {\n      let desc = this.getDesc(scan);\n      if (desc)\n        return desc.localPosFromDOM(dom, offset, bias);\n    }\n    return -1;\n  }\n  descAt(pos) {\n    for (let i = 0, offset = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size;\n      if (offset == pos && end != offset) {\n        while (!child.border && child.children.length)\n          child = child.children[0];\n        return child;\n      }\n      if (pos < end)\n        return child.descAt(pos - offset - child.border);\n      offset = end;\n    }\n  }\n  domFromPos(pos, side) {\n    if (!this.contentDOM)\n      return { node: this.dom, offset: 0, atom: pos + 1 };\n    let i = 0, offset = 0;\n    for (let curPos = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = curPos + child.size;\n      if (end > pos || child instanceof TrailingHackViewDesc) {\n        offset = pos - curPos;\n        break;\n      }\n      curPos = end;\n    }\n    if (offset)\n      return this.children[i].domFromPos(offset - this.children[i].border, side);\n    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {\n    }\n    if (side <= 0) {\n      let prev, enter = true;\n      for (; ; i--, enter = false) {\n        prev = i ? this.children[i - 1] : null;\n        if (!prev || prev.dom.parentNode == this.contentDOM)\n          break;\n      }\n      if (prev && side && enter && !prev.border && !prev.domAtom)\n        return prev.domFromPos(prev.size, side);\n      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };\n    } else {\n      let next, enter = true;\n      for (; ; i++, enter = false) {\n        next = i < this.children.length ? this.children[i] : null;\n        if (!next || next.dom.parentNode == this.contentDOM)\n          break;\n      }\n      if (next && enter && !next.border && !next.domAtom)\n        return next.domFromPos(0, side);\n      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };\n    }\n  }\n  parseRange(from, to, base = 0) {\n    if (this.children.length == 0)\n      return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };\n    let fromOffset = -1, toOffset = -1;\n    for (let offset = base, i = 0; ; i++) {\n      let child = this.children[i], end = offset + child.size;\n      if (fromOffset == -1 && from <= end) {\n        let childBase = offset + child.border;\n        if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))\n          return child.parseRange(from, to, childBase);\n        from = offset;\n        for (let j = i; j > 0; j--) {\n          let prev = this.children[j - 1];\n          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n            fromOffset = domIndex(prev.dom) + 1;\n            break;\n          }\n          from -= prev.size;\n        }\n        if (fromOffset == -1)\n          fromOffset = 0;\n      }\n      if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n        to = end;\n        for (let j = i + 1; j < this.children.length; j++) {\n          let next = this.children[j];\n          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n            toOffset = domIndex(next.dom);\n            break;\n          }\n          to += next.size;\n        }\n        if (toOffset == -1)\n          toOffset = this.contentDOM.childNodes.length;\n        break;\n      }\n      offset = end;\n    }\n    return { node: this.contentDOM, from, to, fromOffset, toOffset };\n  }\n  emptyChildAt(side) {\n    if (this.border || !this.contentDOM || !this.children.length)\n      return false;\n    let child = this.children[side < 0 ? 0 : this.children.length - 1];\n    return child.size == 0 || child.emptyChildAt(side);\n  }\n  domAfterPos(pos) {\n    let { node, offset } = this.domFromPos(pos, 0);\n    if (node.nodeType != 1 || offset == node.childNodes.length)\n      throw new RangeError(\"No node after pos \" + pos);\n    return node.childNodes[offset];\n  }\n  setSelection(anchor, head, root, force = false) {\n    let from = Math.min(anchor, head), to = Math.max(anchor, head);\n    for (let i = 0, offset = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size;\n      if (from > offset && to < end)\n        return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);\n      offset = end;\n    }\n    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n    let domSel = root.getSelection();\n    let brKludge = false;\n    if ((gecko || safari) && anchor == head) {\n      let { node, offset } = anchorDOM;\n      if (node.nodeType == 3) {\n        brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n        if (brKludge && offset == node.nodeValue.length) {\n          for (let scan = node, after; scan; scan = scan.parentNode) {\n            if (after = scan.nextSibling) {\n              if (after.nodeName == \"BR\")\n                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };\n              break;\n            }\n            let desc = scan.pmViewDesc;\n            if (desc && desc.node && desc.node.isBlock)\n              break;\n          }\n        }\n      } else {\n        let prev = node.childNodes[offset - 1];\n        brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n      }\n    }\n    if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {\n      let after = domSel.focusNode.childNodes[domSel.focusOffset];\n      if (after && after.contentEditable == \"false\")\n        force = true;\n    }\n    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))\n      return;\n    let domSelExtended = false;\n    if ((domSel.extend || anchor == head) && !brKludge) {\n      domSel.collapse(anchorDOM.node, anchorDOM.offset);\n      try {\n        if (anchor != head)\n          domSel.extend(headDOM.node, headDOM.offset);\n        domSelExtended = true;\n      } catch (_) {\n      }\n    }\n    if (!domSelExtended) {\n      if (anchor > head) {\n        let tmp = anchorDOM;\n        anchorDOM = headDOM;\n        headDOM = tmp;\n      }\n      let range = document.createRange();\n      range.setEnd(headDOM.node, headDOM.offset);\n      range.setStart(anchorDOM.node, anchorDOM.offset);\n      domSel.removeAllRanges();\n      domSel.addRange(range);\n    }\n  }\n  ignoreMutation(mutation) {\n    return !this.contentDOM && mutation.type != \"selection\";\n  }\n  get contentLost() {\n    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n  }\n  markDirty(from, to) {\n    for (let offset = 0, i = 0; i < this.children.length; i++) {\n      let child = this.children[i], end = offset + child.size;\n      if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n        let startInside = offset + child.border, endInside = end - child.border;\n        if (from >= startInside && to <= endInside) {\n          this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n          if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))\n            child.dirty = NODE_DIRTY;\n          else\n            child.markDirty(from - startInside, to - startInside);\n          return;\n        } else {\n          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n        }\n      }\n      offset = end;\n    }\n    this.dirty = CONTENT_DIRTY;\n  }\n  markParentsDirty() {\n    let level = 1;\n    for (let node = this.parent; node; node = node.parent, level++) {\n      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n      if (node.dirty < dirty)\n        node.dirty = dirty;\n    }\n  }\n  get domAtom() {\n    return false;\n  }\n  get ignoreForCoords() {\n    return false;\n  }\n}\nclass WidgetViewDesc extends ViewDesc {\n  constructor(parent, widget, view, pos) {\n    let self, dom = widget.type.toDOM;\n    if (typeof dom == \"function\")\n      dom = dom(view, () => {\n        if (!self)\n          return pos;\n        if (self.parent)\n          return self.parent.posBeforeChild(self);\n      });\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        let wrap = document.createElement(\"span\");\n        wrap.appendChild(dom);\n        dom = wrap;\n      }\n      dom.contentEditable = \"false\";\n      dom.classList.add(\"ProseMirror-widget\");\n    }\n    super(parent, [], dom, null);\n    this.widget = widget;\n    this.widget = widget;\n    self = this;\n  }\n  matchesWidget(widget) {\n    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n  }\n  parseRule() {\n    return { ignore: true };\n  }\n  stopEvent(event) {\n    let stop = this.widget.spec.stopEvent;\n    return stop ? stop(event) : false;\n  }\n  ignoreMutation(mutation) {\n    return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n  }\n  destroy() {\n    this.widget.type.destroy(this.dom);\n    super.destroy();\n  }\n  get domAtom() {\n    return true;\n  }\n  get side() {\n    return this.widget.type.side;\n  }\n}\nclass CompositionViewDesc extends ViewDesc {\n  constructor(parent, dom, textDOM, text) {\n    super(parent, [], dom, null);\n    this.textDOM = textDOM;\n    this.text = text;\n  }\n  get size() {\n    return this.text.length;\n  }\n  localPosFromDOM(dom, offset) {\n    if (dom != this.textDOM)\n      return this.posAtStart + (offset ? this.size : 0);\n    return this.posAtStart + offset;\n  }\n  domFromPos(pos) {\n    return { node: this.textDOM, offset: pos };\n  }\n  ignoreMutation(mut) {\n    return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n  }\n}\nclass MarkViewDesc extends ViewDesc {\n  constructor(parent, mark, dom, contentDOM) {\n    super(parent, [], dom, contentDOM);\n    this.mark = mark;\n  }\n  static create(parent, mark, inline, view) {\n    let custom = view.nodeViews[mark.type.name];\n    let spec = custom && custom(mark, view, inline);\n    if (!spec || !spec.dom)\n      spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));\n    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);\n  }\n  parseRule() {\n    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)\n      return null;\n    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 };\n  }\n  matchesMark(mark) {\n    return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n  }\n  markDirty(from, to) {\n    super.markDirty(from, to);\n    if (this.dirty != NOT_DIRTY) {\n      let parent = this.parent;\n      while (!parent.node)\n        parent = parent.parent;\n      if (parent.dirty < this.dirty)\n        parent.dirty = this.dirty;\n      this.dirty = NOT_DIRTY;\n    }\n  }\n  slice(from, to, view) {\n    let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n    let nodes = this.children, size = this.size;\n    if (to < size)\n      nodes = replaceNodes(nodes, to, size, view);\n    if (from > 0)\n      nodes = replaceNodes(nodes, 0, from, view);\n    for (let i = 0; i < nodes.length; i++)\n      nodes[i].parent = copy;\n    copy.children = nodes;\n    return copy;\n  }\n}\nclass NodeViewDesc extends ViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    super(parent, [], dom, contentDOM);\n    this.node = node;\n    this.outerDeco = outerDeco;\n    this.innerDeco = innerDeco;\n    this.nodeDOM = nodeDOM;\n    if (contentDOM)\n      this.updateChildren(view, pos);\n  }\n  static create(parent, node, outerDeco, innerDeco, view, pos) {\n    let custom = view.nodeViews[node.type.name], descObj;\n    let spec = custom && custom(node, view, () => {\n      if (!descObj)\n        return pos;\n      if (descObj.parent)\n        return descObj.parent.posBeforeChild(descObj);\n    }, outerDeco, innerDeco);\n    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n    if (node.isText) {\n      if (!dom)\n        dom = document.createTextNode(node.text);\n      else if (dom.nodeType != 3)\n        throw new RangeError(\"Text must be rendered as a DOM text node\");\n    } else if (!dom) {\n      ({ dom, contentDOM } = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)));\n    }\n    if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n      if (!dom.hasAttribute(\"contenteditable\"))\n        dom.contentEditable = \"false\";\n      if (node.type.spec.draggable)\n        dom.draggable = true;\n    }\n    let nodeDOM = dom;\n    dom = applyOuterDeco(dom, outerDeco, node);\n    if (spec)\n      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n    else if (node.isText)\n      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n    else\n      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n  }\n  parseRule() {\n    if (this.node.type.spec.reparseInView)\n      return null;\n    let rule = { node: this.node.type.name, attrs: this.node.attrs };\n    if (this.node.type.whitespace == \"pre\")\n      rule.preserveWhitespace = \"full\";\n    if (!this.contentDOM) {\n      rule.getContent = () => this.node.content;\n    } else if (!this.contentLost) {\n      rule.contentElement = this.contentDOM;\n    } else {\n      for (let i = this.children.length - 1; i >= 0; i--) {\n        let child = this.children[i];\n        if (this.dom.contains(child.dom.parentNode)) {\n          rule.contentElement = child.dom.parentNode;\n          break;\n        }\n      }\n      if (!rule.contentElement)\n        rule.getContent = () => prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    }\n    return rule;\n  }\n  matchesNode(node, outerDeco, innerDeco) {\n    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n  }\n  get size() {\n    return this.node.nodeSize;\n  }\n  get border() {\n    return this.node.isLeaf ? 0 : 1;\n  }\n  updateChildren(view, pos) {\n    let inline = this.node.inlineContent, off = pos;\n    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n    let localComposition = composition && composition.pos > -1 ? composition : null;\n    let compositionInChild = composition && composition.pos < 0;\n    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n      if (widget.spec.marks)\n        updater.syncToMarks(widget.spec.marks, inline, view);\n      else if (widget.type.side >= 0 && !insideNode)\n        updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view);\n      updater.placeWidget(widget, view, off);\n    }, (child, outerDeco, innerDeco, i) => {\n      updater.syncToMarks(child.marks, inline, view);\n      let compIndex;\n      if (updater.findNodeMatch(child, outerDeco, innerDeco, i))\n        ;\n      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))\n        ;\n      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i))\n        ;\n      else {\n        updater.addNode(child, outerDeco, innerDeco, view, off);\n      }\n      off += child.nodeSize;\n    });\n    updater.syncToMarks([], inline, view);\n    if (this.node.isTextblock)\n      updater.addTextblockHacks();\n    updater.destroyRest();\n    if (updater.changed || this.dirty == CONTENT_DIRTY) {\n      if (localComposition)\n        this.protectLocalComposition(view, localComposition);\n      renderDescs(this.contentDOM, this.children, view);\n      if (ios)\n        iosHacks(this.dom);\n    }\n  }\n  localCompositionInfo(view, pos) {\n    let { from, to } = view.state.selection;\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size)\n      return null;\n    let sel = view.domSelectionRange();\n    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);\n    if (!textNode || !this.dom.contains(textNode.parentNode))\n      return null;\n    if (this.node.inlineContent) {\n      let text = textNode.nodeValue;\n      let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n      return textPos < 0 ? null : { node: textNode, pos: textPos, text };\n    } else {\n      return { node: textNode, pos: -1, text: \"\" };\n    }\n  }\n  protectLocalComposition(view, { node, pos, text }) {\n    if (this.getDesc(node))\n      return;\n    let topNode = node;\n    for (; ; topNode = topNode.parentNode) {\n      if (topNode.parentNode == this.contentDOM)\n        break;\n      while (topNode.previousSibling)\n        topNode.parentNode.removeChild(topNode.previousSibling);\n      while (topNode.nextSibling)\n        topNode.parentNode.removeChild(topNode.nextSibling);\n      if (topNode.pmViewDesc)\n        topNode.pmViewDesc = void 0;\n    }\n    let desc = new CompositionViewDesc(this, topNode, node, text);\n    view.input.compositionNodes.push(desc);\n    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n  }\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))\n      return false;\n    this.updateInner(node, outerDeco, innerDeco, view);\n    return true;\n  }\n  updateInner(node, outerDeco, innerDeco, view) {\n    this.updateOuterDeco(outerDeco);\n    this.node = node;\n    this.innerDeco = innerDeco;\n    if (this.contentDOM)\n      this.updateChildren(view, this.posAtStart);\n    this.dirty = NOT_DIRTY;\n  }\n  updateOuterDeco(outerDeco) {\n    if (sameOuterDeco(outerDeco, this.outerDeco))\n      return;\n    let needsWrap = this.nodeDOM.nodeType != 1;\n    let oldDOM = this.dom;\n    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n    if (this.dom != oldDOM) {\n      oldDOM.pmViewDesc = void 0;\n      this.dom.pmViewDesc = this;\n    }\n    this.outerDeco = outerDeco;\n  }\n  selectNode() {\n    if (this.nodeDOM.nodeType == 1)\n      this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n    if (this.contentDOM || !this.node.type.spec.draggable)\n      this.dom.draggable = true;\n  }\n  deselectNode() {\n    if (this.nodeDOM.nodeType == 1)\n      this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n    if (this.contentDOM || !this.node.type.spec.draggable)\n      this.dom.removeAttribute(\"draggable\");\n  }\n  get domAtom() {\n    return this.node.isAtom;\n  }\n}\nfunction docViewDesc(doc2, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc2);\n  return new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);\n}\nclass TextViewDesc extends NodeViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n  }\n  parseRule() {\n    let skip = this.nodeDOM.parentNode;\n    while (skip && skip != this.dom && !skip.pmIsDeco)\n      skip = skip.parentNode;\n    return { skip: skip || true };\n  }\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))\n      return false;\n    this.updateOuterDeco(outerDeco);\n    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n      this.nodeDOM.nodeValue = node.text;\n      if (view.trackWrites == this.nodeDOM)\n        view.trackWrites = null;\n    }\n    this.node = node;\n    this.dirty = NOT_DIRTY;\n    return true;\n  }\n  inParent() {\n    let parentDOM = this.parent.contentDOM;\n    for (let n = this.nodeDOM; n; n = n.parentNode)\n      if (n == parentDOM)\n        return true;\n    return false;\n  }\n  domFromPos(pos) {\n    return { node: this.nodeDOM, offset: pos };\n  }\n  localPosFromDOM(dom, offset, bias) {\n    if (dom == this.nodeDOM)\n      return this.posAtStart + Math.min(offset, this.node.text.length);\n    return super.localPosFromDOM(dom, offset, bias);\n  }\n  ignoreMutation(mutation) {\n    return mutation.type != \"characterData\" && mutation.type != \"selection\";\n  }\n  slice(from, to, view) {\n    let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n  }\n  markDirty(from, to) {\n    super.markDirty(from, to);\n    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))\n      this.dirty = NODE_DIRTY;\n  }\n  get domAtom() {\n    return false;\n  }\n}\nclass TrailingHackViewDesc extends ViewDesc {\n  parseRule() {\n    return { ignore: true };\n  }\n  matchesHack(nodeName) {\n    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n  }\n  get domAtom() {\n    return true;\n  }\n  get ignoreForCoords() {\n    return this.dom.nodeName == \"IMG\";\n  }\n}\nclass CustomNodeViewDesc extends NodeViewDesc {\n  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n    this.spec = spec;\n  }\n  update(node, outerDeco, innerDeco, view) {\n    if (this.dirty == NODE_DIRTY)\n      return false;\n    if (this.spec.update) {\n      let result = this.spec.update(node, outerDeco, innerDeco);\n      if (result)\n        this.updateInner(node, outerDeco, innerDeco, view);\n      return result;\n    } else if (!this.contentDOM && !node.isLeaf) {\n      return false;\n    } else {\n      return super.update(node, outerDeco, innerDeco, view);\n    }\n  }\n  selectNode() {\n    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n  }\n  deselectNode() {\n    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n  }\n  setSelection(anchor, head, root, force) {\n    this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : super.setSelection(anchor, head, root, force);\n  }\n  destroy() {\n    if (this.spec.destroy)\n      this.spec.destroy();\n    super.destroy();\n  }\n  stopEvent(event) {\n    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n  }\n  ignoreMutation(mutation) {\n    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n  }\n}\nfunction renderDescs(parentDOM, descs, view) {\n  let dom = parentDOM.firstChild, written = false;\n  for (let i = 0; i < descs.length; i++) {\n    let desc = descs[i], childDOM = desc.dom;\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) {\n        dom = rm(dom);\n        written = true;\n      }\n      dom = dom.nextSibling;\n    } else {\n      written = true;\n      parentDOM.insertBefore(childDOM, dom);\n    }\n    if (desc instanceof MarkViewDesc) {\n      let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n      renderDescs(desc.contentDOM, desc.children, view);\n      dom = pos ? pos.nextSibling : parentDOM.firstChild;\n    }\n  }\n  while (dom) {\n    dom = rm(dom);\n    written = true;\n  }\n  if (written && view.trackWrites == parentDOM)\n    view.trackWrites = null;\n}\nconst OuterDecoLevel = function(nodeName) {\n  if (nodeName)\n    this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);\nconst noDeco = [new OuterDecoLevel()];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0)\n    return noDeco;\n  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];\n  for (let i = 0; i < outerDeco.length; i++) {\n    let attrs = outerDeco[i].type.attrs;\n    if (!attrs)\n      continue;\n    if (attrs.nodeName)\n      result.push(top = new OuterDecoLevel(attrs.nodeName));\n    for (let name in attrs) {\n      let val = attrs[name];\n      if (val == null)\n        continue;\n      if (needsWrap && result.length == 1)\n        result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n      if (name == \"class\")\n        top.class = (top.class ? top.class + \" \" : \"\") + val;\n      else if (name == \"style\")\n        top.style = (top.style ? top.style + \";\" : \"\") + val;\n      else if (name != \"nodeName\")\n        top[name] = val;\n    }\n  }\n  return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  if (prevComputed == noDeco && curComputed == noDeco)\n    return nodeDOM;\n  let curDOM = nodeDOM;\n  for (let i = 0; i < curComputed.length; i++) {\n    let deco = curComputed[i], prev = prevComputed[i];\n    if (i) {\n      let parent;\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n        curDOM = parent;\n      } else {\n        parent = document.createElement(deco.nodeName);\n        parent.pmIsDeco = true;\n        parent.appendChild(curDOM);\n        prev = noDeco[0];\n        curDOM = parent;\n      }\n    }\n    patchAttributes(curDOM, prev || noDeco[0], deco);\n  }\n  return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n  for (let name in prev)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n      dom.removeAttribute(name);\n  for (let name in cur)\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n      dom.setAttribute(name, cur[name]);\n  if (prev.class != cur.class) {\n    let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n    let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n    for (let i = 0; i < prevList.length; i++)\n      if (curList.indexOf(prevList[i]) == -1)\n        dom.classList.remove(prevList[i]);\n    for (let i = 0; i < curList.length; i++)\n      if (prevList.indexOf(curList[i]) == -1)\n        dom.classList.add(curList[i]);\n    if (dom.classList.length == 0)\n      dom.removeAttribute(\"class\");\n  }\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n      while (m = prop.exec(prev.style))\n        dom.style.removeProperty(m[1]);\n    }\n    if (cur.style)\n      dom.style.cssText += cur.style;\n  }\n}\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length)\n    return false;\n  for (let i = 0; i < a.length; i++)\n    if (!a[i].type.eq(b[i].type))\n      return false;\n  return true;\n}\nfunction rm(dom) {\n  let next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next;\n}\nclass ViewTreeUpdater {\n  constructor(top, lock, view) {\n    this.lock = lock;\n    this.view = view;\n    this.index = 0;\n    this.stack = [];\n    this.changed = false;\n    this.top = top;\n    this.preMatch = preMatch(top.node.content, top);\n  }\n  destroyBetween(start, end) {\n    if (start == end)\n      return;\n    for (let i = start; i < end; i++)\n      this.top.children[i].destroy();\n    this.top.children.splice(start, end - start);\n    this.changed = true;\n  }\n  destroyRest() {\n    this.destroyBetween(this.index, this.top.children.length);\n  }\n  syncToMarks(marks, inline, view) {\n    let keep = 0, depth = this.stack.length >> 1;\n    let maxKeep = Math.min(depth, marks.length);\n    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n      keep++;\n    while (keep < depth) {\n      this.destroyRest();\n      this.top.dirty = NOT_DIRTY;\n      this.index = this.stack.pop();\n      this.top = this.stack.pop();\n      depth--;\n    }\n    while (depth < marks.length) {\n      this.stack.push(this.top, this.index + 1);\n      let found = -1;\n      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n        if (this.top.children[i].matchesMark(marks[depth])) {\n          found = i;\n          break;\n        }\n      }\n      if (found > -1) {\n        if (found > this.index) {\n          this.changed = true;\n          this.destroyBetween(this.index, found);\n        }\n        this.top = this.top.children[this.index];\n      } else {\n        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n        this.top.children.splice(this.index, 0, markDesc);\n        this.top = markDesc;\n        this.changed = true;\n      }\n      this.index = 0;\n      depth++;\n    }\n  }\n  findNodeMatch(node, outerDeco, innerDeco, index) {\n    let found = -1, targetDesc;\n    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n      found = this.top.children.indexOf(targetDesc, this.index);\n    } else {\n      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n        let child = this.top.children[i];\n        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n          found = i;\n          break;\n        }\n      }\n    }\n    if (found < 0)\n      return false;\n    this.destroyBetween(this.index, found);\n    this.index++;\n    return true;\n  }\n  updateNodeAt(node, outerDeco, innerDeco, index, view) {\n    let child = this.top.children[index];\n    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)\n      child.dirty = CONTENT_DIRTY;\n    if (!child.update(node, outerDeco, innerDeco, view))\n      return false;\n    this.destroyBetween(this.index, index);\n    this.index++;\n    return true;\n  }\n  findIndexWithChild(domNode) {\n    for (; ; ) {\n      let parent = domNode.parentNode;\n      if (!parent)\n        return -1;\n      if (parent == this.top.contentDOM) {\n        let desc = domNode.pmViewDesc;\n        if (desc)\n          for (let i = this.index; i < this.top.children.length; i++) {\n            if (this.top.children[i] == desc)\n              return i;\n          }\n        return -1;\n      }\n      domNode = parent;\n    }\n  }\n  updateNextNode(node, outerDeco, innerDeco, view, index) {\n    for (let i = this.index; i < this.top.children.length; i++) {\n      let next = this.top.children[i];\n      if (next instanceof NodeViewDesc) {\n        let preMatch2 = this.preMatch.matched.get(next);\n        if (preMatch2 != null && preMatch2 != index)\n          return false;\n        let nextDOM = next.dom;\n        let locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n        if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n          this.destroyBetween(this.index, i);\n          if (next.dom != nextDOM)\n            this.changed = true;\n          this.index++;\n          return true;\n        }\n        break;\n      }\n    }\n    return false;\n  }\n  addNode(node, outerDeco, innerDeco, view, pos) {\n    this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));\n    this.changed = true;\n  }\n  placeWidget(widget, view, pos) {\n    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n      this.index++;\n    } else {\n      let desc = new WidgetViewDesc(this.top, widget, view, pos);\n      this.top.children.splice(this.index++, 0, desc);\n      this.changed = true;\n    }\n  }\n  addTextblockHacks() {\n    let lastChild = this.top.children[this.index - 1], parent = this.top;\n    while (lastChild instanceof MarkViewDesc) {\n      parent = lastChild;\n      lastChild = parent.children[parent.children.length - 1];\n    }\n    if (!lastChild || !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n        this.addHackNode(\"IMG\", parent);\n      this.addHackNode(\"BR\", this.top);\n    }\n  }\n  addHackNode(nodeName, parent) {\n    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n      this.index++;\n    } else {\n      let dom = document.createElement(nodeName);\n      if (nodeName == \"IMG\") {\n        dom.className = \"ProseMirror-separator\";\n        dom.alt = \"\";\n      }\n      if (nodeName == \"BR\")\n        dom.className = \"ProseMirror-trailingBreak\";\n      let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n      if (parent != this.top)\n        parent.children.push(hack);\n      else\n        parent.children.splice(this.index++, 0, hack);\n      this.changed = true;\n    }\n  }\n}\nfunction preMatch(frag, parentDesc) {\n  let curDesc = parentDesc, descI = curDesc.children.length;\n  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches = [];\n  outer:\n    while (fI > 0) {\n      let desc;\n      for (; ; ) {\n        if (descI) {\n          let next = curDesc.children[descI - 1];\n          if (next instanceof MarkViewDesc) {\n            curDesc = next;\n            descI = next.children.length;\n          } else {\n            desc = next;\n            descI--;\n            break;\n          }\n        } else if (curDesc == parentDesc) {\n          break outer;\n        } else {\n          descI = curDesc.parent.children.indexOf(curDesc);\n          curDesc = curDesc.parent;\n        }\n      }\n      let node = desc.node;\n      if (!node)\n        continue;\n      if (node != frag.child(fI - 1))\n        break;\n      --fI;\n      matched.set(desc, fI);\n      matches.push(desc);\n    }\n  return { index: fI, matched, matches: matches.reverse() };\n}\nfunction compareSide(a, b) {\n  return a.type.side - b.type.side;\n}\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  let locals = deco.locals(parent), offset = 0;\n  if (locals.length == 0) {\n    for (let i = 0; i < parent.childCount; i++) {\n      let child = parent.child(i);\n      onNode(child, locals, deco.forChild(offset, child), i);\n      offset += child.nodeSize;\n    }\n    return;\n  }\n  let decoIndex = 0, active = [], restNode = null;\n  for (let parentIndex = 0; ; ) {\n    if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      let widget = locals[decoIndex++], widgets;\n      while (decoIndex < locals.length && locals[decoIndex].to == offset)\n        (widgets || (widgets = [widget])).push(locals[decoIndex++]);\n      if (widgets) {\n        widgets.sort(compareSide);\n        for (let i = 0; i < widgets.length; i++)\n          onWidget(widgets[i], parentIndex, !!restNode);\n      } else {\n        onWidget(widget, parentIndex, !!restNode);\n      }\n    }\n    let child, index;\n    if (restNode) {\n      index = -1;\n      child = restNode;\n      restNode = null;\n    } else if (parentIndex < parent.childCount) {\n      index = parentIndex;\n      child = parent.child(parentIndex++);\n    } else {\n      break;\n    }\n    for (let i = 0; i < active.length; i++)\n      if (active[i].to <= offset)\n        active.splice(i--, 1);\n    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n      active.push(locals[decoIndex++]);\n    let end = offset + child.nodeSize;\n    if (child.isText) {\n      let cutAt = end;\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)\n        cutAt = locals[decoIndex].from;\n      for (let i = 0; i < active.length; i++)\n        if (active[i].to < cutAt)\n          cutAt = active[i].to;\n      if (cutAt < end) {\n        restNode = child.cut(cutAt - offset);\n        child = child.cut(0, cutAt - offset);\n        end = cutAt;\n        index = -1;\n      }\n    }\n    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();\n    onNode(child, outerDeco, deco.forChild(offset, child), index);\n    offset = end;\n  }\n}\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    let oldCSS = dom.style.cssText;\n    dom.style.cssText = oldCSS + \"; list-style: square !important\";\n    window.getComputedStyle(dom).listStyle;\n    dom.style.cssText = oldCSS;\n  }\n}\nfunction nearbyTextNode(node, offset) {\n  for (; ; ) {\n    if (node.nodeType == 3)\n      return node;\n    if (node.nodeType == 1 && offset > 0) {\n      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)\n        return node.childNodes[offset];\n      node = node.childNodes[offset - 1];\n      offset = nodeSize(node);\n    } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n      node = node.childNodes[offset];\n      offset = 0;\n    } else {\n      return null;\n    }\n  }\n}\nfunction findTextInFragment(frag, text, from, to) {\n  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {\n    let child = frag.child(i++), childStart = pos;\n    pos += child.nodeSize;\n    if (!child.isText)\n      continue;\n    let str = child.text;\n    while (i < frag.childCount) {\n      let next = frag.child(i++);\n      pos += next.nodeSize;\n      if (!next.isText)\n        break;\n      str += next.text;\n    }\n    if (pos >= from) {\n      let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n      if (found >= 0 && found + text.length + childStart >= from)\n        return childStart + found;\n      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)\n        return to;\n    }\n  }\n  return -1;\n}\nfunction replaceNodes(nodes, from, to, view, replacement) {\n  let result = [];\n  for (let i = 0, off = 0; i < nodes.length; i++) {\n    let child = nodes[i], start = off, end = off += child.size;\n    if (start >= to || end <= from) {\n      result.push(child);\n    } else {\n      if (start < from)\n        result.push(child.slice(0, from - start, view));\n      if (replacement) {\n        result.push(replacement);\n        replacement = void 0;\n      }\n      if (end > to)\n        result.push(child.slice(to - start, child.size, view));\n    }\n  }\n  return result;\n}\nfunction selectionFromDOM(view, origin = null) {\n  let domSel = view.domSelectionRange(), doc2 = view.state.doc;\n  if (!domSel.focusNode)\n    return null;\n  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n  if (head < 0)\n    return null;\n  let $head = doc2.resolve(head), $anchor, selection;\n  if (selectionCollapsed(domSel)) {\n    $anchor = $head;\n    while (nearestDesc && !nearestDesc.node)\n      nearestDesc = nearestDesc.parent;\n    let nearestDescNode = nearestDesc.node;\n    if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n      let pos = nearestDesc.posBefore;\n      selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc2.resolve(pos));\n    }\n  } else {\n    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n    if (anchor < 0)\n      return null;\n    $anchor = doc2.resolve(anchor);\n  }\n  if (!selection) {\n    let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n    selection = selectionBetween(view, $anchor, $head, bias);\n  }\n  return selection;\n}\nfunction editorOwnsSelection(view) {\n  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n  let sel = view.state.selection;\n  syncNodeSelection(view, sel);\n  if (!editorOwnsSelection(view))\n    return;\n  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n      view.input.mouseDown.delayedSelectionSync = true;\n      view.domObserver.setCurSelection();\n      return;\n    }\n  }\n  view.domObserver.disconnectSelection();\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view);\n  } else {\n    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n      if (!sel.$from.parent.inlineContent)\n        resetEditableFrom = temporarilyEditableNear(view, sel.from);\n      if (!sel.empty && !sel.$from.parent.inlineContent)\n        resetEditableTo = temporarilyEditableNear(view, sel.to);\n    }\n    view.docView.setSelection(anchor, head, view.root, force);\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom)\n        resetEditable(resetEditableFrom);\n      if (resetEditableTo)\n        resetEditable(resetEditableTo);\n    }\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\");\n    } else {\n      view.dom.classList.add(\"ProseMirror-hideselection\");\n      if (\"onselectionchange\" in document)\n        removeClassOnSelectionChange(view);\n    }\n  }\n  view.domObserver.setCurSelection();\n  view.domObserver.connectSelection();\n}\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n  let { node, offset } = view.docView.domFromPos(pos, 0);\n  let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n  let before = offset ? node.childNodes[offset - 1] : null;\n  if (safari && after && after.contentEditable == \"false\")\n    return setEditable(after);\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after)\n      return setEditable(after);\n    else if (before)\n      return setEditable(before);\n  }\n}\nfunction setEditable(element) {\n  element.contentEditable = \"true\";\n  if (safari && element.draggable) {\n    element.draggable = false;\n    element.wasDraggable = true;\n  }\n  return element;\n}\nfunction resetEditable(element) {\n  element.contentEditable = \"false\";\n  if (element.wasDraggable) {\n    element.draggable = true;\n    element.wasDraggable = null;\n  }\n}\nfunction removeClassOnSelectionChange(view) {\n  let doc2 = view.dom.ownerDocument;\n  doc2.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n  let domSel = view.domSelectionRange();\n  let node = domSel.anchorNode, offset = domSel.anchorOffset;\n  doc2.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = () => {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc2.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n      setTimeout(() => {\n        if (!editorOwnsSelection(view) || view.state.selection.visible)\n          view.dom.classList.remove(\"ProseMirror-hideselection\");\n      }, 20);\n    }\n  });\n}\nfunction selectCursorWrapper(view) {\n  let domSel = view.domSelection(), range = document.createRange();\n  let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n  if (img)\n    range.setEnd(node.parentNode, domIndex(node) + 1);\n  else\n    range.setEnd(node, 0);\n  range.collapse(false);\n  domSel.removeAllRanges();\n  domSel.addRange(range);\n  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n    node.disabled = true;\n    node.disabled = false;\n  }\n}\nfunction syncNodeSelection(view, sel) {\n  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n    let desc = view.docView.descAt(sel.from);\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view);\n      if (desc)\n        desc.selectNode();\n      view.lastSelectedViewDesc = desc;\n    }\n  } else {\n    clearNodeSelection(view);\n  }\n}\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    if (view.lastSelectedViewDesc.parent)\n      view.lastSelectedViewDesc.deselectNode();\n    view.lastSelectedViewDesc = void 0;\n  }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", (f) => f(view, $anchor, $head)) || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n  if (view.editable && !view.hasFocus())\n    return false;\n  return hasSelection(view);\n}\nfunction hasSelection(view) {\n  let sel = view.domSelectionRange();\n  if (!sel.anchorNode)\n    return false;\n  try {\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n  } catch (_) {\n    return false;\n  }\n}\nfunction anchorInRightPlace(view) {\n  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n  let domSel = view.domSelectionRange();\n  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\nfunction moveSelectionBlock(state, dir) {\n  let { $anchor, $head } = state.selection;\n  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n  return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n  return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n  let sel = view.state.selection;\n  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n    if (!sel.empty || mods.indexOf(\"s\") > -1) {\n      return false;\n    } else if (view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n      let next = moveSelectionBlock(view.state, dir);\n      if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection)\n        return apply(view, next);\n      return false;\n    } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n      if (!node || node.isText)\n        return false;\n      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))\n        return false;\n      if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n      } else if (webkit) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n      } else {\n        return false;\n      }\n    }\n  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n    return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n  } else {\n    let next = moveSelectionBlock(view.state, dir);\n    if (next)\n      return apply(view, next);\n    return false;\n  }\n}\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom) {\n  let desc = dom.pmViewDesc;\n  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodesLeft(view) {\n  let sel = view.domSelectionRange();\n  let node = sel.focusNode, offset = sel.focusOffset;\n  if (!node)\n    return;\n  let moveNode, moveOffset, force = false;\n  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset]))\n    force = true;\n  for (; ; ) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        break;\n      } else {\n        let before = node.childNodes[offset - 1];\n        if (isIgnorable(before)) {\n          moveNode = node;\n          moveOffset = --offset;\n        } else if (before.nodeType == 3) {\n          node = before;\n          offset = node.nodeValue.length;\n        } else\n          break;\n      }\n    } else if (isBlockNode(node)) {\n      break;\n    } else {\n      let prev = node.previousSibling;\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode;\n        moveOffset = domIndex(prev);\n        prev = prev.previousSibling;\n      }\n      if (!prev) {\n        node = node.parentNode;\n        if (node == view.dom)\n          break;\n        offset = 0;\n      } else {\n        node = prev;\n        offset = nodeLen(node);\n      }\n    }\n  }\n  if (force)\n    setSelFocus(view, node, offset);\n  else if (moveNode)\n    setSelFocus(view, moveNode, moveOffset);\n}\nfunction skipIgnoredNodesRight(view) {\n  let sel = view.domSelectionRange();\n  let node = sel.focusNode, offset = sel.focusOffset;\n  if (!node)\n    return;\n  let len = nodeLen(node);\n  let moveNode, moveOffset;\n  for (; ; ) {\n    if (offset < len) {\n      if (node.nodeType != 1)\n        break;\n      let after = node.childNodes[offset];\n      if (isIgnorable(after)) {\n        moveNode = node;\n        moveOffset = ++offset;\n      } else\n        break;\n    } else if (isBlockNode(node)) {\n      break;\n    } else {\n      let next = node.nextSibling;\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode;\n        moveOffset = domIndex(next) + 1;\n        next = next.nextSibling;\n      }\n      if (!next) {\n        node = node.parentNode;\n        if (node == view.dom)\n          break;\n        offset = len = 0;\n      } else {\n        node = next;\n        offset = 0;\n        len = nodeLen(node);\n      }\n    }\n  }\n  if (moveNode)\n    setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n  let desc = dom.pmViewDesc;\n  return desc && desc.node && desc.node.isBlock;\n}\nfunction setSelFocus(view, node, offset) {\n  let sel = view.domSelection();\n  if (selectionCollapsed(sel)) {\n    let range = document.createRange();\n    range.setEnd(node, offset);\n    range.setStart(node, offset);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  } else if (sel.extend) {\n    sel.extend(node, offset);\n  }\n  view.domObserver.setCurSelection();\n  let { state } = view;\n  setTimeout(() => {\n    if (view.state == state)\n      selectionToDOM(view);\n  }, 50);\n}\nfunction selectVertically(view, dir, mods) {\n  let sel = view.state.selection;\n  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1)\n    return false;\n  if (mac && mods.indexOf(\"m\") > -1)\n    return false;\n  let { $from, $to } = sel;\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    let next = moveSelectionBlock(view.state, dir);\n    if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection)\n      return apply(view, next);\n  }\n  if (!$from.parent.inlineContent) {\n    let side = dir < 0 ? $from : $to;\n    let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n    return beyond ? apply(view, beyond) : false;\n  }\n  return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection))\n    return true;\n  let { $head, $anchor, empty: empty2 } = view.state.selection;\n  if (!$head.sameParent($anchor))\n    return true;\n  if (!empty2)\n    return false;\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\"))\n    return true;\n  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n  if (nextNode && !nextNode.isText) {\n    let tr = view.state.tr;\n    if (dir < 0)\n      tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n    else\n      tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n    view.dispatch(tr);\n    return true;\n  }\n  return false;\n}\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop();\n  node.contentEditable = state;\n  view.domObserver.start();\n}\nfunction safariDownArrowBug(view) {\n  if (!safari || view.state.selection.$head.parentOffset > 0)\n    return false;\n  let { focusNode, focusOffset } = view.domSelectionRange();\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    let child = focusNode.firstChild;\n    switchEditable(view, child, \"true\");\n    setTimeout(() => switchEditable(view, child, \"false\"), 20);\n  }\n  return false;\n}\nfunction getMods(event) {\n  let result = \"\";\n  if (event.ctrlKey)\n    result += \"c\";\n  if (event.metaKey)\n    result += \"m\";\n  if (event.altKey)\n    result += \"a\";\n  if (event.shiftKey)\n    result += \"s\";\n  return result;\n}\nfunction captureKeyDown(view, event) {\n  let code = event.keyCode, mods = getMods(event);\n  if (code == 8 || mac && code == 72 && mods == \"c\") {\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);\n  } else if (code == 46 || mac && code == 68 && mods == \"c\") {\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);\n  } else if (code == 13 || code == 27) {\n    return true;\n  } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);\n  } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);\n  } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);\n  } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);\n  } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n    return true;\n  }\n  return false;\n}\nfunction serializeForClipboard(view, slice) {\n  view.someProp(\"transformCopied\", (f) => {\n    slice = f(slice, view);\n  });\n  let context = [], { content, openStart, openEnd } = slice;\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--;\n    openEnd--;\n    let node = content.firstChild;\n    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n    content = node.content;\n  }\n  let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n  let doc2 = detachedDoc(), wrap = doc2.createElement(\"div\");\n  wrap.appendChild(serializer.serializeFragment(content, { document: doc2 }));\n  let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (let i = needsWrap.length - 1; i >= 0; i--) {\n      let wrapper = doc2.createElement(needsWrap[i]);\n      while (wrap.firstChild)\n        wrapper.appendChild(wrap.firstChild);\n      wrap.appendChild(wrapper);\n      wrappers++;\n    }\n    firstChild = wrap.firstChild;\n  }\n  if (firstChild && firstChild.nodeType == 1)\n    firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n  let text = view.someProp(\"clipboardTextSerializer\", (f) => f(slice, view)) || slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n  return { dom: wrap, text };\n}\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n  let inCode = $context.parent.type.spec.code;\n  let dom, slice;\n  if (!html && !text)\n    return null;\n  let asText = text && (plainText || inCode || !html);\n  if (asText) {\n    view.someProp(\"transformPastedText\", (f) => {\n      text = f(text, inCode || plainText, view);\n    });\n    if (inCode)\n      return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;\n    let parsed = view.someProp(\"clipboardTextParser\", (f) => f(text, $context, plainText, view));\n    if (parsed) {\n      slice = parsed;\n    } else {\n      let marks = $context.marks();\n      let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n      dom = document.createElement(\"div\");\n      text.split(/(?:\\r\\n?|\\n)+/).forEach((block) => {\n        let p = dom.appendChild(document.createElement(\"p\"));\n        if (block)\n          p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n      });\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", (f) => {\n      html = f(html, view);\n    });\n    dom = readHTML(html);\n    if (webkit)\n      restoreReplacedSpaces(dom);\n  }\n  let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n  let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n  if (sliceData && sliceData[3])\n    for (let i = +sliceData[3]; i > 0; i--) {\n      let child = dom.firstChild;\n      while (child && child.nodeType != 1)\n        child = child.nextSibling;\n      if (!child)\n        break;\n      dom = child;\n    }\n  if (!slice) {\n    let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    slice = parser.parseSlice(dom, {\n      preserveWhitespace: !!(asText || sliceData),\n      context: $context,\n      ruleFromNode(dom2) {\n        if (dom2.nodeName == \"BR\" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))\n          return { ignore: true };\n        return null;\n      }\n    });\n  }\n  if (sliceData) {\n    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n  } else {\n    slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n    if (slice.openStart || slice.openEnd) {\n      let openStart = 0, openEnd = 0;\n      for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {\n      }\n      for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {\n      }\n      slice = closeSlice(slice, openStart, openEnd);\n    }\n  }\n  view.someProp(\"transformPasted\", (f) => {\n    slice = f(slice, view);\n  });\n  return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2)\n    return fragment;\n  for (let d = $context.depth; d >= 0; d--) {\n    let parent = $context.node(d);\n    let match = parent.contentMatchAt($context.index(d));\n    let lastWrap, result = [];\n    fragment.forEach((node) => {\n      if (!result)\n        return;\n      let wrap = match.findWrapping(node.type), inLast;\n      if (!wrap)\n        return result = null;\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast;\n      } else {\n        if (result.length)\n          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n        let wrapped = withWrappers(node, wrap);\n        result.push(wrapped);\n        match = match.matchType(wrapped.type);\n        lastWrap = wrap;\n      }\n    });\n    if (result)\n      return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n  }\n  return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n  for (let i = wrap.length - 1; i >= from; i--)\n    node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n  return node;\n}\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n    let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n    if (inner)\n      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n    let match = sibling.contentMatchAt(sibling.childCount);\n    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n      return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n  }\n}\nfunction closeRight(node, depth) {\n  if (depth == 0)\n    return node;\n  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n  let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n  return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n  if (depth < to - 1)\n    inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n  if (depth >= from)\n    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n  if (openStart < slice.openStart)\n    slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n  if (openEnd < slice.openEnd)\n    slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n  return slice;\n}\nconst wrapMap = {\n  thead: [\"table\"],\n  tbody: [\"table\"],\n  tfoot: [\"table\"],\n  caption: [\"table\"],\n  colgroup: [\"table\"],\n  col: [\"table\", \"colgroup\"],\n  tr: [\"table\", \"tbody\"],\n  td: [\"table\", \"tbody\", \"tr\"],\n  th: [\"table\", \"tbody\", \"tr\"]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nfunction readHTML(html) {\n  let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n  if (metas)\n    html = html.slice(metas[0].length);\n  let elt = detachedDoc().createElement(\"div\");\n  let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n    html = wrap.map((n) => \"<\" + n + \">\").join(\"\") + html + wrap.map((n) => \"</\" + n + \">\").reverse().join(\"\");\n  elt.innerHTML = html;\n  if (wrap)\n    for (let i = 0; i < wrap.length; i++)\n      elt = elt.querySelector(wrap[i]) || elt;\n  return elt;\n}\nfunction restoreReplacedSpaces(dom) {\n  let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n  for (let i = 0; i < nodes.length; i++) {\n    let node = nodes[i];\n    if (node.childNodes.length == 1 && node.textContent == \"\\xA0\" && node.parentNode)\n      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n  }\n}\nfunction addContext(slice, context) {\n  if (!slice.size)\n    return slice;\n  let schema = slice.content.firstChild.type.schema, array;\n  try {\n    array = JSON.parse(context);\n  } catch (e) {\n    return slice;\n  }\n  let { content, openStart, openEnd } = slice;\n  for (let i = array.length - 2; i >= 0; i -= 2) {\n    let type = schema.nodes[array[i]];\n    if (!type || type.hasRequiredAttrs())\n      break;\n    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n    openStart++;\n    openEnd++;\n  }\n  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = { touchstart: true, touchmove: true };\nclass InputState {\n  constructor() {\n    this.shiftKey = false;\n    this.mouseDown = null;\n    this.lastKeyCode = null;\n    this.lastKeyCodeTime = 0;\n    this.lastClick = { time: 0, x: 0, y: 0, type: \"\" };\n    this.lastSelectionOrigin = null;\n    this.lastSelectionTime = 0;\n    this.lastIOSEnter = 0;\n    this.lastIOSEnterFallbackTimeout = -1;\n    this.lastFocus = 0;\n    this.lastTouch = 0;\n    this.lastAndroidDelete = 0;\n    this.composing = false;\n    this.composingTimeout = -1;\n    this.compositionNodes = [];\n    this.compositionEndedAt = -2e8;\n    this.domChangeCount = 0;\n    this.eventHandlers = /* @__PURE__ */ Object.create(null);\n    this.hideSelectionGuard = null;\n  }\n}\nfunction initInput(view) {\n  for (let event in handlers) {\n    let handler = handlers[event];\n    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {\n      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))\n        handler(view, event2);\n    }, passiveHandlers[event] ? { passive: true } : void 0);\n  }\n  if (safari)\n    view.dom.addEventListener(\"input\", () => null);\n  ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n  view.input.lastSelectionOrigin = origin;\n  view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n  view.domObserver.stop();\n  for (let type in view.input.eventHandlers)\n    view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n  clearTimeout(view.input.composingTimeout);\n  clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", (currentHandlers) => {\n    for (let type in currentHandlers)\n      if (!view.input.eventHandlers[type])\n        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));\n  });\n}\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", (handlers2) => {\n    let handler = handlers2[event.type];\n    return handler ? handler(view, event) || event.defaultPrevented : false;\n  });\n}\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles)\n    return true;\n  if (event.defaultPrevented)\n    return false;\n  for (let node = event.target; node != view.dom; node = node.parentNode)\n    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))\n      return false;\n  return true;\n}\nfunction dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))\n    handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event) => {\n  let event = _event;\n  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n  if (inOrNearComposition(view, event))\n    return;\n  view.input.lastKeyCode = event.keyCode;\n  view.input.lastKeyCodeTime = Date.now();\n  if (android && chrome && event.keyCode == 13)\n    return;\n  if (event.keyCode != 229)\n    view.domObserver.forceFlush();\n  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n    let now = Date.now();\n    view.input.lastIOSEnter = now;\n    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {\n      if (view.input.lastIOSEnter == now) {\n        view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")));\n        view.input.lastIOSEnter = 0;\n      }\n    }, 200);\n  } else if (view.someProp(\"handleKeyDown\", (f) => f(view, event)) || captureKeyDown(view, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"key\");\n  }\n};\neditHandlers.keyup = (view, event) => {\n  if (event.keyCode == 16)\n    view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event) => {\n  let event = _event;\n  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)\n    return;\n  if (view.someProp(\"handleKeyPress\", (f) => f(view, event))) {\n    event.preventDefault();\n    return;\n  }\n  let sel = view.state.selection;\n  if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    let text = String.fromCharCode(event.charCode);\n    if (!view.someProp(\"handleTextInput\", (f) => f(view, sel.$from.pos, sel.$to.pos, text)))\n      view.dispatch(view.state.tr.insertText(text).scrollIntoView());\n    event.preventDefault();\n  }\n};\nfunction eventCoords(event) {\n  return { left: event.clientX, top: event.clientY };\n}\nfunction isNear(event, click) {\n  let dx = click.x - event.clientX, dy = click.y - event.clientY;\n  return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1)\n    return false;\n  let $pos = view.state.doc.resolve(inside);\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n      return true;\n  }\n  return false;\n}\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused)\n    view.focus();\n  let tr = view.state.tr.setSelection(selection);\n  if (origin == \"pointer\")\n    tr.setMeta(\"pointer\", true);\n  view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1)\n    return false;\n  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n  if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n    updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n    return true;\n  }\n  return false;\n}\nfunction selectClickedNode(view, inside) {\n  if (inside == -1)\n    return false;\n  let sel = view.state.selection, selectedNode, selectAt;\n  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection)\n    selectedNode = sel.node;\n  let $pos = view.state.doc.resolve(inside);\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n        selectAt = $pos.before(sel.$from.depth);\n      else\n        selectAt = $pos.before(i);\n      break;\n    }\n  }\n  if (selectAt != null) {\n    updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f) => f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n  if (event.button != 0)\n    return false;\n  let doc2 = view.state.doc;\n  if (inside == -1) {\n    if (doc2.inlineContent) {\n      updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc2, 0, doc2.content.size), \"pointer\");\n      return true;\n    }\n    return false;\n  }\n  let $pos = doc2.resolve(inside);\n  for (let i = $pos.depth + 1; i > 0; i--) {\n    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    let nodePos = $pos.before(i);\n    if (node.inlineContent)\n      updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n    else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n      updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc2, nodePos), \"pointer\");\n    else\n      continue;\n    return true;\n  }\n}\nfunction forceDOMFlush(view) {\n  return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event) => {\n  let event = _event;\n  view.input.shiftKey = event.shiftKey;\n  let flushed = forceDOMFlush(view);\n  let now = Date.now(), type = \"singleClick\";\n  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {\n    if (view.input.lastClick.type == \"singleClick\")\n      type = \"doubleClick\";\n    else if (view.input.lastClick.type == \"doubleClick\")\n      type = \"tripleClick\";\n  }\n  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type };\n  let pos = view.posAtCoords(eventCoords(event));\n  if (!pos)\n    return;\n  if (type == \"singleClick\") {\n    if (view.input.mouseDown)\n      view.input.mouseDown.done();\n    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n  } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"pointer\");\n  }\n};\nclass MouseDown {\n  constructor(view, pos, event, flushed) {\n    this.view = view;\n    this.pos = pos;\n    this.event = event;\n    this.flushed = flushed;\n    this.delayedSelectionSync = false;\n    this.mightDrag = null;\n    this.startDoc = view.state.doc;\n    this.selectNode = !!event[selectNodeModifier];\n    this.allowDefault = event.shiftKey;\n    let targetNode, targetPos;\n    if (pos.inside > -1) {\n      targetNode = view.state.doc.nodeAt(pos.inside);\n      targetPos = pos.inside;\n    } else {\n      let $pos = view.state.doc.resolve(pos.pos);\n      targetNode = $pos.parent;\n      targetPos = $pos.depth ? $pos.before() : 0;\n    }\n    const target = flushed ? null : event.target;\n    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n    this.target = targetDesc ? targetDesc.dom : null;\n    let { selection } = view.state;\n    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n      this.mightDrag = {\n        node: targetNode,\n        pos: targetPos,\n        addAttr: !!(this.target && !this.target.draggable),\n        setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n      };\n    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n      this.view.domObserver.stop();\n      if (this.mightDrag.addAttr)\n        this.target.draggable = true;\n      if (this.mightDrag.setUneditable)\n        setTimeout(() => {\n          if (this.view.input.mouseDown == this)\n            this.target.setAttribute(\"contentEditable\", \"false\");\n        }, 20);\n      this.view.domObserver.start();\n    }\n    view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n    view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n    setSelectionOrigin(view, \"pointer\");\n  }\n  done() {\n    this.view.root.removeEventListener(\"mouseup\", this.up);\n    this.view.root.removeEventListener(\"mousemove\", this.move);\n    if (this.mightDrag && this.target) {\n      this.view.domObserver.stop();\n      if (this.mightDrag.addAttr)\n        this.target.removeAttribute(\"draggable\");\n      if (this.mightDrag.setUneditable)\n        this.target.removeAttribute(\"contentEditable\");\n      this.view.domObserver.start();\n    }\n    if (this.delayedSelectionSync)\n      setTimeout(() => selectionToDOM(this.view));\n    this.view.input.mouseDown = null;\n  }\n  up(event) {\n    this.done();\n    if (!this.view.dom.contains(event.target))\n      return;\n    let pos = this.pos;\n    if (this.view.state.doc != this.startDoc)\n      pos = this.view.posAtCoords(eventCoords(event));\n    this.updateAllowDefault(event);\n    if (this.allowDefault || !pos) {\n      setSelectionOrigin(this.view, \"pointer\");\n    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n      event.preventDefault();\n    } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n      updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n      event.preventDefault();\n    } else {\n      setSelectionOrigin(this.view, \"pointer\");\n    }\n  }\n  move(event) {\n    this.updateAllowDefault(event);\n    setSelectionOrigin(this.view, \"pointer\");\n    if (event.buttons == 0)\n      this.done();\n  }\n  updateAllowDefault(event) {\n    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))\n      this.allowDefault = true;\n  }\n}\nhandlers.touchstart = (view) => {\n  view.input.lastTouch = Date.now();\n  forceDOMFlush(view);\n  setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = (view) => {\n  view.input.lastTouch = Date.now();\n  setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = (view) => forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n  if (view.composing)\n    return true;\n  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n    view.input.compositionEndedAt = -2e8;\n    return true;\n  }\n  return false;\n}\nconst timeoutComposition = android ? 5e3 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = (view) => {\n  if (!view.composing) {\n    view.domObserver.flush();\n    let { state } = view, $pos = state.selection.$from;\n    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {\n      view.markCursor = view.state.storedMarks || $pos.marks();\n      endComposition(view, true);\n      view.markCursor = null;\n    } else {\n      endComposition(view);\n      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n        let sel = view.domSelectionRange();\n        for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {\n          let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n          if (!before)\n            break;\n          if (before.nodeType == 3) {\n            view.domSelection().collapse(before, before.nodeValue.length);\n            break;\n          } else {\n            node = before;\n            offset = -1;\n          }\n        }\n      }\n    }\n    view.input.composing = true;\n  }\n  scheduleComposeEnd(view, timeoutComposition);\n};\neditHandlers.compositionend = (view, event) => {\n  if (view.composing) {\n    view.input.composing = false;\n    view.input.compositionEndedAt = event.timeStamp;\n    scheduleComposeEnd(view, 20);\n  }\n};\nfunction scheduleComposeEnd(view, delay) {\n  clearTimeout(view.input.composingTimeout);\n  if (delay > -1)\n    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);\n}\nfunction clearComposition(view) {\n  if (view.composing) {\n    view.input.composing = false;\n    view.input.compositionEndedAt = timestampFromCustomEvent();\n  }\n  while (view.input.compositionNodes.length > 0)\n    view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction timestampFromCustomEvent() {\n  let event = document.createEvent(\"Event\");\n  event.initEvent(\"event\", true, true);\n  return event.timeStamp;\n}\nfunction endComposition(view, forceUpdate = false) {\n  if (android && view.domObserver.flushingSoon >= 0)\n    return;\n  view.domObserver.forceFlush();\n  clearComposition(view);\n  if (forceUpdate || view.docView && view.docView.dirty) {\n    let sel = selectionFromDOM(view);\n    if (sel && !sel.eq(view.state.selection))\n      view.dispatch(view.state.tr.setSelection(sel));\n    else\n      view.updateState(view.state);\n    return true;\n  }\n  return false;\n}\nfunction captureCopy(view, dom) {\n  if (!view.dom.parentNode)\n    return;\n  let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n  wrap.appendChild(dom);\n  wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  let sel = getSelection(), range = document.createRange();\n  range.selectNodeContents(dom);\n  view.dom.blur();\n  sel.removeAllRanges();\n  sel.addRange(range);\n  setTimeout(() => {\n    if (wrap.parentNode)\n      wrap.parentNode.removeChild(wrap);\n    view.focus();\n  }, 50);\n}\nconst brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\nhandlers.copy = editHandlers.cut = (view, _event) => {\n  let event = _event;\n  let sel = view.state.selection, cut = event.type == \"cut\";\n  if (sel.empty)\n    return;\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n  if (data) {\n    event.preventDefault();\n    data.clearData();\n    data.setData(\"text/html\", dom.innerHTML);\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, dom);\n  }\n  if (cut)\n    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n  if (!view.dom.parentNode)\n    return;\n  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n  if (!plainText)\n    target.contentEditable = \"true\";\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(() => {\n    view.focus();\n    if (target.parentNode)\n      target.parentNode.removeChild(target);\n    if (plainText)\n      doPaste(view, target.value, null, event);\n    else\n      doPaste(view, target.textContent, target.innerHTML, event);\n  }, 50);\n}\nfunction doPaste(view, text, html, event) {\n  let slice = parseFromClipboard(view, text, html, view.input.shiftKey, view.state.selection.$from);\n  if (view.someProp(\"handlePaste\", (f) => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty)))\n    return true;\n  if (!slice)\n    return false;\n  let singleNode = sliceSingleNode(slice);\n  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice);\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n  return true;\n}\neditHandlers.paste = (view, _event) => {\n  let event = _event;\n  if (view.composing && !android)\n    return;\n  let data = brokenClipboardAPI ? null : event.clipboardData;\n  if (data && doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), event))\n    event.preventDefault();\n  else\n    capturePaste(view, event);\n};\nclass Dragging {\n  constructor(slice, move) {\n    this.slice = slice;\n    this.move = move;\n  }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nhandlers.dragstart = (view, _event) => {\n  let event = _event;\n  let mouseDown = view.input.mouseDown;\n  if (mouseDown)\n    mouseDown.done();\n  if (!event.dataTransfer)\n    return;\n  let sel = view.state.selection;\n  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to))\n    ;\n  else if (mouseDown && mouseDown.mightDrag) {\n    view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));\n  } else if (event.target && event.target.nodeType == 1) {\n    let desc = view.docView.nearestDesc(event.target, true);\n    if (desc && desc.node.type.spec.draggable && desc != view.docView)\n      view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore)));\n  }\n  let slice = view.state.selection.content(), { dom, text } = serializeForClipboard(view, slice);\n  event.dataTransfer.clearData();\n  event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n  event.dataTransfer.effectAllowed = \"copyMove\";\n  if (!brokenClipboardAPI)\n    event.dataTransfer.setData(\"text/plain\", text);\n  view.dragging = new Dragging(slice, !event[dragCopyModifier]);\n};\nhandlers.dragend = (view) => {\n  let dragging = view.dragging;\n  window.setTimeout(() => {\n    if (view.dragging == dragging)\n      view.dragging = null;\n  }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();\neditHandlers.drop = (view, _event) => {\n  let event = _event;\n  let dragging = view.dragging;\n  view.dragging = null;\n  if (!event.dataTransfer)\n    return;\n  let eventPos = view.posAtCoords(eventCoords(event));\n  if (!eventPos)\n    return;\n  let $mouse = view.state.doc.resolve(eventPos.pos);\n  let slice = dragging && dragging.slice;\n  if (slice) {\n    view.someProp(\"transformPasted\", (f) => {\n      slice = f(slice, view);\n    });\n  } else {\n    slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n  }\n  let move = !!(dragging && !event[dragCopyModifier]);\n  if (view.someProp(\"handleDrop\", (f) => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n    event.preventDefault();\n    return;\n  }\n  if (!slice)\n    return;\n  event.preventDefault();\n  let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n  if (insertPos == null)\n    insertPos = $mouse.pos;\n  let tr = view.state.tr;\n  if (move)\n    tr.deleteSelection();\n  let pos = tr.mapping.map(insertPos);\n  let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n  let beforeInsert = tr.doc;\n  if (isNode)\n    tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n  else\n    tr.replaceRange(pos, pos, slice);\n  if (tr.doc.eq(beforeInsert))\n    return;\n  let $pos = tr.doc.resolve(pos);\n  if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n    tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n  } else {\n    let end = tr.mapping.map(insertPos);\n    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);\n    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n  }\n  view.focus();\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\nhandlers.focus = (view) => {\n  view.input.lastFocus = Date.now();\n  if (!view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.add(\"ProseMirror-focused\");\n    view.domObserver.start();\n    view.focused = true;\n    setTimeout(() => {\n      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))\n        selectionToDOM(view);\n    }, 20);\n  }\n};\nhandlers.blur = (view, _event) => {\n  let event = _event;\n  if (view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.remove(\"ProseMirror-focused\");\n    view.domObserver.start();\n    if (event.relatedTarget && view.dom.contains(event.relatedTarget))\n      view.domObserver.currentSelection.clear();\n    view.focused = false;\n  }\n};\nhandlers.beforeinput = (view, _event) => {\n  let event = _event;\n  if (chrome && android && event.inputType == \"deleteContentBackward\") {\n    view.domObserver.flushSoon();\n    let { domChangeCount } = view.input;\n    setTimeout(() => {\n      if (view.input.domChangeCount != domChangeCount)\n        return;\n      view.dom.blur();\n      view.focus();\n      if (view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(8, \"Backspace\"))))\n        return;\n      let { $cursor } = view.state.selection;\n      if ($cursor && $cursor.pos > 0)\n        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n    }, 50);\n  }\n};\nfor (let prop in editHandlers)\n  handlers[prop] = editHandlers[prop];\nfunction compareObjs(a, b) {\n  if (a == b)\n    return true;\n  for (let p in a)\n    if (a[p] !== b[p])\n      return false;\n  for (let p in b)\n    if (!(p in a))\n      return false;\n  return true;\n}\nclass WidgetType {\n  constructor(toDOM, spec) {\n    this.toDOM = toDOM;\n    this.spec = spec || noSpec;\n    this.side = this.spec.side || 0;\n  }\n  map(mapping, span, offset, oldOffset) {\n    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n    return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n  }\n  valid() {\n    return true;\n  }\n  eq(other) {\n    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n  }\n  destroy(node) {\n    if (this.spec.destroy)\n      this.spec.destroy(node);\n  }\n}\nclass InlineType {\n  constructor(attrs, spec) {\n    this.attrs = attrs;\n    this.spec = spec || noSpec;\n  }\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n    return from >= to ? null : new Decoration(from, to, this);\n  }\n  valid(_, span) {\n    return span.from < span.to;\n  }\n  eq(other) {\n    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n  }\n  static is(span) {\n    return span.type instanceof InlineType;\n  }\n  destroy() {\n  }\n}\nclass NodeType {\n  constructor(attrs, spec) {\n    this.attrs = attrs;\n    this.spec = spec || noSpec;\n  }\n  map(mapping, span, offset, oldOffset) {\n    let from = mapping.mapResult(span.from + oldOffset, 1);\n    if (from.deleted)\n      return null;\n    let to = mapping.mapResult(span.to + oldOffset, -1);\n    if (to.deleted || to.pos <= from.pos)\n      return null;\n    return new Decoration(from.pos - offset, to.pos - offset, this);\n  }\n  valid(node, span) {\n    let { index, offset } = node.content.findIndex(span.from), child;\n    return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n  }\n  eq(other) {\n    return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n  }\n  destroy() {\n  }\n}\nclass Decoration {\n  constructor(from, to, type) {\n    this.from = from;\n    this.to = to;\n    this.type = type;\n  }\n  copy(from, to) {\n    return new Decoration(from, to, this.type);\n  }\n  eq(other, offset = 0) {\n    return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n  }\n  map(mapping, offset, oldOffset) {\n    return this.type.map(mapping, this, offset, oldOffset);\n  }\n  static widget(pos, toDOM, spec) {\n    return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n  }\n  static inline(from, to, attrs, spec) {\n    return new Decoration(from, to, new InlineType(attrs, spec));\n  }\n  static node(from, to, attrs, spec) {\n    return new Decoration(from, to, new NodeType(attrs, spec));\n  }\n  get spec() {\n    return this.type.spec;\n  }\n  get inline() {\n    return this.type instanceof InlineType;\n  }\n}\nconst none = [], noSpec = {};\nclass DecorationSet {\n  constructor(local, children) {\n    this.local = local.length ? local : none;\n    this.children = children.length ? children : none;\n  }\n  static create(doc2, decorations) {\n    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;\n  }\n  find(start, end, predicate) {\n    let result = [];\n    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n    return result;\n  }\n  findInner(start, end, result, offset, predicate) {\n    for (let i = 0; i < this.local.length; i++) {\n      let span = this.local[i];\n      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n        result.push(span.copy(span.from + offset, span.to + offset));\n    }\n    for (let i = 0; i < this.children.length; i += 3) {\n      if (this.children[i] < end && this.children[i + 1] > start) {\n        let childOff = this.children[i] + 1;\n        this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n      }\n    }\n  }\n  map(mapping, doc2, options) {\n    if (this == empty || mapping.maps.length == 0)\n      return this;\n    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);\n  }\n  mapInner(mapping, node, offset, oldOffset, options) {\n    let newLocal;\n    for (let i = 0; i < this.local.length; i++) {\n      let mapped = this.local[i].map(mapping, offset, oldOffset);\n      if (mapped && mapped.type.valid(node, mapped))\n        (newLocal || (newLocal = [])).push(mapped);\n      else if (options.onRemove)\n        options.onRemove(this.local[i].spec);\n    }\n    if (this.children.length)\n      return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n    else\n      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n  }\n  add(doc2, decorations) {\n    if (!decorations.length)\n      return this;\n    if (this == empty)\n      return DecorationSet.create(doc2, decorations);\n    return this.addInner(doc2, decorations, 0);\n  }\n  addInner(doc2, decorations, offset) {\n    let children, childIndex = 0;\n    doc2.forEach((childNode, childOffset) => {\n      let baseOffset = childOffset + offset, found;\n      if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))\n        return;\n      if (!children)\n        children = this.children.slice();\n      while (childIndex < children.length && children[childIndex] < childOffset)\n        childIndex += 3;\n      if (children[childIndex] == childOffset)\n        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n      else\n        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n      childIndex += 3;\n    });\n    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n    for (let i = 0; i < local.length; i++)\n      if (!local[i].type.valid(doc2, local[i]))\n        local.splice(i--, 1);\n    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n  }\n  remove(decorations) {\n    if (decorations.length == 0 || this == empty)\n      return this;\n    return this.removeInner(decorations, 0);\n  }\n  removeInner(decorations, offset) {\n    let children = this.children, local = this.local;\n    for (let i = 0; i < children.length; i += 3) {\n      let found;\n      let from = children[i] + offset, to = children[i + 1] + offset;\n      for (let j = 0, span; j < decorations.length; j++)\n        if (span = decorations[j]) {\n          if (span.from > from && span.to < to) {\n            decorations[j] = null;\n            (found || (found = [])).push(span);\n          }\n        }\n      if (!found)\n        continue;\n      if (children == this.children)\n        children = this.children.slice();\n      let removed = children[i + 2].removeInner(found, from + 1);\n      if (removed != empty) {\n        children[i + 2] = removed;\n      } else {\n        children.splice(i, 3);\n        i -= 3;\n      }\n    }\n    if (local.length) {\n      for (let i = 0, span; i < decorations.length; i++)\n        if (span = decorations[i]) {\n          for (let j = 0; j < local.length; j++)\n            if (local[j].eq(span, offset)) {\n              if (local == this.local)\n                local = this.local.slice();\n              local.splice(j--, 1);\n            }\n        }\n    }\n    if (children == this.children && local == this.local)\n      return this;\n    return local.length || children.length ? new DecorationSet(local, children) : empty;\n  }\n  forChild(offset, node) {\n    if (this == empty)\n      return this;\n    if (node.isLeaf)\n      return DecorationSet.empty;\n    let child, local;\n    for (let i = 0; i < this.children.length; i += 3)\n      if (this.children[i] >= offset) {\n        if (this.children[i] == offset)\n          child = this.children[i + 2];\n        break;\n      }\n    let start = offset + 1, end = start + node.content.size;\n    for (let i = 0; i < this.local.length; i++) {\n      let dec = this.local[i];\n      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n        let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n        if (from < to)\n          (local || (local = [])).push(dec.copy(from, to));\n      }\n    }\n    if (local) {\n      let localSet = new DecorationSet(local.sort(byPos), none);\n      return child ? new DecorationGroup([localSet, child]) : localSet;\n    }\n    return child || empty;\n  }\n  eq(other) {\n    if (this == other)\n      return true;\n    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)\n      return false;\n    for (let i = 0; i < this.local.length; i++)\n      if (!this.local[i].eq(other.local[i]))\n        return false;\n    for (let i = 0; i < this.children.length; i += 3)\n      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))\n        return false;\n    return true;\n  }\n  locals(node) {\n    return removeOverlap(this.localsInner(node));\n  }\n  localsInner(node) {\n    if (this == empty)\n      return none;\n    if (node.inlineContent || !this.local.some(InlineType.is))\n      return this.local;\n    let result = [];\n    for (let i = 0; i < this.local.length; i++) {\n      if (!(this.local[i].type instanceof InlineType))\n        result.push(this.local[i]);\n    }\n    return result;\n  }\n}\nDecorationSet.empty = new DecorationSet([], []);\nDecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\nclass DecorationGroup {\n  constructor(members) {\n    this.members = members;\n  }\n  map(mapping, doc2) {\n    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));\n    return DecorationGroup.from(mappedDecos);\n  }\n  forChild(offset, child) {\n    if (child.isLeaf)\n      return DecorationSet.empty;\n    let found = [];\n    for (let i = 0; i < this.members.length; i++) {\n      let result = this.members[i].forChild(offset, child);\n      if (result == empty)\n        continue;\n      if (result instanceof DecorationGroup)\n        found = found.concat(result.members);\n      else\n        found.push(result);\n    }\n    return DecorationGroup.from(found);\n  }\n  eq(other) {\n    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)\n      return false;\n    for (let i = 0; i < this.members.length; i++)\n      if (!this.members[i].eq(other.members[i]))\n        return false;\n    return true;\n  }\n  locals(node) {\n    let result, sorted = true;\n    for (let i = 0; i < this.members.length; i++) {\n      let locals = this.members[i].localsInner(node);\n      if (!locals.length)\n        continue;\n      if (!result) {\n        result = locals;\n      } else {\n        if (sorted) {\n          result = result.slice();\n          sorted = false;\n        }\n        for (let j = 0; j < locals.length; j++)\n          result.push(locals[j]);\n      }\n    }\n    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n  }\n  static from(members) {\n    switch (members.length) {\n      case 0:\n        return empty;\n      case 1:\n        return members[0];\n      default:\n        return new DecorationGroup(members);\n    }\n  }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  let children = oldChildren.slice();\n  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {\n    let moved = 0;\n    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {\n      let dSize = newEnd - newStart - (oldEnd - oldStart);\n      for (let i2 = 0; i2 < children.length; i2 += 3) {\n        let end = children[i2 + 1];\n        if (end < 0 || oldStart > end + baseOffset - moved)\n          continue;\n        let start = children[i2] + baseOffset - moved;\n        if (oldEnd >= start) {\n          children[i2 + 1] = oldStart <= start ? -2 : -1;\n        } else if (newStart >= offset && dSize) {\n          children[i2] += dSize;\n          children[i2 + 1] += dSize;\n        }\n      }\n      moved += dSize;\n    });\n    baseOffset = mapping.maps[i].map(baseOffset, -1);\n  }\n  let mustRebuild = false;\n  for (let i = 0; i < children.length; i += 3)\n    if (children[i + 1] < 0) {\n      if (children[i + 1] == -2) {\n        mustRebuild = true;\n        children[i + 1] = -1;\n        continue;\n      }\n      let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n      if (fromLocal < 0 || fromLocal >= node.content.size) {\n        mustRebuild = true;\n        continue;\n      }\n      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n      let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n      let childNode = node.maybeChild(index);\n      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n        let mapped = children[i + 2].mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n        if (mapped != empty) {\n          children[i] = fromLocal;\n          children[i + 1] = toLocal;\n          children[i + 2] = mapped;\n        } else {\n          children[i + 1] = -2;\n          mustRebuild = true;\n        }\n      } else {\n        mustRebuild = true;\n      }\n    }\n  if (mustRebuild) {\n    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n    let built = buildTree(decorations, node, 0, options);\n    newLocal = built.local;\n    for (let i = 0; i < children.length; i += 3)\n      if (children[i + 1] < 0) {\n        children.splice(i, 3);\n        i -= 3;\n      }\n    for (let i = 0, j = 0; i < built.children.length; i += 3) {\n      let from = built.children[i];\n      while (j < children.length && children[j] < from)\n        j += 3;\n      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n    }\n  }\n  return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length)\n    return spans;\n  let result = [];\n  for (let i = 0; i < spans.length; i++) {\n    let span = spans[i];\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n  }\n  return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  function gather(set, oldOffset2) {\n    for (let i = 0; i < set.local.length; i++) {\n      let mapped = set.local[i].map(mapping, offset, oldOffset2);\n      if (mapped)\n        decorations.push(mapped);\n      else if (options.onRemove)\n        options.onRemove(set.local[i].spec);\n    }\n    for (let i = 0; i < set.children.length; i += 3)\n      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);\n  }\n  for (let i = 0; i < children.length; i += 3)\n    if (children[i + 1] == -1)\n      gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n  return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf)\n    return null;\n  let end = offset + node.nodeSize, found = null;\n  for (let i = 0, span; i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n      (found || (found = [])).push(span);\n      spans[i] = null;\n    }\n  }\n  return found;\n}\nfunction withoutNulls(array) {\n  let result = [];\n  for (let i = 0; i < array.length; i++)\n    if (array[i] != null)\n      result.push(array[i]);\n  return result;\n}\nfunction buildTree(spans, node, offset, options) {\n  let children = [], hasNulls = false;\n  node.forEach((childNode, localStart) => {\n    let found = takeSpansForNode(spans, childNode, localStart + offset);\n    if (found) {\n      hasNulls = true;\n      let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n      if (subtree != empty)\n        children.push(localStart, localStart + childNode.nodeSize, subtree);\n    }\n  });\n  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n  for (let i = 0; i < locals.length; i++)\n    if (!locals[i].type.valid(node, locals[i])) {\n      if (options.onRemove)\n        options.onRemove(locals[i].spec);\n      locals.splice(i--, 1);\n    }\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to;\n}\nfunction removeOverlap(spans) {\n  let working = spans;\n  for (let i = 0; i < working.length - 1; i++) {\n    let span = working[i];\n    if (span.from != span.to)\n      for (let j = i + 1; j < working.length; j++) {\n        let next = working[j];\n        if (next.from == span.from) {\n          if (next.to != span.to) {\n            if (working == spans)\n              working = spans.slice();\n            working[j] = next.copy(next.from, span.to);\n            insertAhead(working, j + 1, next.copy(span.to, next.to));\n          }\n          continue;\n        } else {\n          if (next.from < span.to) {\n            if (working == spans)\n              working = spans.slice();\n            working[i] = span.copy(span.from, next.from);\n            insertAhead(working, j, span.copy(next.from, span.to));\n          }\n          break;\n        }\n      }\n  }\n  return working;\n}\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0)\n    i++;\n  array.splice(i, 0, deco);\n}\nfunction viewDecorations(view) {\n  let found = [];\n  view.someProp(\"decorations\", (f) => {\n    let result = f(view.state);\n    if (result && result != empty)\n      found.push(result);\n  });\n  if (view.cursorWrapper)\n    found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n  return DecorationGroup.from(found);\n}\nconst observeOptions = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  attributes: true,\n  attributeOldValue: true,\n  subtree: true\n};\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n  constructor() {\n    this.anchorNode = null;\n    this.anchorOffset = 0;\n    this.focusNode = null;\n    this.focusOffset = 0;\n  }\n  set(sel) {\n    this.anchorNode = sel.anchorNode;\n    this.anchorOffset = sel.anchorOffset;\n    this.focusNode = sel.focusNode;\n    this.focusOffset = sel.focusOffset;\n  }\n  clear() {\n    this.anchorNode = this.focusNode = null;\n  }\n  eq(sel) {\n    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n  }\n}\nclass DOMObserver {\n  constructor(view, handleDOMChange) {\n    this.view = view;\n    this.handleDOMChange = handleDOMChange;\n    this.queue = [];\n    this.flushingSoon = -1;\n    this.observer = null;\n    this.currentSelection = new SelectionState();\n    this.onCharData = null;\n    this.suppressingSelectionUpdates = false;\n    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {\n      for (let i = 0; i < mutations.length; i++)\n        this.queue.push(mutations[i]);\n      if (ie && ie_version <= 11 && mutations.some((m) => m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n        this.flushSoon();\n      else\n        this.flush();\n    });\n    if (useCharData) {\n      this.onCharData = (e) => {\n        this.queue.push({ target: e.target, type: \"characterData\", oldValue: e.prevValue });\n        this.flushSoon();\n      };\n    }\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n  }\n  flushSoon() {\n    if (this.flushingSoon < 0)\n      this.flushingSoon = window.setTimeout(() => {\n        this.flushingSoon = -1;\n        this.flush();\n      }, 20);\n  }\n  forceFlush() {\n    if (this.flushingSoon > -1) {\n      window.clearTimeout(this.flushingSoon);\n      this.flushingSoon = -1;\n      this.flush();\n    }\n  }\n  start() {\n    if (this.observer) {\n      this.observer.takeRecords();\n      this.observer.observe(this.view.dom, observeOptions);\n    }\n    if (this.onCharData)\n      this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    this.connectSelection();\n  }\n  stop() {\n    if (this.observer) {\n      let take = this.observer.takeRecords();\n      if (take.length) {\n        for (let i = 0; i < take.length; i++)\n          this.queue.push(take[i]);\n        window.setTimeout(() => this.flush(), 20);\n      }\n      this.observer.disconnect();\n    }\n    if (this.onCharData)\n      this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n    this.disconnectSelection();\n  }\n  connectSelection() {\n    this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  disconnectSelection() {\n    this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  suppressSelectionUpdates() {\n    this.suppressingSelectionUpdates = true;\n    setTimeout(() => this.suppressingSelectionUpdates = false, 50);\n  }\n  onSelectionChange() {\n    if (!hasFocusAndSelection(this.view))\n      return;\n    if (this.suppressingSelectionUpdates)\n      return selectionToDOM(this.view);\n    if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n      let sel = this.view.domSelectionRange();\n      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n        return this.flushSoon();\n    }\n    this.flush();\n  }\n  setCurSelection() {\n    this.currentSelection.set(this.view.domSelectionRange());\n  }\n  ignoreSelectionChange(sel) {\n    if (!sel.focusNode)\n      return true;\n    let ancestors = /* @__PURE__ */ new Set(), container;\n    for (let scan = sel.focusNode; scan; scan = parentNode(scan))\n      ancestors.add(scan);\n    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))\n      if (ancestors.has(scan)) {\n        container = scan;\n        break;\n      }\n    let desc = container && this.view.docView.nearestDesc(container);\n    if (desc && desc.ignoreMutation({\n      type: \"selection\",\n      target: container.nodeType == 3 ? container.parentNode : container\n    })) {\n      this.setCurSelection();\n      return true;\n    }\n  }\n  flush() {\n    let { view } = this;\n    if (!view.docView || this.flushingSoon > -1)\n      return;\n    let mutations = this.observer ? this.observer.takeRecords() : [];\n    if (this.queue.length) {\n      mutations = this.queue.concat(mutations);\n      this.queue.length = 0;\n    }\n    let sel = view.domSelectionRange();\n    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n    let from = -1, to = -1, typeOver = false, added = [];\n    if (view.editable) {\n      for (let i = 0; i < mutations.length; i++) {\n        let result = this.registerMutation(mutations[i], added);\n        if (result) {\n          from = from < 0 ? result.from : Math.min(result.from, from);\n          to = to < 0 ? result.to : Math.max(result.to, to);\n          if (result.typeOver)\n            typeOver = true;\n        }\n      }\n    }\n    if (gecko && added.length > 1) {\n      let brs = added.filter((n) => n.nodeName == \"BR\");\n      if (brs.length == 2) {\n        let a = brs[0], b = brs[1];\n        if (a.parentNode && a.parentNode.parentNode == b.parentNode)\n          b.remove();\n        else\n          a.remove();\n      }\n    }\n    let readSel = null;\n    if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && view.input.lastTouch < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n      view.input.lastFocus = 0;\n      selectionToDOM(view);\n      this.currentSelection.set(sel);\n      view.scrollToSelection();\n    } else if (from > -1 || newSel) {\n      if (from > -1) {\n        view.docView.markDirty(from, to);\n        checkCSS(view);\n      }\n      this.handleDOMChange(from, to, typeOver, added);\n      if (view.docView && view.docView.dirty)\n        view.updateState(view.state);\n      else if (!this.currentSelection.eq(sel))\n        selectionToDOM(view);\n      this.currentSelection.set(sel);\n    }\n  }\n  registerMutation(mut, added) {\n    if (added.indexOf(mut.target) > -1)\n      return null;\n    let desc = this.view.docView.nearestDesc(mut.target);\n    if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\")))\n      return null;\n    if (!desc || desc.ignoreMutation(mut))\n      return null;\n    if (mut.type == \"childList\") {\n      for (let i = 0; i < mut.addedNodes.length; i++)\n        added.push(mut.addedNodes[i]);\n      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n        return { from: desc.posBefore, to: desc.posAfter };\n      let prev = mut.previousSibling, next = mut.nextSibling;\n      if (ie && ie_version <= 11 && mut.addedNodes.length) {\n        for (let i = 0; i < mut.addedNodes.length; i++) {\n          let { previousSibling, nextSibling } = mut.addedNodes[i];\n          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)\n            prev = previousSibling;\n          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)\n            next = nextSibling;\n        }\n      }\n      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n      let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n      let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n      return { from, to };\n    } else if (mut.type == \"attributes\") {\n      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };\n    } else {\n      return {\n        from: desc.posAtStart,\n        to: desc.posAtEnd,\n        typeOver: mut.target.nodeValue == mut.oldValue\n      };\n    }\n  }\n}\nlet cssChecked = /* @__PURE__ */ new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n  if (cssChecked.has(view))\n    return;\n  cssChecked.set(view, null);\n  if ([\"normal\", \"nowrap\", \"pre-line\"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n    view.requiresGeckoHackNode = gecko;\n    if (cssCheckWarned)\n      return;\n    console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n    cssCheckWarned = true;\n  }\n}\nfunction safariShadowSelectionRange(view) {\n  let found;\n  function read(event) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    found = event.getTargetRanges()[0];\n  }\n  view.dom.addEventListener(\"beforeinput\", read, true);\n  document.execCommand(\"indent\");\n  view.dom.removeEventListener(\"beforeinput\", read, true);\n  let anchorNode = found.startContainer, anchorOffset = found.startOffset;\n  let focusNode = found.endContainer, focusOffset = found.endOffset;\n  let currentAnchor = view.domAtPos(view.state.selection.anchor);\n  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))\n    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n  return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\nfunction parseBetween(view, from_, to_) {\n  let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n  let domSel = view.domSelectionRange();\n  let find;\n  let anchor = domSel.anchorNode;\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{ node: anchor, offset: domSel.anchorOffset }];\n    if (!selectionCollapsed(domSel))\n      find.push({ node: domSel.focusNode, offset: domSel.focusOffset });\n  }\n  if (chrome && view.input.lastKeyCode === 8) {\n    for (let off = toOffset; off > fromOffset; off--) {\n      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n      if (node.nodeName == \"BR\" && !desc) {\n        toOffset = off;\n        break;\n      }\n      if (!desc || desc.size)\n        break;\n    }\n  }\n  let startDoc = view.state.doc;\n  let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n  let $from = startDoc.resolve(from);\n  let sel = null, doc2 = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n    findPositions: find,\n    ruleFromNode,\n    context: $from\n  });\n  if (find && find[0].pos != null) {\n    let anchor2 = find[0].pos, head = find[1] && find[1].pos;\n    if (head == null)\n      head = anchor2;\n    sel = { anchor: anchor2 + from, head: head + from };\n  }\n  return { doc: doc2, sel, from, to };\n}\nfunction ruleFromNode(dom) {\n  let desc = dom.pmViewDesc;\n  if (desc) {\n    return desc.parseRule();\n  } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n      let skip = document.createElement(\"div\");\n      skip.appendChild(document.createElement(\"li\"));\n      return { skip };\n    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n      return { ignore: true };\n    }\n  } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n    return { ignore: true };\n  }\n  return null;\n}\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n  if (from < 0) {\n    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n    let newSel = selectionFromDOM(view, origin);\n    if (newSel && !view.state.selection.eq(newSel)) {\n      let tr2 = view.state.tr.setSelection(newSel);\n      if (origin == \"pointer\")\n        tr2.setMeta(\"pointer\", true);\n      else if (origin == \"key\")\n        tr2.scrollIntoView();\n      view.dispatch(tr2);\n    }\n    return;\n  }\n  let $before = view.state.doc.resolve(from);\n  let shared = $before.sharedDepth(to);\n  from = $before.before(shared + 1);\n  to = view.state.doc.resolve(to).after(shared + 1);\n  let sel = view.state.selection;\n  let parse = parseBetween(view, from, to);\n  let doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);\n  let preferredPos, preferredSide;\n  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n    preferredPos = view.state.selection.to;\n    preferredSide = \"end\";\n  } else {\n    preferredPos = view.state.selection.from;\n    preferredSide = \"start\";\n  }\n  view.input.lastKeyCode = null;\n  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeName == \"DIV\" || n.nodeName == \"P\" || n.nodeName == \"LI\") && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")))) {\n    view.input.lastIOSEnter = 0;\n    return;\n  }\n  if (!change) {\n    if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n      change = { start: sel.from, endA: sel.to, endB: sel.to };\n    } else {\n      if (parse.sel) {\n        let sel2 = resolveSelection(view, view.state.doc, parse.sel);\n        if (sel2 && !sel2.eq(view.state.selection))\n          view.dispatch(view.state.tr.setSelection(sel2));\n      }\n      return;\n    }\n  }\n  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {\n    let size = change.endB - change.start;\n    parse.sel = { anchor: parse.sel.anchor + size, head: parse.sel.anchor + size };\n  }\n  view.input.domChangeCount++;\n  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n      change.start = view.state.selection.from;\n    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n      change.endB += view.state.selection.to - change.endA;\n      change.endA = view.state.selection.to;\n    }\n  }\n  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xA0\") {\n    change.start--;\n    change.endA--;\n    change.endB--;\n  }\n  let $from = parse.doc.resolveNoCache(change.start - parse.from);\n  let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n  let $fromA = doc2.resolve(change.start);\n  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n  let nextSel;\n  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")))) {\n    view.input.lastIOSEnter = 0;\n    return;\n  }\n  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(8, \"Backspace\")))) {\n    if (android && chrome)\n      view.domObserver.suppressSelectionUpdates();\n    return;\n  }\n  if (chrome && android && change.endB == change.start)\n    view.input.lastAndroidDelete = Date.now();\n  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n    change.endB -= 2;\n    $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    setTimeout(() => {\n      view.someProp(\"handleKeyDown\", function(f) {\n        return f(view, keyEvent(13, \"Enter\"));\n      });\n    }, 20);\n  }\n  let chFrom = change.start, chTo = change.endA;\n  let tr, storedMarks, markChange;\n  if (inlineChange) {\n    if ($from.pos == $to.pos) {\n      if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n        view.domObserver.suppressSelectionUpdates();\n        setTimeout(() => selectionToDOM(view), 20);\n      }\n      tr = view.state.tr.delete(chFrom, chTo);\n      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));\n    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n      tr = view.state.tr;\n      if (markChange.type == \"add\")\n        tr.addMark(chFrom, chTo, markChange.mark);\n      else\n        tr.removeMark(chFrom, chTo, markChange.mark);\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n      if (view.someProp(\"handleTextInput\", (f) => f(view, chFrom, chTo, text)))\n        return;\n      tr = view.state.tr.insertText(text, chFrom, chTo);\n    }\n  }\n  if (!tr)\n    tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n  if (parse.sel) {\n    let sel2 = resolveSelection(view, tr.doc, parse.sel);\n    if (sel2 && !(chrome && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))\n      tr.setSelection(sel2);\n  }\n  if (storedMarks)\n    tr.ensureMarks(storedMarks);\n  view.dispatch(tr.scrollIntoView());\n}\nfunction resolveSelection(view, doc2, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)\n    return null;\n  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));\n}\nfunction isMarkChange(cur, prev) {\n  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n  let added = curMarks, removed = prevMarks, type, mark, update;\n  for (let i = 0; i < prevMarks.length; i++)\n    added = prevMarks[i].removeFromSet(added);\n  for (let i = 0; i < curMarks.length; i++)\n    removed = curMarks[i].removeFromSet(removed);\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0];\n    type = \"add\";\n    update = (node) => node.mark(mark.addToSet(node.marks));\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0];\n    type = \"remove\";\n    update = (node) => node.mark(mark.removeFromSet(node.marks));\n  } else {\n    return null;\n  }\n  let updated = [];\n  for (let i = 0; i < prev.childCount; i++)\n    updated.push(update(prev.child(i)));\n  if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur))\n    return { mark, type };\n}\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock || end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n    return false;\n  let $start = old.resolve(start);\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n    return false;\n  let $next = old.resolve(skipClosingAndOpening($start, true, true));\n  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)\n    return false;\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--;\n    end++;\n    fromEnd = false;\n  }\n  if (mayOpen) {\n    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n    while (next && !next.isLeaf) {\n      next = next.firstChild;\n      end++;\n    }\n  }\n  return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  let start = a.findDiffStart(b, pos);\n  if (start == null)\n    return null;\n  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n  if (preferredSide == \"end\") {\n    let adjust = Math.max(0, start - Math.min(endA, endB));\n    preferredPos -= endA + adjust - start;\n  }\n  if (endA < start && a.size < b.size) {\n    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n    start -= move;\n    endB = start + (endB - endA);\n    endA = start;\n  } else if (endB < start) {\n    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n    start -= move;\n    endA = start + (endA - endB);\n    endB = start;\n  }\n  return { start, endA, endB };\n}\nconst __serializeForClipboard = serializeForClipboard;\nconst __parseFromClipboard = parseFromClipboard;\nconst __endComposition = endComposition;\nclass EditorView {\n  constructor(place, props) {\n    this._root = null;\n    this.focused = false;\n    this.trackWrites = null;\n    this.mounted = false;\n    this.markCursor = null;\n    this.cursorWrapper = null;\n    this.lastSelectedViewDesc = void 0;\n    this.input = new InputState();\n    this.prevDirectPlugins = [];\n    this.pluginViews = [];\n    this.requiresGeckoHackNode = false;\n    this.dragging = null;\n    this._props = props;\n    this.state = props.state;\n    this.directPlugins = props.plugins || [];\n    this.directPlugins.forEach(checkStateComponent);\n    this.dispatch = this.dispatch.bind(this);\n    this.dom = place && place.mount || document.createElement(\"div\");\n    if (place) {\n      if (place.appendChild)\n        place.appendChild(this.dom);\n      else if (typeof place == \"function\")\n        place(this.dom);\n      else if (place.mount)\n        this.mounted = true;\n    }\n    this.editable = getEditable(this);\n    updateCursorWrapper(this);\n    this.nodeViews = buildNodeViews(this);\n    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n    this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));\n    this.domObserver.start();\n    initInput(this);\n    this.updatePluginViews();\n  }\n  get composing() {\n    return this.input.composing;\n  }\n  get props() {\n    if (this._props.state != this.state) {\n      let prev = this._props;\n      this._props = {};\n      for (let name in prev)\n        this._props[name] = prev[name];\n      this._props.state = this.state;\n    }\n    return this._props;\n  }\n  update(props) {\n    if (props.handleDOMEvents != this._props.handleDOMEvents)\n      ensureListeners(this);\n    let prevProps = this._props;\n    this._props = props;\n    if (props.plugins) {\n      props.plugins.forEach(checkStateComponent);\n      this.directPlugins = props.plugins;\n    }\n    this.updateStateInner(props.state, prevProps);\n  }\n  setProps(props) {\n    let updated = {};\n    for (let name in this._props)\n      updated[name] = this._props[name];\n    updated.state = this.state;\n    for (let name in props)\n      updated[name] = props[name];\n    this.update(updated);\n  }\n  updateState(state) {\n    this.updateStateInner(state, this._props);\n  }\n  updateStateInner(state, prevProps) {\n    let prev = this.state, redraw = false, updateSel = false;\n    if (state.storedMarks && this.composing) {\n      clearComposition(this);\n      updateSel = true;\n    }\n    this.state = state;\n    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n      let nodeViews = buildNodeViews(this);\n      if (changedNodeViews(nodeViews, this.nodeViews)) {\n        this.nodeViews = nodeViews;\n        redraw = true;\n      }\n    }\n    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n      ensureListeners(this);\n    }\n    this.editable = getEditable(this);\n    updateCursorWrapper(this);\n    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n    if (updateDoc || !state.selection.eq(prev.selection))\n      updateSel = true;\n    let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n    if (updateSel) {\n      this.domObserver.stop();\n      let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n      if (updateDoc) {\n        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n          this.docView.updateOuterDeco([]);\n          this.docView.destroy();\n          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n        }\n        if (chromeKludge && !this.trackWrites)\n          forceSelUpdate = true;\n      }\n      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n        selectionToDOM(this, forceSelUpdate);\n      } else {\n        syncNodeSelection(this, state.selection);\n        this.domObserver.setCurSelection();\n      }\n      this.domObserver.start();\n    }\n    this.updatePluginViews(prev);\n    if (scroll == \"reset\") {\n      this.dom.scrollTop = 0;\n    } else if (scroll == \"to selection\") {\n      this.scrollToSelection();\n    } else if (oldScrollPos) {\n      resetScrollPos(oldScrollPos);\n    }\n  }\n  scrollToSelection() {\n    let startDOM = this.domSelectionRange().focusNode;\n    if (this.someProp(\"handleScrollToSelection\", (f) => f(this)))\n      ;\n    else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n      let target = this.docView.domAfterPos(this.state.selection.from);\n      if (target.nodeType == 1)\n        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n    } else {\n      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n    }\n  }\n  destroyPluginViews() {\n    let view;\n    while (view = this.pluginViews.pop())\n      if (view.destroy)\n        view.destroy();\n  }\n  updatePluginViews(prevState) {\n    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n      this.prevDirectPlugins = this.directPlugins;\n      this.destroyPluginViews();\n      for (let i = 0; i < this.directPlugins.length; i++) {\n        let plugin = this.directPlugins[i];\n        if (plugin.spec.view)\n          this.pluginViews.push(plugin.spec.view(this));\n      }\n      for (let i = 0; i < this.state.plugins.length; i++) {\n        let plugin = this.state.plugins[i];\n        if (plugin.spec.view)\n          this.pluginViews.push(plugin.spec.view(this));\n      }\n    } else {\n      for (let i = 0; i < this.pluginViews.length; i++) {\n        let pluginView = this.pluginViews[i];\n        if (pluginView.update)\n          pluginView.update(this, prevState);\n      }\n    }\n  }\n  someProp(propName, f) {\n    let prop = this._props && this._props[propName], value;\n    if (prop != null && (value = f ? f(prop) : prop))\n      return value;\n    for (let i = 0; i < this.directPlugins.length; i++) {\n      let prop2 = this.directPlugins[i].props[propName];\n      if (prop2 != null && (value = f ? f(prop2) : prop2))\n        return value;\n    }\n    let plugins = this.state.plugins;\n    if (plugins)\n      for (let i = 0; i < plugins.length; i++) {\n        let prop2 = plugins[i].props[propName];\n        if (prop2 != null && (value = f ? f(prop2) : prop2))\n          return value;\n      }\n  }\n  hasFocus() {\n    if (ie) {\n      let node = this.root.activeElement;\n      if (node == this.dom)\n        return true;\n      if (!node || !this.dom.contains(node))\n        return false;\n      while (node && this.dom != node && this.dom.contains(node)) {\n        if (node.contentEditable == \"false\")\n          return false;\n        node = node.parentElement;\n      }\n      return true;\n    }\n    return this.root.activeElement == this.dom;\n  }\n  focus() {\n    this.domObserver.stop();\n    if (this.editable)\n      focusPreventScroll(this.dom);\n    selectionToDOM(this);\n    this.domObserver.start();\n  }\n  get root() {\n    let cached = this._root;\n    if (cached == null)\n      for (let search = this.dom.parentNode; search; search = search.parentNode) {\n        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n          if (!search.getSelection)\n            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();\n          return this._root = search;\n        }\n      }\n    return cached || document;\n  }\n  posAtCoords(coords) {\n    return posAtCoords(this, coords);\n  }\n  coordsAtPos(pos, side = 1) {\n    return coordsAtPos(this, pos, side);\n  }\n  domAtPos(pos, side = 0) {\n    return this.docView.domFromPos(pos, side);\n  }\n  nodeDOM(pos) {\n    let desc = this.docView.descAt(pos);\n    return desc ? desc.nodeDOM : null;\n  }\n  posAtDOM(node, offset, bias = -1) {\n    let pos = this.docView.posFromDOM(node, offset, bias);\n    if (pos == null)\n      throw new RangeError(\"DOM position not inside the editor\");\n    return pos;\n  }\n  endOfTextblock(dir, state) {\n    return endOfTextblock(this, state || this.state, dir);\n  }\n  destroy() {\n    if (!this.docView)\n      return;\n    destroyInput(this);\n    this.destroyPluginViews();\n    if (this.mounted) {\n      this.docView.update(this.state.doc, [], viewDecorations(this), this);\n      this.dom.textContent = \"\";\n    } else if (this.dom.parentNode) {\n      this.dom.parentNode.removeChild(this.dom);\n    }\n    this.docView.destroy();\n    this.docView = null;\n  }\n  get isDestroyed() {\n    return this.docView == null;\n  }\n  dispatchEvent(event) {\n    return dispatchEvent(this, event);\n  }\n  dispatch(tr) {\n    let dispatchTransaction = this._props.dispatchTransaction;\n    if (dispatchTransaction)\n      dispatchTransaction.call(this, tr);\n    else\n      this.updateState(this.state.apply(tr));\n  }\n  domSelectionRange() {\n    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();\n  }\n  domSelection() {\n    return this.root.getSelection();\n  }\n}\nfunction computeDocDeco(view) {\n  let attrs = /* @__PURE__ */ Object.create(null);\n  attrs.class = \"ProseMirror\";\n  attrs.contenteditable = String(view.editable);\n  attrs.translate = \"no\";\n  view.someProp(\"attributes\", (value) => {\n    if (typeof value == \"function\")\n      value = value(view.state);\n    if (value)\n      for (let attr in value) {\n        if (attr == \"class\")\n          attrs.class += \" \" + value[attr];\n        if (attr == \"style\") {\n          attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n        } else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n          attrs[attr] = String(value[attr]);\n      }\n  });\n  return [Decoration.node(0, view.state.doc.content.size, attrs)];\n}\nfunction updateCursorWrapper(view) {\n  if (view.markCursor) {\n    let dom = document.createElement(\"img\");\n    dom.className = \"ProseMirror-separator\";\n    dom.setAttribute(\"mark-placeholder\", \"true\");\n    dom.setAttribute(\"alt\", \"\");\n    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };\n  } else {\n    view.cursorWrapper = null;\n  }\n}\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", (value) => value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n  let result = /* @__PURE__ */ Object.create(null);\n  function add(obj) {\n    for (let prop in obj)\n      if (!Object.prototype.hasOwnProperty.call(result, prop))\n        result[prop] = obj[prop];\n  }\n  view.someProp(\"nodeViews\", add);\n  view.someProp(\"markViews\", add);\n  return result;\n}\nfunction changedNodeViews(a, b) {\n  let nA = 0, nB = 0;\n  for (let prop in a) {\n    if (a[prop] != b[prop])\n      return true;\n    nA++;\n  }\n  for (let _ in b)\n    nB++;\n  return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n    throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n\n\n//# sourceURL=webpack://cms_git/./node_modules/prosemirror-view/dist/index.js?");

/***/ }),

/***/ "./node_modules/w3c-keyname/index.es.js":
/*!**********************************************!*\
  !*** ./node_modules/w3c-keyname/index.es.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"base\": () => (/* binding */ base),\n/* harmony export */   \"keyName\": () => (/* binding */ keyName),\n/* harmony export */   \"shift\": () => (/* binding */ shift)\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n};\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: '\"'\n};\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent);\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nvar brokenModifierNames = mac || chrome && +chrome[1] < 57;\nfor (var i = 0; i < 10; i++)\n  base[48 + i] = base[96 + i] = String(i);\nfor (var i = 1; i <= 24; i++)\n  base[i + 111] = \"F\" + i;\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n}\nfor (var code in base)\n  if (!shift.hasOwnProperty(code))\n    shift[code] = base[code];\nfunction keyName(event) {\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == \"Unidentified\";\n  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || \"Unidentified\";\n  if (name == \"Esc\")\n    name = \"Escape\";\n  if (name == \"Del\")\n    name = \"Delete\";\n  if (name == \"Left\")\n    name = \"ArrowLeft\";\n  if (name == \"Up\")\n    name = \"ArrowUp\";\n  if (name == \"Right\")\n    name = \"ArrowRight\";\n  if (name == \"Down\")\n    name = \"ArrowDown\";\n  return name;\n}\n\n\n//# sourceURL=webpack://cms_git/./node_modules/w3c-keyname/index.es.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/index.js");
/******/ 	
/******/ })()
;